/**

<!-- @page te_agents Test Agents -->

@defgroup te_agents Test Agents
@ingroup te
@{

@section te_agt_introduction Introduction

Test Agent is a piece of software that in general runs on dedicated host and
exports functionality necessary to configure test set-up, generate some
traffic, or receive some statistics from device under test or auxiliary
testing components.
Depending on the particular type of an Agent, it can operate as a single
process or as a set of processes or threads.

The Agent is a component that is intended for future amendments, extensions
and porting to different platforms.

At the time or writing this document TE has Test Agents available for
the following Operating Systems:
- Linux;
- FreBSD;
- Windows.
.

Depending on the physical location of Test Agent and the device it controls
we can differentiate Agents as following:
- <b>Auxiliary Agent</b><br/>
  Test Agent running on an auxiliary station and controlling this station.<br/>
  Test Protocol is used over a network and all commands are applied to
  the station on which Test Agent runs. Such Agents are necessary when
  we do Black Box testing:
  - to emulate presence of some software or hardware component in
    the test set-up;
  - network protocol testing (sending/receiving protocol data);
  - in interoperability testing;
  - external interface testing (SNMP, TR-069, CLI).
  .
  Please note that a Test Agent can be run on the same station as
  @ref te_engine, the only difference is that @cmd{reboot} command should never
  be applied to this Test Agent;
- <b>Proxy Agent</b><br/>
  Test Agent running on an auxiliary station and controlling the DUT.<br/>
  Test Protocol is used over a network and all commands are applied to
  the DUT (Test Agent interacts with the DUT via a DUT-specific interface).<br/>
  This kind of Agent is necessary when we need to be able to configure DUT
  during test scenario or when we want to control some external equipment
  that provides facilities necessary in the particular test scenarios,
  but at the same time we only have some external interfaces exported by DUT
  or auxiliary equipment.
- <b>Embedded Agent</b><br/>
  Test Agent running on a DUT and controlling the DUT.<br/>
  Test Protocol is used over a network or over some other transport 
  (for example, over a serial port) and all commands are applied to the NUT.<br/>
  This kind of Test Agent is necessary when we want to do White Box testing
  (i.e. when we are able to integrate our software components into the DUT):
  - Module testing;
  - DUP API testing;
  - DUT-specific management.
  .

@image html agt_types.png "Possible physical location of Test Agents"

All communication with Test Agents performed via @ref te_engine_rcf components.
Interactions are done with text-based Test Protocol.

@section te_agt_organization Test Agent Organization

Basically Test Agent consists of:
- start-up code;
- generic implementation of PCH functions (@path{lib/rcfpch});
- OS-specific implementation of some PCH functions
  (rcf_ch_start_process(), rcf_ch_start_thread(), etc.);
- OS-specific implementation of callbacks for configurator tree;
- a set of functions used in RPC;
- a number of standard RCF Services supported in separate libraries
  (like TAD).
.

@image html ta_decomp.png "Test Agent decomposition"

<!--
@startditaa "ditaa ta_rcfpch.png -S"
+----------------------------------------------------------------------------------------------+
|                                                                                  Test Agent  |
:                                                                                  ----------  |
|   +------------------------------------------------------------------------+                 |
|   |                                RCF PCH                                 |                 |
|   |                               lib/rcfpch                               |                 |
|   +----+-------------------+-------------------+----------------------+----+                 |
|        |                   |                   |                      |                      |
|        |                   |                   |                      |                      |
|        v                   v                   |                      v                      |
|  +-----------+     +----------------+          |           +----------------------+          |
|  |    TAD    |     |    PCH CFG     |          |           |      RPC Server      |          |
|  |  lib/tad  |     |  lib/rcfpch/   |          |           |      lib/rcfpch/     |          |
|  |           |     | rcf_pch_conf.c |          |           | rcf_pch_rpc_server.c |          |
|  +-----------+     +-------+--------+          |           +--+----------------+--+          |
|                            |                   |              |                |             |
|         +------------------|--=----------------|--=-----------|--=-------------|----------+  |
|         :                  |                   |              |                |          |  |
|         |                  v                   v              v                v          |  |
|         |      +-----------------------+   +----------------------+     +-------------+   |  |
|         |      |   Configurator tree   |   | rcf_ch_start_process |     |  RPC Calls  |   |  |
|         |      |     node handlers     |   | rcf_ch_start_thread  |     |             |   |  |
|         |      |                       |   | ...                  |     +-------------+   |  |
|         |      +-----------------------+   +----------------------+                       |  |
|         |                                                                                 |  |
|         |                                                     OS -specific part           |  |
|         +---------------------------------------------------------------------------------+  |
+----------------------------------------------------------------------------------------------+
@endditaa
-->

On start-up Test Agent does the following things:
- calls ta_log_init() to initialize logger API;
- if a Test Agent supports process or thread creation
  (rcf_ch_start_process(), and rcf_ch_start_thread() are supported),
  then it is necessary to create a separate thread or process that
  will receive log messages from different processes and threads
  run on behalf of Test Agent.
  @path{lib/loggerta} library exports logfork_entry() function that
  should be used as an entry
  point for such a thread/process;
- calls rcf_pch_run() function that passes control to
  RCF Portable Command Handler.
.

In RCF PCH Test Agent passively waits for @ref te_engine_rcf commands.
RCF commands are handled in the main loop of RCF PCH library.
Depending on the command type it can be handled either by generic part of
RCF PCH (located under @path{lib/rcfpch}) or it can be directed to
Agent specific parts of code (located under @path{agents/[type]}).

Functions declared in lib/rcfpch/rcf_ch_api.h should be exported
by a Test Agent, though they can return -1 telling that an operation
is not supported.

@section te_agt_types Types of supported Test Agents

Currently we support two main types of @ref te_agents:
- @ref te_agents_win;
- @ref te_agents_unix.
.

@section te_agt_extending Extending Test Agent with new functionality

@subsection te_agt_extending_rpc Adding new RPC calls

- @ref tapi_rpc page gives guidelines on how to add support for a new RPC call.
.

@subsection te_agt_extending_cfg Adding new configuration nodes

- @ref te_agents_conf page gives guidelines on how to add new configuration
nodes to Test Agent;
- @ref confapi page gives guidelines on how to work with API from test scenarios.
.

@} <!-- END te_agents -->




<!-- @page te_agents_conf Test Agents: Creating new configuration nodes in Test Agent -->

@defgroup te_agents_conf Test Agents: Creating new configuration nodes in Test Agent
@ingroup te_agents
@{

@section Introduction

@copydetails lib/confapi/conf_api.h

Details of API usage can be found at @ref confapi page.

Here we will explain how to add support for a new objects and instances
on Test Agent side.

@section te_agt_extending_cfg_design Design of configuration nodes

First thing to do while creating new configuration nodes is to design
structure of new nodes, their relationship, access rights and types of
value kept by them.

Descriptions of configuration nodes are kept under @path{doc/cm} directory
(@path{cm} is derived from Configuration Model). You should update one of
existing files or create a new one with information about your new nodes.

The format of Configuration Model files complies to format of
@ref te_engine_conf backups, which makes it possible to use lines from these
files in @ref te_engine_conf configuration file when you need to add this or
that object into your run time configuration.

Read some more information about configuration objects and instances at
@ref te_engine_conf_tree.

In our example we will define the following objects:

@code
  <!-- An example of read-only object with integer type of value.
       Name: an arbitrary string -->
  <object oid="/agent/ro_object" access="read_only" type="integer"/>
  
  <!-- An example of read-write object with address type of value.
       Name: an arbitrary string -->
  <object oid="/agent/rw_object" access="read_write" type="address"/>


  <!-- An example of collection object.
       Name: an arbitrary string -->
  <object oid="/agent/col_object" access="read_create" type="none"/>

  <!-- An example of a child node of a collection object.
       Name: an arbitrary string -->
  <object oid="/agent/col_object/var" access="read_only" type="string"/>
@endcode

@section te_agt_extending_cfg_init Test Agent initialization

On Test Agent start-up we should pass control to PCH (Portable Command Handler)
main loop function rcf_pch_run(). As a part of initialization process for
configuration support rcf_pch_run() function calls:
- rcf_ch_conf_init() - to do all Test Agent specific initialization.
.

In rcf_ch_conf_init() function you should register all object nodes that
Test Agent will support during its operation. Nodes are registered to RCF PCH
with rcf_pch_add_node() function where you specify parent object path
and pointer to object description structure of rcf_pch_cfg_object type.

@image html ta_conf_call_diagram.png "Test Agent configuration support event sequence diagram"

To specify node description you should use @ref rcf_ch_cfg_node_def.

For example definition of nodes of our sample might look like:

@code
RCF_PCH_CFG_NODE_RO(ro_node, "ro_object", NULL, NULL, ro_object_get);
RCF_PCH_CFG_NODE_RW(rw_node, "rw_object", NULL,
                    &ro_node, /* neighbor node */
                    rw_object_get, rw_object_set);

RCF_PCH_CFG_NODE_RO(col_obj_var, "var", NULL, NULL, var_get);
RCF_PCH_CFG_NODE_COLLECTION(col_node, "col_object",
                            &col_obj_var, /* son node */
                            &rw_node, /* bother node (neighbor node) */
                            NULL, NULL, col_list, NULL);
@endcode

These definitions should be placed in the source of Test Agent.
Then in the implementation of rcf_ch_conf_init() you should put
the following line of code that will register your configuration subtree:

@code
int
rcf_ch_conf_init(void)
{
    ...
    if (rcf_pch_add_node("/agent", &col_node) != 0)
    {
        /* Do error handling */
    }
    ...
}
@endcode

@section te_agt_extending_cfg_handlers Implementation of node handlers

The main thing to be done is to define node handlers that in most cases
interact with system interfaces to get necessary value or to update
system settings.

All data exchange between PCH and CH is done in terms of strings.
For example if we have a node with the value of integer type we should
anyway return value in a character string form and on set operation
the value passed to a callback is in a character string form.

Implementation of handlers for @p ro_object and @p rw_object objects
might look like the following:

@code
static te_errno
ro_object_get(unsigned int gid, const char *oid, char *value, const char *instN,...)
{
    int val;

    /*
     * Some comments about function parameters:
     * gid - Identifier associated with an operation
     *       (make sense for SET and COMMIT operations);
     * oid - Object instance identifier whose value to get;
     * value - buffer of RCF_MAX_VAL size to fill with value;
     * instN... - the list of instance names of nodes
     *            in "oid" starting from the son of "/agent" node.
     *            For example for "oid": "/agent:Agt_A/ro_object:"
     *            "instN" will be an empty string, and the next
     *            element of the list will be NULL.
     *            for "oid": "/agent:Agt_A/col_object:a/var:"
     *            "instN" will be "a", the next element will be an
     *            empty string and the third element will be NULL.
     */

    ...
    /* Get value of integer type */
    ...
    snprintf(value, RCF_MAX_VAL, "%d", val);
    return 0;
}

static te_errno
rw_object_get(unsigned int gid, const char *oid, char *value, const char *instN,...)
{
    ...
    /* Get the value of address type */
    ...
    /* Save address value in the return buffer in string format */
    if (inet_ntop(af, addr, value, RCF_MAX_VAL) == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    return 0;
}

static te_errno
rw_object_set(unsigned int gid, const char *oid, const char *value, const char *instN,...)
{
    if (inet_pton(AF_INET, value, addr_buf) == 1)
        af= AF_INET;
    else if (inet_pton(AF_INET6, value, addr_buf) == 1)
        af = AF_INET6;
    else
        ...

    /* Do something with address value */

    return 0;
}
@endcode

Please note that for scalar (not collection) objects instance name will be an empty string.

Implementation of handlers for @p col_object might look like the following:

@code
static te_errno
var_get(unsigned int gid, const char *oid, char *value, const char *instN,...)
{
    /*
     * oid - "/agent:<agt_name>/col_object:<inst_name>/var:",
     *       where "agt_name" is an agent name where this code runs,
     *             "inst_name" is collection object instance name,
     *             in our sample it is one of: '1', '2', '3', '4'.
     * value - buffer of RCF_MAX_VAL size to fill with some string value;
     * instN... - the list of instance names of nodes.
     *            For our sample "instN" would be one of: '1', '2', '3', '4'.
     *            Next element of the list would be an empty string
     *            (as the instance name of "var" node), and the third entry
     *            would be NULL.
     */
    snprintf(value, RCF_MAX_VAL, "STRING VALUE for '%s'", instN);

    return 0;
}

/*
 * The function returns the list of instance names of "col_object" object.
 * Instance names are arbitrary strings that better fits your design.
 */
static te_errno
col_list(unsigned int gid, const char *oid, char **list, const char *instN,...)
{
    /*
     * Here we return predefined list of four instance names:
     * '1', '2', '3', '4'.
     * More natuarally this list would grow dynamically depending on
     * some system attributes. The list can vary from call to call.
     */
    *list = strdup("1 2 3 4");
    if (*list == NULL)
        TE_RC(TE_TA_UNIX, TE_ENOMEM);

    return 0;
}
@endcode

Collection nodes can support synamic @cmd{add}/@cmd{del} operations which
require implementation of corresponding handlers:

@code
RCF_PCH_CFG_NODE_COLLECTION(col_node, "col_object",
                            &col_obj_var, /* son node */
                            &rw_node, /* bother node (neighbor node) */
                            col_add, col_del, col_list, NULL);

static te_errno
col_add(unsigned int gid, const char *oid, const char *value, const char *instN,...)
{
    /*
     * Add a new instance whose name is "instN".
     * In case we successfully added an entry, the next call to
     * col_list() function shall include this new instance name
     * into the list of instance names.
     */

    /* Install a new entry that is associated with name instN */
    
    return 0;
}

static te_errno
col_del(unsigned int gid, const char *oid, const char *instN,...)
{
    /*
     * Remove an entry whose instance name is instN.
     * The next call to col_list() function shall not include
     * this instance name in returned list of instance names.
     */

    /* Deinstall an entry from the system */

    return 0;
}
@endcode

Apart from basic @cmd{get}/@cmd{set}/@cmd{list}/@cmd{add}/@cmd{del} handlers
there is one more handler rcf_pch_cfg_object::commit that is additionally
called for each successful @cmd{set}/@cmd{add}/@cmd{del} operation.
There are two modes of @cmd{commit} call:
- immediate call (@cmd{commit} is called after successful completion of
  @cmd{set}/@cmd{add}/@cmd{del} operation);
- postponed call (@cmd{commit} functions are called after a series of
  @cmd{set}/@cmd{add}/@cmd{del} operations and duplicate commit calls are avoided).
.

@image html ta_conf_commit_immediate.png "Commit calls in case of ordinary SET calls"

@image html ta_conf_commit_group.png "Commit calls in case of group context SET calls"

Please note that in the group call case the particular @cmd{commit} function
is called only once - in our sample @cmd{commit_X()} is called once though
it is a @cmd{commit} function for @conf_path{/X/a} and @conf_path{/X/c}
objects whose instances are updated.

Usually the commit function is specified in parent node and children nodes
refer to parent node with RCF_PCH_CFG_NODE_RWC() macro:

@code
static rcf_pch_cfg_object col_node;
RCF_PCH_CFG_NODE_RWC(col_obj_var2, "var2", NULL, NULL,
                     var2_get, var2_set,
                     &col_node);
RCF_PCH_CFG_NODE_RWC(col_obj_var1, "var1", NULL,
                     &col_obj_var2, /* brother node */
                     var1_get, var1_set,
                     &col_node);
RCF_PCH_CFG_NODE_COLLECTION(col_node, "col_object",
                            &col_obj_var1, /* son node */
                            &rw_node, /* bother node (neighbor node) */
                            col_add, col_del, col_list, col_commit);
@endcode

Please note that @cmd{add}/@cmd{del}/@cmd{set} handlers have no way to detect what
the calling mode takes place (immediate @cmd{commit} or postponed @cmd{commit}).
The only thing to keep in mind is that commit will be called anyway.

@} <!-- END te_agents_conf -->

 */

