/** @file
 * @brief Unix Test Agent
 *
 * OpenVPN configurator tree
 *
 * Copyright (C) 2004-2018 OKTET Labs. All rights reserved.
 *
 * @author Svetlana Fishchuk <Svetlana.Fishchuk@oktetlabs.ru>
 */

#include "te_config.h"
#if HAVE_CONFIG_H
#include "config.h"
#endif

#include "conf_daemons_internal.h"
#include "te_str.h"
#include "te_string.h"
#include "te_sockaddr.h"
#include "rcf_pch.h"

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509.h>

#include <limits.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <linux/if_link.h>
#include <libgen.h>

/** Maximum buffer size for some of arrays */
#define AUX_BUF_LEN (256)

/** Security level for scripts used in OpenVPN config */
#define OPENVPN_SECURITY_ALLOW_USER_SCRIPTS (2)

/* Macro used to simplify error propagation in config writing functions */
#define FPRINTF(x...) \
    do {                                        \
        if (fprintf(x) < 0)                     \
        {                                       \
            rc = TE_OS_RC(TE_TA_UNIX, errno);   \
            goto cleanup;                       \
        }                                       \
    } while (0)

/* Check OpenVPN instance for validity */
#define OPENVPN_CHECK(instance) \
    do {                                                \
        if (instance == NULL)                           \
            return TE_RC(TE_TA_UNIX, TE_ENOENT);     \
    } while (0)

/** Format string of path to configuration file on TA */
#define OPENVPN_CONFIG_PATH_FMT                "/tmp/ovpn_%s_cfg.ovpn"
/** Path to OpenVPN application */
#define OPENVPN_PATH                           "/usr/sbin/openvpn"
/** Format string of path to PID file */
#define OPENVPN_PID_PATH_FMT                   "/var/run/openvpn_%s.pid"
/** Format string of path to autogenerated TLS key */
#define OPENVPN_TLS_KEY_PATH_FMT               "/tmp/ovpn_%s_tls_key"
/** Format string of path to dh parameters */
#define OPENVPN_DH_PATH_FMT                    "/tmp/ovpn_%s_dh"
/** Format string of path to updown script */
#define OPENVPN_UPDOWN_SCRIPT_PATH_FMT         "/tmp/ovpn_%s_updown.sh"
/** Format string of path to TLS verification script */
#define OPENVPN_TLS_VERIFY_SCRIPT_PATH_FMT     "/tmp/ovpn_%s_tls_verify.sh"
/** Format string of path to user verification script */
#define OPENVPN_USER_VERIFY_SCRIPT_PATH_FMT    "/tmp/ovpn_%s_user_verify.sh"
/** Format string of path to client connect handling script */
#define OPENVPN_CLIENT_CONNECT_SCRIPT_PATH_FMT "/tmp/ovpn_%s_client_connect.sh"
/** Format string of path to file which will contain temporary address pool */
#define OPENVPN_POOL_PATH_FMT                  "/tmp/ovpn_%s_pool.txt"
/** Format string of path to file which will contain interface name */
#define OPENVPN_IFNAME_PATH_FMT                "/tmp/ovpn_%s_ifname.txt"
/** Format string of path to file containing daemon status */
#define OPENVPN_STATUS_PATH_FMT                "/tmp/ovpn_%s_status"
/** Format string of path to file containing client's userpass file */
#define OPENVPN_USER_PASS_PATH_FMT             "/tmp/ovpn_%s_user_pass.txt"
/** Format string of path to file which will contain user status */
#define OPENVPN_USER_STATUS_PATH_FMT           "/tmp/ovpn_%s_user_%s_status"

/** Structure to carry additional OpenVPN options to pass to .ovpn file */
typedef struct option {
    char           *name;   /**< Option friendly name */
    struct option  *next;   /**< Pointer to next option in linked list */
    char           *value;  /**< Full option text */
} option;

/** Structure to define user details */
typedef struct user {
    char          *name;            /**< Friendly user name */
    struct user   *next;            /**< Pointer to next user in linked list */
    char   *username;               /**< Full username */
    char   *password;               /**< Full password */
    char   *certificate;            /**< Path to certificate file on TA */

/* Fingerprint length in printed characters */
#define FP_LENGTH (EVP_MAX_MD_SIZE * 3 + 1)
    char    fingerprint[FP_LENGTH]; /**< Saved fingerprint of the certificate */
#undef FP_LENGTH

} user;

/** Structure to define peer details */
typedef struct peer {
    char           *name;       /**< Peer name/IP address */
    struct peer    *next;       /**< Pointer to next peer in linked list */
    uint16_t        port;       /**< Port to connect to */
} peer;

struct te_openvpn_server;
typedef struct te_openvpn_server te_openvpn_server;

/** OpenVPN server configuration structure */
typedef struct te_openvpn_server {

    char              *name;            /**< Instance name. */
    te_openvpn_server *next;            /**< Next instance. */

    te_bool     status;                 /**< Daemon status.
                                             Possible values:
                                             @c TRUE when running,
                                             @c FALSE otherwise */

    int         lzo;                    /**< Enable LZO compression or not */
    uint16_t    port;                   /**< Port to bind to */
    uint32_t    dh_size;                /**< Default Diffie-Hellman parameters
                                             size (in bits) */
    te_bool     is_server;              /**< Is this instance running as server?
                                             Possible values:
                                             @c TRUE if as server,
                                             @c FALSE if as client */
    char        mode[AUX_BUF_LEN];      /**< Current operation mode based
                                             on device type.
                                             Possible values: "tun", "tap" */

    char        key_direction[AUX_BUF_LEN]; /**< Direction when to use
                                                 TLS authentication.
                                                 Possible values: "normal",
                                                 "inverse", "bidirectional" */

    char        cipher[AUX_BUF_LEN];    /**< Cipher suite used for encryption.
                                             Possible values: refer to OpenVPN
                                             documentation */

    char        digest[AUX_BUF_LEN];    /**< Digest calculation method.
                                             Possible values: refer
                                             to OpenVPN documentation */
    char        tls_key[AUX_BUF_LEN];   /**< Path to TLS key file on TA */
    char        ca[AUX_BUF_LEN];        /**< Path to Certification Authority
                                             file on TA */
    char        cert[AUX_BUF_LEN];      /**< Path to Certificate file on TA */
    char        key[AUX_BUF_LEN];       /**< Path to Private Key file on TA */
    char        proto[AUX_BUF_LEN];     /**< Used protocol.
                                             Possible values: "udp", "tcp" */

    char    interface_behind[AUX_BUF_LEN];  /**< Interface to bind OpenVPN to */
    char    ip_facility[AUX_BUF_LEN];       /**< IP assigning facility.
                                                 Possible values:
                                                 "internal", "external" */

    /* Server parameters */
    te_bool require_certs;              /**< Should server require certificates?
                                             Possible values:
                                             @c TRUE if yes,
                                             @c FALSE otherwise */
    char    ip[AUX_BUF_LEN];            /**< Server's own IP address.
                                             Must be a valid IP */
    char    subnet_mask[AUX_BUF_LEN];   /**< Server's own subnet mask. */
    char    dh[AUX_BUF_LEN];            /**< Path to file containing DH
                                             parameters on TA */
    char    pool_start[AUX_BUF_LEN];    /**< Start of the OpenVPN address pool.
                                             Must be a valid IP */
    char    pool_end[AUX_BUF_LEN];      /**< End of the OpenVPN address pool.
                                             Must be a valid IP */

    /* Client parameters */
    char    client_username[AUX_BUF_LEN];   /**< Username to use when connecting
                                                 to remote server */
    char    client_password[AUX_BUF_LEN];   /**< Password to use when connecting
                                                 to remote server */

    /* Instance-specific paths to associated files */
    char   *pid_path;                   /**< Path to PID file */
    char   *config_path;                /**< Path to configuration file on TA */
    char   *tls_key_path;               /**< Path to autogenerated TLS key */
    char   *dh_path;                    /**< Path to dh parameters */
    char   *updown_script_path;         /**< Path to updown script */
    char   *tls_verify_script_path;     /**< Path to TLS verification script */
    char   *user_verify_script_path;    /**< Path to user verification script */
    char   *client_connect_script_path; /**< Path to client connect
                                             handling script */
    char   *pool_path;                  /**< Path to file which will contain
                                             temporary address pool */
    char   *ifname_path;                /**< Path to file which will contain
                                             interface name */
    char   *status_path;                /**< Path to file containing
                                             daemon status */
    char   *user_pass_path;             /**< Path to file containing
                                             client's userpass file */

    option   *options;                  /**< Head of option linked list */
    user     *users;                    /**< Head of user linked list */
    peer     *peers;                    /**< Head of peer linked list */
} te_openvpn_server;

/* Forward declarations for nodes */
static rcf_pch_cfg_object node_openvpn;
static rcf_pch_cfg_object node_openvpn_server_dh;
static rcf_pch_cfg_object node_openvpn_server_dh_size;
static rcf_pch_cfg_object node_openvpn_server_pool_start;
static rcf_pch_cfg_object node_openvpn_server_user_username;
static rcf_pch_cfg_object node_openvpn_client_peer;
static rcf_pch_cfg_object node_openvpn_client_peer_port;

/* Forward declarations for functions */
static te_errno openvpn_server_generate_tls_verify_script(
    te_openvpn_server *instance);
static te_errno openvpn_server_generate_user_verify_script(
    te_openvpn_server *instance);
static te_errno openvpn_server_generate_updown_script(
    te_openvpn_server *instance);
static te_errno openvpn_server_generate_client_connect_script(
    te_openvpn_server *instance);
static te_errno openvpn_option_list(unsigned int gid, const char *oid,
                                    const char *sub_id, char **list,
                                    const char *openvpn, ...);
static te_errno openvpn_server_start(te_openvpn_server *instance);
static te_errno openvpn_server_stop(te_openvpn_server *instance);
static te_errno openvpn_server_prepare_input_files(te_openvpn_server *instance);
static void openvpn_server_free(te_openvpn_server *instance);

static void free_option(option *opt);
static void free_user(user *u);
static void free_peer(peer *p);

/** Server list head */
static te_openvpn_server *server_head;

/**
 * Create a new instance of OpenVPN server with given name.
 *
 * @param name    Instance name.
 *
 * @return Created instance.
 */
te_openvpn_server *
openvpn_server_create(const char *name)
{
    te_openvpn_server *instance;

    instance = calloc(1, sizeof(te_openvpn_server));
    if (instance == NULL)
        return NULL;

    instance->name = strdup(name);
    if (instance->name == NULL)
        goto error;

    instance->status = FALSE;
    instance->lzo = 0;
    instance->port = 1194;
    instance->dh_size = 1024;
    instance->is_server = FALSE;
    strcpy(instance->mode, "tun");
    strcpy(instance->key_direction, "bidirectional");
    strcpy(instance->cipher, "BF-CBC");
    strcpy(instance->digest, "SHA1");
    strcpy(instance->tls_key, "");
    strcpy(instance->ca, "");
    strcpy(instance->cert, "");
    strcpy(instance->key, "");
    strcpy(instance->proto, "udp");
    strcpy(instance->interface_behind, "");
    strcpy(instance->ip_facility, "internal");
    instance->require_certs = TRUE;
    strcpy(instance->dh, "");
    strcpy(instance->pool_start, "");
    strcpy(instance->pool_end, "");
    strcpy(instance->client_username, "");
    strcpy(instance->client_password, "");
    strcpy(instance->ip, "10.10.0.1");
    strcpy(instance->subnet_mask, "255.255.255.0");

    instance->pid_path = te_sprintf(OPENVPN_PID_PATH_FMT, instance->name);
    if (instance->pid_path == NULL)
        goto error;

    instance->config_path = te_sprintf(OPENVPN_CONFIG_PATH_FMT,
                                       instance->name);
    if (instance->config_path == NULL)
        goto error;

    instance->tls_key_path = te_sprintf(OPENVPN_TLS_KEY_PATH_FMT,
                                        instance->name);
    if (instance->tls_key_path == NULL)
        goto error;

    instance->dh_path = te_sprintf(OPENVPN_DH_PATH_FMT, instance->name);
    if (instance->dh_path == NULL)
        goto error;

    instance->updown_script_path = te_sprintf(OPENVPN_UPDOWN_SCRIPT_PATH_FMT,
                                              instance->name);
    if (instance->updown_script_path == NULL)
        goto error;

    instance->tls_verify_script_path = te_sprintf(
        OPENVPN_TLS_VERIFY_SCRIPT_PATH_FMT, instance->name);
    if (instance->tls_verify_script_path == NULL)
        goto error;

    instance->user_verify_script_path =
        te_sprintf(OPENVPN_USER_VERIFY_SCRIPT_PATH_FMT, instance->name);
    if (instance->user_verify_script_path == NULL)
        goto error;

    instance->client_connect_script_path =
        te_sprintf(OPENVPN_CLIENT_CONNECT_SCRIPT_PATH_FMT, instance->name);
    if (instance->client_connect_script_path == NULL)
        goto error;

    instance->pool_path = te_sprintf(OPENVPN_POOL_PATH_FMT, instance->name);
    if (instance->pool_path == NULL)
        goto error;

    instance->ifname_path = te_sprintf(OPENVPN_IFNAME_PATH_FMT,
                                       instance->name);
    if (instance->ifname_path == NULL)
        goto error;

    instance->status_path = te_sprintf(OPENVPN_STATUS_PATH_FMT,
                                       instance->name);
    if (instance->status_path == NULL)
        goto error;
    instance->user_pass_path = te_sprintf(OPENVPN_USER_PASS_PATH_FMT,
                                          instance->name);
    if (instance->user_pass_path == NULL)
        goto error;

    return instance;

error:
    openvpn_server_free(instance);
    return NULL;
}

/**
 * Release all memory used by OpenVPN server.
 *
 * @param instance  Server instance.
 */
static void
openvpn_server_free(te_openvpn_server *instance)
{
    option            *opt,  *opt_tmp;
    peer              *peer, *peer_tmp;
    user              *u,    *u_tmp;

    free(instance->pid_path);
    free(instance->config_path);
    free(instance->tls_key_path);
    free(instance->dh_path);
    free(instance->updown_script_path);
    free(instance->tls_verify_script_path);
    free(instance->user_verify_script_path);
    free(instance->client_connect_script_path);
    free(instance->pool_path);
    free(instance->ifname_path);
    free(instance->status_path);
    free(instance->user_pass_path);

    free(instance->name);

    /* Free old lists */
    for (opt = instance->options; opt != NULL; opt = opt_tmp)
    {
        opt_tmp = opt->next;
        free_option(opt);
        free(opt);
    }
    instance->options = NULL;

    for (peer = instance->peers; peer != NULL; peer = peer_tmp)
    {
        peer_tmp = peer->next;
        free_peer(peer);
        free(peer);
    }
    instance->peers = NULL;

    for (u = instance->users; u != NULL; u = u_tmp)
    {
        u_tmp = u->next;
        free_user(u);
        free(u);
    }
    instance->users = NULL;

    free(instance);
}

/**
 * Add server to the list of servers.
 *
 * @param instance Server instance to add.
 *
 * @remark It is assumed that function always succeeds.
 */
static void
openvpn_add_server(te_openvpn_server *instance)
{
    instance->next = server_head;
    server_head = instance;
}

/**
 * Get OpenVPN server instance by name.
 *
 * @param name    Instance name.
 *
 * @return Instance pointer, or @c NULL if instance is not found.
 */
static te_openvpn_server *
openvpn_get_server(const char *name)
{
    te_openvpn_server *p = server_head;

    while (p != NULL)
    {
        if (strcmp(p->name, name) == 0)
            return p;

        p = p->next;
    }

    return NULL;
}

/**
 * Delete OpenVPN server instance from list by name.
 *
 * @param name    Instance name.
 *
 * @return Pointer to deleted instance, or @c NULL if it is not found.
 */
static te_openvpn_server *
openvpn_del_server(const char *name)
{
    te_openvpn_server *p = server_head;
    te_openvpn_server *prev = NULL;

    while (p != NULL)
    {
        if (strcmp(p->name, name) == 0)
        {
            if (prev == NULL)
                server_head = p->next;
            else
                prev->next = p->next;

            return p;
        }

        prev = p;
        p = p->next;
    }

    return NULL;
}

/** Restart OpenVPN in case of need */
static inline te_errno
openvpn_server_restart(te_openvpn_server *instance)
{
    te_errno rc;

    if (!instance->status)
        return 0;

    rc = openvpn_server_stop(instance);
    if (rc != 0)
    {
        ERROR("Failed to stop instance during restart: %r", rc);
        return rc;
    }

    rc = openvpn_server_prepare_input_files(instance);
    if (rc != 0)
    {
        ERROR("Couldn't write input files: %r", rc);
        return rc;
    }

    rc = openvpn_server_start(instance);
    if (rc != 0)
    {
        ERROR("Failed to restart instance: %r", rc);
        return rc;
    }

    return 0;
}

/**
 * Find the option in the linked list
 *
 * @param instance  Server instance.
 * @param name      Friendly name of the option.
 *
 * @return Pointer to option, or @c NULL.
 */
static option *
find_option(te_openvpn_server *instance, const char *name)
{
    option *opt;

    for (opt = instance->options; opt != NULL && strcmp(opt->name, name) != 0;
         opt = opt->next);

    return opt;
}

/** Release all memory allocated for option structure */
static void
free_option(option *opt)
{
    free(opt->name);
    free(opt->value);
}

/**
 * Find the user in the list
 *
 * @param instance  Server instance.
 * @param name      User's friendly name.
 *
 * @return Pointer to user structure, or @c NULL.
 */
static user *
find_user(te_openvpn_server *instance, const char *name)
{
    user *u;

    for (u = instance->users;
         u != NULL && strcmp(u->name, name) != 0;
         u = u->next);

    return u;
}

/** Release all memory allocated for user structure */
static void
free_user(user *u)
{
    free(u->name);
    free(u->certificate);
    free(u->password);
    free(u->username);
}

/**
 * Find the peer in the list
 *
 * @param instance  Server instance.
 * @param name      Peer's friendly name.
 *
 * @return Pointer to peer structure, or @c NULL if it is not found.
 */
static peer *
find_peer(te_openvpn_server *instance, const char *name)
{
    peer *p;

    for (p = instance->peers;
         p != NULL && strcmp(p->name, name) != 0;
         p = p->next);

    return p;
}

/** Release all memory allocated for peer structure */
static void
free_peer(peer *p)
{
    free(p->name);
}

/** Obtain peer/port for specific peer */
static te_errno
openvpn_client_peer_port_get(unsigned int gid, const char *oid, char *value,
                             const char *openvpn, const char *client,
                             const char *name, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    peer              *p;

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(client);

    OPENVPN_CHECK(instance);

    p = find_peer(instance, name);
    if (p == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    sprintf(value, "%u", (unsigned int)p->port);

    return 0;
}

/** Set peer/port for specific peer */
static te_errno
openvpn_client_peer_port_set(unsigned int gid, const char *oid,
                             const char *value, const char *openvpn,
                             const char *client, const char *name, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    peer              *p;
    char              *end = NULL;
    unsigned long      port;

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(client);

    OPENVPN_CHECK(instance);

    if ((p = find_peer(instance, name)) == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    port = strtoul(value, &end, 10);
    if (*end != '\0' || port > UINT16_MAX)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    p->port = (uint16_t)port;

    openvpn_server_restart(instance);

    return 0;
}

/* Macro definitions for uniformal configuring methods */
/** Definition of list method for peers, users, options */
#define LIST_METHOD(_gh) \
static te_errno                                                             \
openvpn_##_gh##_list(unsigned int gid, const char *oid, const char *sub_id, \
                     char **list, const char *openvpn, ...)                 \
{                                                                           \
    te_openvpn_server *instance = openvpn_get_server(openvpn);              \
    _gh               *gh;                                                  \
    te_errno           rc;                                                  \
    te_string          str = TE_STRING_INIT;                                \
                                                                            \
    UNUSED(oid);                                                            \
    UNUSED(gid);                                                            \
    UNUSED(sub_id);                                                         \
                                                                            \
    OPENVPN_CHECK(instance);                                                \
                                                                            \
    for (gh = instance->_gh##s; gh != NULL; gh = gh->next)                  \
    {                                                                       \
        rc = te_string_append(&str,                                         \
                              gh->next == NULL ? "%s" : "%s ",              \
                              gh->name);                                    \
        if (rc != 0)                                                        \
        {                                                                   \
            te_string_free(&str);                                           \
            return TE_RC(TE_TA_UNIX, rc);                                   \
        }                                                                   \
    }                                                                       \
    *list = str.ptr;                                                        \
                                                                            \
    return 0;                                                               \
}

/**
 * Definition of add method for peers, users.
 * @remark Note that all of them have path like:
 *         /agent:ta/openvpn:inst:/client:/peer:name
 */
#define ADD_METHOD(_gh) \
static te_errno                                                             \
openvpn_##_gh##_add(unsigned int gid, const char *oid, const char *value,   \
                    const char *openvpn, const char *server,                \
                    const char *name,  ...)                                 \
{                                                                           \
    te_openvpn_server *instance = openvpn_get_server(openvpn);              \
    _gh               *gh;                                                  \
                                                                            \
    UNUSED(gid);                                                            \
    UNUSED(oid);                                                            \
    UNUSED(value);                                                          \
    UNUSED(server);                                                         \
                                                                            \
    OPENVPN_CHECK(instance);                                                \
                                                                            \
    if ((gh = find_##_gh(instance, name)) != NULL)                          \
        return TE_RC(TE_TA_UNIX, TE_EEXIST);                                \
                                                                            \
    if ((gh = calloc(1, sizeof(_gh))) == NULL)                              \
        return TE_RC(TE_TA_UNIX, TE_ENOMEM);                                \
                                                                            \
    if ((gh->name = strdup(name)) == NULL)                                  \
    {                                                                       \
        free(gh);                                                           \
        return TE_RC(TE_TA_UNIX, TE_ENOMEM);                                \
    }                                                                       \
                                                                            \
    gh->next = instance->_gh##s;                                            \
    instance->_gh##s = gh;                                                  \
                                                                            \
    openvpn_server_restart(instance);                                       \
                                                                            \
    return 0;                                                               \
}

/**
 * Definition of delete method for peers, users, options
 * @remark Note that all of them have path like:
 *         /agent:ta/openvpn:inst:/client:/peer:name
 */
#define DEL_METHOD(_gh) \
static te_errno                                                     \
openvpn_##_gh##_del(unsigned int gid, const char *oid,              \
                    const char *openvpn, const char *server,        \
                    const char *name, ...)                          \
{                                                                   \
    te_openvpn_server *instance = openvpn_get_server(openvpn);      \
    _gh               *gh;                                          \
    _gh               *prev;                                        \
                                                                    \
    UNUSED(gid);                                                    \
    UNUSED(oid);                                                    \
    UNUSED(server);                                                 \
                                                                    \
    OPENVPN_CHECK(instance);                                        \
                                                                    \
    for (gh = instance->_gh##s, prev = NULL;                        \
         gh != NULL && strcmp(gh->name, name) != 0;                 \
         prev = gh, gh = gh->next);                                 \
                                                                    \
    if (gh == NULL)                                                 \
        return TE_RC(TE_TA_UNIX, TE_ENOENT);                        \
                                                                    \
    if (prev)                                                       \
        prev->next = gh->next;                                      \
    else                                                            \
        instance->_gh##s = gh->next;                                \
    free_##_gh(gh);                                                 \
    free(gh);                                                       \
                                                                    \
    openvpn_server_restart(instance);                               \
                                                                    \
    return 0;                                                       \
}


/** List existing options */
static te_errno
openvpn_option_list(unsigned int gid, const char *oid,
                    const char *sub_id, char **list,
                    const char *openvpn, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    te_errno           rc;
    te_string          str = TE_STRING_INIT;
    option            *opt;

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(sub_id);

    OPENVPN_CHECK(instance);

    for (opt = instance->options; opt != NULL; opt = opt->next)
    {
        rc = te_string_append(&str,
                              opt->next == NULL ? "%s" : "%s ",
                              opt->name);
        if (rc != 0)
        {
            te_string_free(&str);
            return TE_RC(TE_TA_UNIX, rc);
        }
    }

    *list = str.ptr;
    return 0;
}

/** Add a new custom option */
static te_errno
openvpn_option_add(unsigned int gid, const char *oid,
                   const char *value, const char *openvpn,
                   const char *optname, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    option            *opt;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (find_option(instance, optname) != NULL)
        return TE_RC(TE_TA_UNIX, TE_EEXIST);

    if ((opt = calloc(1, sizeof(*opt))) == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOMEM);

    opt->name = strdup(optname);
    opt->value = strdup(value);

    if (opt->name == NULL || opt->value == NULL)
    {
        free_option(opt);
        return TE_RC(TE_TA_UNIX, TE_ENOMEM);
    }

    opt->next = instance->options;
    instance->options = opt;

    openvpn_server_restart(instance);

    return 0;
}

/** Delete custom option by name */
static te_errno
openvpn_option_del(unsigned int gid, const char *oid,
                   const char *openvpn, const char *optname, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    option            *opt, *prev;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    for (opt = instance->options, prev = NULL;
         opt != NULL && strcmp(opt->name, optname) != 0;
         prev = opt, opt = opt->next);

    if (opt == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    if (prev)
        prev->next = opt->next;
    else
        instance->options = opt->next;

    free_option(opt);
    free(opt);

    openvpn_server_restart(instance);

    return 0;
}

/** Set custom option value */
static te_errno
openvpn_option_value_set(unsigned int gid, const char *oid,
                         const char *value, const char *openvpn,
                         const char *optname, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    char              *old;
    option            *opt;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if ((opt = find_option(instance, optname)) == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    old = opt->value;
    if (strlen(value) == 0)
    {
        opt->value = NULL;
    }
    else
    {
        if ((opt->value = strdup(value)) == NULL)
        {
            opt->value = old;
            return TE_RC(TE_TA_UNIX, TE_ENOMEM);
        }
    }

    free(old);

    openvpn_server_restart(instance);

    return 0;
}

/** Get custom option value */
static te_errno
openvpn_option_value_get(unsigned int gid, const char *oid,
                         char *value, const char *openvpn,
                         const char *optname, ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    option            *opt;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if ((opt = find_option(instance, optname)) == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    strcpy(value, opt->value);

    return 0;
}

/*
 * Definition of the routines for obtaining/changing of
 * server/user/... attributes (except options).
 */
#define ATTR_GET(_attr, _ghs, _ghs_type) \
static te_errno \
openvpn_server_##_ghs##_##_attr##_get(unsigned int gid, const char *oid,    \
                                      char *value, const char *openvpn,     \
                                      const char *server, const char *name, \
                                      ...)                                  \
{                                                                           \
    te_openvpn_server *instance = openvpn_get_server(openvpn);              \
    _ghs_type         *ghs;                                                 \
                                                                            \
    UNUSED(gid);                                                            \
    UNUSED(oid);                                                            \
    UNUSED(server);                                                         \
                                                                            \
    OPENVPN_CHECK(instance);                                                \
                                                                            \
    if ((ghs = find_##_ghs(instance, name)) == NULL)                        \
        return TE_RC(TE_TA_UNIX, TE_ENOENT);                                \
                                                                            \
    if (ghs->_attr == NULL)                                                 \
        *value = '\0';                                                      \
    else                                                                    \
        strcpy(value, ghs->_attr);                                          \
                                                                            \
    return 0;                                                               \
}

#define ATTR_SET(_attr, _ghs, _ghs_type) \
static te_errno \
openvpn_server_##_ghs##_##_attr##_set(unsigned int gid, const char *oid,    \
                                      const char *value,                    \
                                      const char *openvpn,                  \
                                      const char *server,                   \
                                      const char *name,                     \
                                      ...)                                  \
{                                                                           \
    te_openvpn_server *instance = openvpn_get_server(openvpn);              \
    _ghs_type         *ghs;                                                 \
    char              *old_val;                                             \
                                                                            \
    UNUSED(gid);                                                            \
    UNUSED(oid);                                                            \
    UNUSED(server);                                                         \
                                                                            \
    OPENVPN_CHECK(instance);                                                \
                                                                            \
    if ((ghs = find_##_ghs(instance, name)) == NULL)                        \
        return TE_RC(TE_TA_UNIX, TE_ENOENT);                                \
                                                                            \
    old_val = ghs->_attr;                                                   \
                                                                            \
    if (strlen(value) == 0)                                                 \
    {                                                                       \
        ghs->_attr = NULL;                                                  \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        if ((ghs->_attr = strdup(value)) == NULL)                           \
        {                                                                   \
            ghs->_attr = old_val;                                           \
            return TE_RC(TE_TA_UNIX, TE_ENOMEM);                            \
        }                                                                   \
    }                                                                       \
                                                                            \
    free(old_val);                                                          \
                                                                            \
    openvpn_server_restart(instance);                                       \
                                                                            \
    return 0;                                                               \
}

ADD_METHOD(peer)
DEL_METHOD(peer)
LIST_METHOD(peer)

ADD_METHOD(user)
DEL_METHOD(user)
LIST_METHOD(user)

ATTR_GET(username, user, user)
ATTR_SET(username, user, user)

ATTR_GET(password, user, user)
ATTR_SET(password, user, user)

ATTR_GET(certificate, user, user)

/**
 * Read certificate's fingerprint to provided buffer.
 *
 * @param[in]   cert_path   Path to certificate.
 * @param[out]  buf         Buffer where to copy fingerprint. Assumed to be
 *                          large enough; the constant @c EVP_MAX_MD_SIZE is
 *                          suggested.
 * @param[out]  size        Pointer to variable where the size of fingerprint
 *                          is set. If @c NULL, size is not copied there.
 *
 * @return Status code.
 */
static te_errno
read_cert_fingerprint(const char *cert_path, unsigned char *buf, int *size)
{
    BIO          *certbio     = NULL;
    X509         *cert        = NULL;
    const EVP_MD *fprint_type = NULL;
    int           ret;
    te_errno      rc = 0;

    certbio = BIO_new(BIO_s_file());

    ret = BIO_read_filename(certbio, cert_path);
    if (ret == 0 || (cert = PEM_read_bio_X509(certbio, NULL, 0, NULL)) == NULL)
    {
        rc = TE_RC(TE_TA_UNIX, TE_EFAULT);
        goto out;
    }
    fprint_type = EVP_sha256();

    if (X509_digest(cert, fprint_type, buf, (unsigned int *)size) == 0)
        rc = TE_RC(TE_TA_UNIX, TE_EFAULT);

out:
    if (cert != NULL)
        X509_free(cert);

    BIO_free_all(certbio);

    return rc;
}

/** Set user certificate and re-read its fingerprint */
static te_errno
openvpn_server_user_certificate_set(unsigned int gid,
                                    const char *oid,
                                    const char *value,
                                    const char *openvpn,
                                    const char *server,
                                    const char *name,
                                    ...)
{
    te_openvpn_server *instance = openvpn_get_server(openvpn);
    user              *user;
    char              *old_val;
    int                i;
    unsigned char      buf[EVP_MAX_MD_SIZE];
    int                size;
    char               tmp[3] = {'\0'};
    char               digest[EVP_MAX_MD_SIZE * 2 + 1] = {'\0'};

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(server);

    OPENVPN_CHECK(instance);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    if ((user = find_user(instance, name)) == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    old_val = user->certificate;

    if (strlen(value) == 0)
    {
        user->certificate = NULL;
    }
    else
    {
        if ((user->certificate = strdup(value)) == NULL)
        {
            user->certificate = old_val;
            return TE_RC(TE_TA_UNIX, TE_ENOMEM);
        }
    }

    free(old_val);

    memset(user->fingerprint, 0, sizeof(user->fingerprint));
    if (read_cert_fingerprint(user->certificate, buf, &size) == 0)
    {
        for (i = 0; i < size; ++i)
        {
            sprintf(tmp, "%02x", (unsigned int)buf[i]);
            strcat(digest, tmp);
            if (i != (size - 1))
                strcat(digest, ":");
        }
        te_strlcpy(user->fingerprint, digest, sizeof(user->fingerprint));
    }

    openvpn_server_restart(instance);

    return 0;
}

/**
 * Start OpenVPN daemon with specified configuration file.
 *
 * @param instance    Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_start(te_openvpn_server *instance)
{
    char               buf[AUX_BUF_LEN];
    int                ret;

    ret = snprintf(buf, sizeof(buf),
                   OPENVPN_PATH " --config %s --writepid %s &",
                   instance->config_path, instance->pid_path);
    if (ret < 0 || (unsigned int)ret >= sizeof(buf))
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    if (ta_system(buf) != 0)
    {
        ERROR("Couldn't start OpenVPN daemon");
        return TE_RC(TE_TA_UNIX, TE_ESHCMD);
    }

    instance->status = TRUE;
    return 0;
}

/**
 * Stop OpenVPN daemon if it is running.
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_stop(te_openvpn_server *instance)
{
    int                pid = -1;
    FILE              *f;

    f = fopen(instance->pid_path, "r");
    if (f == NULL)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    if (fscanf(f, "%d", &pid) != 1 || fclose(f) == EOF)
        return TE_OS_RC(TE_TA_UNIX, errno);

    if (pid == -1)
        return TE_RC(TE_TA_UNIX, TE_ENOENT);

    if (kill(pid, SIGTERM) != 0)
    {
        ERROR("Couldn't kill OpenVPN daemon (pid %d)", pid);
        return te_rc_os2te(errno);
    }

    unlink(instance->pid_path);
    unlink(instance->config_path);
    unlink(instance->updown_script_path);
    unlink(instance->tls_verify_script_path);
    unlink(instance->user_verify_script_path);
    unlink(instance->client_connect_script_path);
    unlink(instance->pool_path);
    unlink(instance->ifname_path);
    unlink(instance->status_path);
    unlink(instance->user_pass_path);

    instance->status = FALSE;

    return 0;
}

/**
 * Generate a new TLS key
 *
 * @param instance Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_tls_key(te_openvpn_server *instance)
{
    char    buf[AUX_BUF_LEN];
    int     ret;

    ret = snprintf(buf, sizeof(buf),
                   OPENVPN_PATH " --genkey --secret %s",
                   instance->tls_key_path);
    if (ret < 0 || ret >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    if (ta_system(buf) != 0)
        return TE_RC(TE_TA_UNIX, TE_ESHCMD);

    chmod(instance->tls_key_path,
          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);

    if (access(instance->tls_key_path, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    return 0;
}

/**
 * Generate new dh parameters
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_dh(te_openvpn_server *instance)
{
    char    buf[AUX_BUF_LEN];
    int     ret;

    ret = snprintf(buf, sizeof(buf),
                   "openssl dhparam -out %s %d",
                   instance->dh_path, instance->dh_size);
    if (ret < 0 || ret >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    if (ta_system(buf) != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    chmod(instance->dh_path,
          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);

    if (access(instance->dh_path, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    return 0;
}

/**
 * Generate auth userpass file.
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_auth_user_pass(te_openvpn_server *instance)
{
    FILE              *f;
    te_errno           rc = 0;

    f = fopen(instance->user_pass_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    FPRINTF(f, "%s\n", instance->client_username);
    FPRINTF(f, "%s\n", instance->client_password);

cleanup:
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}

/**
 * Get the first IP for specific interface name/family.
 *
 * @param[in]   ifname  Target interface name.
 * @param[in]   family  Target address family.
 * @param[out]  ip      Buffer to carry obtained IP.
 * @param[in]   ip_size Size of @p ip buffer.
 *
 * @return Status code.
 */
static te_errno
openvpn_getifaddrs(const char *ifname, int family, char *ip, int ip_size)
{
    struct ifaddrs *ifaddr, *ifa;
    int             rc = ENOENT;
    char           *s;

    if (getifaddrs(&ifaddr) == -1)
        return TE_RC(TE_TA_UNIX, TE_EFAULT);

    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next)
    {
        if (ifa->ifa_addr == NULL)
            continue;

        if (strcmp(ifname, ifa->ifa_name) != 0 ||
            family != ifa->ifa_addr->sa_family)
            continue;

        s = te_ip2str(ifa->ifa_addr);
        if (s == NULL)
            continue;
        te_strlcpy(ip, s, ip_size);
        free(s);

        rc = 0;
        break;
    }

    freeifaddrs(ifaddr);

    return rc;
}

/**
 * Write server scripts and additional files to corresponding place.
 *
 * @param instance  Server instance.
 *
 * @return     Status code.
 */
static te_errno
openvpn_server_write_scripts(te_openvpn_server *instance)
{
    te_errno rc;

    /*
     * Generate scripts and enable their execution.
     * Please note that while 0777 looks too optimistic, OpenVPN daemon
     * might drop capabilities after successful start and later get unable
     * to execute scripts. Scripts don't do anything special, so it doesn't
     * bring any security risk.
     */
    rc = openvpn_server_generate_updown_script(instance);
    if (rc != 0)
        goto cleanup;

    /*
     * Ignoring result as we'll see OpenVPN complaint if privileges are not
     * sufficient.
     */
    chmod(instance->updown_script_path, 0777);

    rc = openvpn_server_generate_tls_verify_script(instance);
    if (rc != 0)
        goto cleanup;

    chmod(instance->tls_verify_script_path, 0777);

    rc = openvpn_server_generate_user_verify_script(instance);
    if (rc != 0)
        goto cleanup;

    chmod(instance->user_verify_script_path, 0777);

    rc = openvpn_server_generate_client_connect_script(instance);
    if (rc != 0)
        goto cleanup;

    chmod(instance->client_connect_script_path, 0777);

    rc = openvpn_server_generate_auth_user_pass(instance);
    if (rc != 0)
        goto cleanup;

    chmod(instance->user_pass_path, 0777);

cleanup:
    return rc;
}

/**
 * Write OpenVPN configuration file to specified location.
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_write_config(te_openvpn_server *instance)
{
    peer              *p;
    option            *opt;
    FILE              *f;
    te_errno           rc = 0;
    char               ip[INET6_ADDRSTRLEN];

    f = fopen(instance->config_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    /* Write out global parameters */
    if (!instance->is_server)
    {
        FPRINTF(f, "client\n");
    }
    else
    {
        FPRINTF(f, "mode server\n");
        FPRINTF(f, "tls-server\n");
    }

    FPRINTF(f, "dev %s\n", instance->mode);

    if (strcmp(instance->key_direction, "normal") == 0)
        FPRINTF(f, "key-direction 0\n");
    else if (strcmp(instance->key_direction, "inverse") == 0)
        FPRINTF(f, "key-direction 1\n");

    FPRINTF(f, "cipher %s\n", instance->cipher);
    FPRINTF(f, "auth %s\n", instance->digest);

    if (strlen(instance->tls_key) == 0)
    {
        /* If TLS key is not present, generate new one and set path in a node */
        rc = openvpn_server_generate_tls_key(instance);
        if (rc != 0)
            goto cleanup;

        if (strlen(instance->tls_key_path) >= AUX_BUF_LEN)
        {
            rc = TE_RC(TE_TA_UNIX, TE_EOVERFLOW);
            goto cleanup;
        }
        te_strlcpy(instance->tls_key, instance->tls_key_path,
                   sizeof(instance->tls_key));
    }
    chmod(instance->tls_key,
          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
    FPRINTF(f, "tls-auth %s\n", instance->tls_key);

    if (strlen(instance->dh) == 0)
    {
        /*
         * If DH parameters are not present,
         * generate new set and change path in a node.
         */
        rc = openvpn_server_generate_dh(instance);
        if (rc != 0)
            goto cleanup;

        if (strlen(instance->dh_path) >= AUX_BUF_LEN)
        {
            rc = TE_RC(TE_TA_UNIX, TE_EOVERFLOW);
            goto cleanup;
        }
        te_strlcpy(instance->dh, instance->dh_path, sizeof(instance->dh));
    }
    chmod(instance->dh,
          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
    FPRINTF(f, "dh %s\n", instance->dh);

    /*
     * CA must be present even with require_certs = FALSE, so we check
     * access directly.
     */
    if (strlen(instance->ca) > 0)
        chmod(instance->ca,
              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
    if (access(instance->ca, R_OK) != 0)
    {
        ERROR("Certificate Authority is not readable");
        rc = TE_RC(TE_TA_UNIX, TE_EACCES);
        goto cleanup;
    }
    FPRINTF(f, "ca %s\n", instance->ca);

    if (strlen(instance->cert) > 0)
    {
        chmod(instance->cert,
              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        if (access(instance->cert, R_OK) != 0)
        {
            ERROR("Certificate is not readable");
            rc = TE_RC(TE_TA_UNIX, TE_EACCES);
            goto cleanup;
        }
        FPRINTF(f, "cert %s\n", instance->cert);
    }

    if (strlen(instance->key) > 0)
    {
        chmod(instance->key,
              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        if (access(instance->key, R_OK) != 0)
        {
            ERROR("Private key is not readable");
            rc = TE_RC(TE_TA_UNIX, TE_EACCES);
            goto cleanup;
        }
        FPRINTF(f, "key %s\n", instance->key);
    }

    FPRINTF(f, "proto %s\n", instance->proto);

    if (instance->lzo == 1)
        FPRINTF(f, "comp-lzo yes\n");

    FPRINTF(f, "port %u\n", (unsigned int)instance->port);

    if (instance->is_server)
    {
        for (p = instance->peers; p != NULL; p = p->next)
            FPRINTF(f, "remote %s %d\n", p->name, p->port);
    }

    for (opt = instance->options; opt != NULL; opt = opt->next)
        FPRINTF(f, "%s\n", opt->value);

    if (access(instance->updown_script_path, R_OK) != 0)
    {
        ERROR("Updown script is not readable");
        rc = TE_RC(TE_TA_UNIX, TE_EACCES);
        goto cleanup;
    }
    FPRINTF(f, "up \"%s up\"\n", instance->updown_script_path);
    FPRINTF(f, "down \"%s down\"\n", instance->updown_script_path);

    if (instance->is_server)
    {
        if (access(instance->tls_verify_script_path, R_OK) != 0)
        {
            ERROR("TLS verify script is not readable");
            rc = TE_RC(TE_TA_UNIX, TE_EACCES);
            goto cleanup;
        }
        FPRINTF(f, "tls-verify %s\n", instance->tls_verify_script_path);

        if (access(instance->user_verify_script_path, R_OK) != 0)
        {
            ERROR("User verify script is not readable");
            rc = TE_RC(TE_TA_UNIX, TE_EACCES);
            goto cleanup;
        }
        FPRINTF(f, "auth-user-pass-optional\n");
        FPRINTF(f, "auth-user-pass-verify %s via-file\n",
                instance->user_verify_script_path);

        if (access(instance->client_connect_script_path, R_OK) != 0)
        {
            ERROR("Client connect script is not readable");
            rc = TE_RC(TE_TA_UNIX, TE_EACCES);
            goto cleanup;
        }
        FPRINTF(f, "client-connect \"%s up\"\n",
                instance->client_connect_script_path);
        FPRINTF(f, "client-disconnect \"%s down\"\n",
                instance->client_connect_script_path);
    }

    if (access(instance->user_pass_path, R_OK) != 0)
    {
        ERROR("User/password file is not readable");
        rc = TE_RC(TE_TA_UNIX, TE_EACCES);
        goto cleanup;
    }

    if (instance->is_server)
    {
        if (!instance->require_certs)
        {
            /*
             * We don't require certificate, so allow passing username as common
             * name.
             */
            FPRINTF(f, "client-cert-not-required\n");
            FPRINTF(f, "username-as-common-name\n");
        }

        if (strlen(instance->ip) != 0 && strlen(instance->subnet_mask) != 0)
        {
            FPRINTF(f, "ifconfig %s %s\n", instance->ip, instance->subnet_mask);
        }

        if (strcmp(instance->ip_facility, "internal") == 0)
        {
            /*
             * OpenVPN daemon deals with IP assignment itself.
             */
            if (instance->pool_start != NULL && instance->pool_end != NULL &&
                strlen(instance->pool_start) != 0 &&
                strlen(instance->pool_end) != 0)
            {
                FPRINTF(f, "ifconfig-pool-persist %s\n", instance->pool_path);
                FPRINTF(f, "ifconfig-pool %s %s\n", instance->pool_start,
                        instance->pool_end);
            }
        }
    }
    else
    {
        FPRINTF(f, "auth-user-pass %s\n", instance->user_pass_path);
    }

    /* Bind to specific interface */
    rc = openvpn_getifaddrs(instance->interface_behind,
                            AF_INET, ip, sizeof(ip));
    if (rc == 0)
        FPRINTF(f, "local %s\n", ip);
    else
        VERB("Server is not binding to any IP address");

    /* Allow scripts to be executed */
    FPRINTF(f, "script-security %d\n", OPENVPN_SECURITY_ALLOW_USER_SCRIPTS);
    rc = 0;

cleanup:
    /*
     * Try to close file. If any fclose fails and no error had been set before,
     * propagate fclose error to upper level.
     */
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}


/**
 * Prepare and write input files required by OpenVPN daemon.
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_prepare_input_files(te_openvpn_server *instance)
{
    te_errno rc;

    rc = openvpn_server_write_scripts(instance);
    if (rc != 0)
    {
        ERROR("Couldn't write scripts: %r", rc);
        return rc;
    }

    rc = openvpn_write_config(instance);
    if (rc != 0)
    {
        ERROR("Couldn't write configuration: %r", rc);
        return rc;
    }

    return 0;
}

/** Obtain interface name from dynamically generated file */
static te_errno
openvpn_ifname_get(unsigned int gid, const char *oid,
                   char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    FILE              *f;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    f = fopen(instance->ifname_path, "r");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    if (fscanf(f, "%s", value) != 1 || fclose(f) == EOF)
        return TE_OS_RC(TE_TA_UNIX, errno);

    return 0;
}

/** Obtain current operation mode */
static te_errno
openvpn_mode_get(unsigned int gid, const char *oid,
                 char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->mode);

    return 0;
}

/** Set current operation mode */
static te_errno
openvpn_mode_set(unsigned int gid, const char *oid,
                 const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strcmp(value, "tun") != 0 && strcmp(value, "tap") != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    te_strlcpy(instance->mode, value, sizeof(instance->mode));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current TLS key direction */
static te_errno
openvpn_key_direction_get(unsigned int gid, const char *oid,
                          char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->key_direction);

    return 0;
}

/** Set current TLS key direction */
static te_errno
openvpn_key_direction_set(unsigned int gid, const char *oid,
                          const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strcmp(value, "normal") != 0 &&
        strcmp(value, "inverse") != 0 &&
        strcmp(value, "bidirectional") != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    te_strlcpy(instance->key_direction, value, sizeof(instance->key_direction));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain currently used cipher */
static te_errno
openvpn_cipher_get(unsigned int gid, const char *oid,
                   char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->cipher);

    return 0;
}

/** Set currently used cipher */
static te_errno
openvpn_cipher_set(unsigned int gid, const char *oid,
                   const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* TODO: set only ciphers supported by OpenVPN daemon. */

    te_strlcpy(instance->cipher, value, sizeof(instance->cipher));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain currently used digest algorithm */
static te_errno
openvpn_digest_get(unsigned int gid, const char *oid,
                   char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->digest);

    return 0;
}

/** Set currently used digest algorithm */
static te_errno
openvpn_digest_set(unsigned int gid, const char *oid,
                   const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    te_strlcpy(instance->digest, value, sizeof(instance->digest));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current path to TLS key (on TA) */
static te_errno
openvpn_tls_key_get(unsigned int gid, const char *oid,
                    char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->tls_key);

    return 0;
}

/** Set currently used path to TLS key (on TA) */
static te_errno
openvpn_tls_key_set(unsigned int gid, const char *oid,
                    const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    te_strlcpy(instance->tls_key, value, sizeof(instance->tls_key));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current path to Certification Authority (on TA) */
static te_errno
openvpn_ca_get(unsigned int gid, const char *oid,
               char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->ca);

    return 0;
}

/** Set current path to Certification Authority (on TA) */
static te_errno
openvpn_ca_set(unsigned int gid, const char *oid,
               const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    te_strlcpy(instance->ca, value, sizeof(instance->ca));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current path to Certificate (on TA) */
static te_errno
openvpn_cert_get(unsigned int gid, const char *oid,
                 char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->cert);

    return 0;
}

/** Set current path to Certificate (on TA) */
static te_errno
openvpn_cert_set(unsigned int gid, const char *oid,
                 const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    te_strlcpy(instance->cert, value, sizeof(instance->cert));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current path to Private Key (on TA) */
static te_errno
openvpn_key_get(unsigned int gid, const char *oid,
                char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->key);

    return 0;
}

/** Set current path to Private Key (on TA) */
static te_errno
openvpn_key_set(unsigned int gid, const char *oid,
                const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    te_strlcpy(instance->key, value, sizeof(instance->key));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain currently used protocol */
static te_errno
openvpn_proto_get(unsigned int gid, const char *oid,
                  char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->proto);

    return 0;
}

/** Set currently used protocol */
static te_errno
openvpn_proto_set(unsigned int gid, const char *oid,
                  const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strcmp(value, "udp") != 0 && strcmp(value, "tcp") != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    te_strlcpy(instance->proto, value, sizeof(instance->proto));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain current state of LZO compression usage */
static te_errno
openvpn_lzo_get(unsigned int gid, const char *oid,
                  char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    sprintf(value, "%d", instance->lzo);

    return 0;
}

/** Set current state of LZO compression usage */
static te_errno
openvpn_lzo_set(unsigned int gid, const char *oid,
                  const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    int                val;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    val = atoi(value);
    if (val != 1 && val != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    instance->lzo = val;
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain the current interface OpenVPN binds to */
static te_errno
openvpn_interface_behind_get(unsigned int gid, const char *oid,
                             char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->interface_behind);

    return 0;
}

/** Set the current interface OpenVPN binds to */
static te_errno
openvpn_interface_behind_set(unsigned int gid, const char *oid,
                             const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    te_strlcpy(instance->interface_behind, value,
               sizeof(instance->interface_behind));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain IP assigning facility */
static te_errno
openvpn_ip_facility_get(unsigned int gid, const char *oid,
                        char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);
    strcpy(value, instance->ip_facility);

    return 0;
}

/** Set IP assigning facility */
static te_errno
openvpn_ip_facility_set(unsigned int gid, const char *oid,
                        const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strcmp(value, "internal") != 0 && strcmp(value, "external") != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    te_strlcpy(instance->ip_facility, value, sizeof(instance->ip_facility));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain server's own IP address */
static te_errno
openvpn_server_ip_get(unsigned int gid, const char *oid,
                      char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->ip);

    return 0;
}

/** Set server's own IP address */
static te_errno
openvpn_server_ip_set(unsigned int gid, const char *oid,
                      const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* TODO: check IP for validity */
    te_strlcpy(instance->ip, value, sizeof(instance->ip));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain server's own subnet mask */
static te_errno
openvpn_server_subnet_mask_get(unsigned int gid, const char *oid,
                               char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->subnet_mask);

    return 0;
}

/** Set server's own subnet mask */
static te_errno
openvpn_server_subnet_mask_set(unsigned int gid, const char *oid,
                               const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* TODO: check IP for validity */
    te_strlcpy(instance->subnet_mask, value, sizeof(instance->subnet_mask));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain path to DH parameters (on TA) */
static te_errno
openvpn_server_dh_get(unsigned int gid, const char *oid,
                      char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->dh);

    return 0;
}

/** Set path to DH parameters (on TA) */
static te_errno
openvpn_server_dh_set(unsigned int gid, const char *oid,
                      const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* Check if file exists and readable */
    if (strlen(value) > 0 && access(value, R_OK) != 0)
        return TE_RC(TE_TA_UNIX, TE_EACCES);

    te_strlcpy(instance->dh, value, sizeof(instance->dh));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain size of DH parameters */
static te_errno
openvpn_server_dh_size_get(unsigned int gid, const char *oid,
                           char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    sprintf(value, "%u", instance->dh_size);

    return 0;
}

/** Set size of DH parameters */
static te_errno
openvpn_server_dh_size_set(unsigned int gid, const char *oid,
                           const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    char              *end = NULL;
    uint32_t           dh_size;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    dh_size = strtoul(value, &end, 10);
    if (*end != '\0')
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    instance->dh_size = dh_size;
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain dynamic pool start IP address */
static te_errno
openvpn_server_pool_start_get(unsigned int gid, const char *oid,
                              char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->pool_start);

    return 0;
}

/** Set dynamic pool start IP address */
static te_errno
openvpn_server_pool_start_set(unsigned int gid, const char *oid,
                              const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* TODO: check IP for validity */
    te_strlcpy(instance->pool_start, value, sizeof(instance->pool_start));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain dynamic pool end IP address */
static te_errno
openvpn_server_pool_end_get(unsigned int gid, const char *oid,
                            char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->pool_end);

    return 0;
}

/** Set dynamic pool end IP address */
static te_errno
openvpn_server_pool_end_set(unsigned int gid, const char *oid,
                            const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    /* TODO: check IP for validity */
    te_strlcpy(instance->pool_end, value, sizeof(instance->pool_end));
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain the state of certificate requirement */
static te_errno
openvpn_server_require_certs_get(unsigned int gid, const char *oid,
                                 char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    sprintf(value, "%d", instance->require_certs);

    return 0;
}

/** Set the state of certificate requirement */
static te_errno
openvpn_server_require_certs_set(unsigned int gid, const char *oid,
                                 const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    int                val;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    val = atoi(value);
    if (val != 1 && val != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    instance->require_certs = val == 1;

    openvpn_server_restart(instance);

    return 0;
}

/** Obtain the number of connected users */
static te_errno
openvpn_server_connected_users_get(unsigned int gid, const char *oid,
                                   char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    FILE              *f;
    char               path[1000];
    int                status;
    int                count = 0;
    user              *u;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    for (u = instance->users; u != NULL; u = u->next)
    {
        sprintf(path, OPENVPN_USER_STATUS_PATH_FMT, instance->name, u->name);
        f = fopen(path, "r");
        if (f == NULL)
            continue;
        if (fscanf(f, "%d", &status) != 1 || fclose(f) == EOF)
            return TE_OS_RC(TE_TA_UNIX, errno);
        if (status == 1)
            count++;
    }

    sprintf(value, "%d", count);

    return 0;
}

/** Obtain username for client mode */
static te_errno
openvpn_client_username_get(unsigned int gid, const char *oid,
                            char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->client_username);

    return 0;
}

/** Set username for client mode */
static te_errno
openvpn_client_username_set(unsigned int gid, const char *oid,
                            const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    te_strlcpy(instance->client_username, value,
               sizeof(instance->client_username));
    openvpn_server_restart(instance);

    return 0;
}

/** Get password for client mode */
static te_errno
openvpn_client_password_get(unsigned int gid, const char *oid,
                            char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, instance->client_password);

    return 0;
}

/** Set password for client mode */
static te_errno
openvpn_client_password_set(unsigned int gid, const char *oid,
                            const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    if (strlen(value) >= AUX_BUF_LEN)
        return TE_RC(TE_TA_UNIX, TE_EOVERFLOW);

    te_strlcpy(instance->client_password, value,
               sizeof(instance->client_password));
    openvpn_server_restart(instance);

    return 0;
}

/** Get actual OpenVPN endpoint IP address */
static te_errno
openvpn_endpoint_ip_get(unsigned int gid, const char *oid,
                        char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    FILE              *f;
    int                status_local = 0;
    char               buf[AUX_BUF_LEN];

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    /* Copy default address beforehand */
    strcpy(value, instance->ip);
    if (!instance->status)
        return 0;

    f = fopen(instance->status_path, "r");
    if (f == NULL)
    {
        /* Not an error, no status is provided */
        return 0;
    }

    if (fgets(buf, sizeof(buf), f) != NULL)
    {
        if (sscanf(buf, "%d", &status_local) != 1)
            goto cleanup;

        if (status_local != -1)
        {
            char *s;

            /* Remove new line symbols */
            s = strchr(buf, '\n');
            if (s != NULL)
                *s = '\0';

            s = strchr(buf, '\r');
            if (s != NULL)
                *s = '\0';

            /* IP is found */
            strcpy(value, buf);
        }
    }

cleanup:
    if (fclose(f) == EOF)
        return TE_OS_RC(TE_TA_UNIX, errno);

    return 0;
}

/** Get actual OpenVPN daemon status */
static te_errno
openvpn_status_get(unsigned int gid, const char *oid,
                   char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    FILE              *f;
    int                status_local = 0;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    strcpy(value, "0");

    if (instance->status)
    {
        f = fopen(instance->status_path, "r");
        if (f == NULL)
        {
            /* Not error: status file can be missing */
            return 0;
        }

        if (fscanf(f, "%d", &status_local) != 1 || fclose(f) == EOF)
            return TE_OS_RC(TE_TA_UNIX, errno);

        /* Fix value: -1 -> 0, any other -> 1 */
        if (status_local == -1)
            status_local = 0;
        else
            status_local = 1;

        sprintf(value, "%d", status_local);
    }

    return 0;
}

/** Set desired OpenVPN daemon status */
static te_errno
openvpn_status_set(unsigned int gid, const char *oid,
                   const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    int                new_status;
    te_errno           rc;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    new_status = atoi(value);
    if (new_status != 1 && new_status != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    if (new_status != instance->status)
    {
        if (new_status == 1)
        {
            rc = openvpn_server_prepare_input_files(instance);
            if (rc != 0)
            {
                ERROR("Couldn't write input files: %r", rc);
                return rc;
            }

            rc = openvpn_server_start(instance);
            if (rc != 0)
            {
                ERROR("Couldn't start server: %r", rc);
                return rc;
            }
        }
        else
        {
            rc = openvpn_server_stop(instance);
            if (rc != 0)
            {
                ERROR("Couldn't stop server: %r", rc);
                return rc;
            }
        }
    }

    return 0;
}

/** Obtain the value indicating whether it is server or client mode */
static te_errno
openvpn_is_server_get(unsigned int gid, const char *oid,
                      char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    sprintf(value, "%d", instance->is_server);

    return 0;
}


/** Set the value indicating whether it is server or client mode */
static te_errno
openvpn_is_server_set(unsigned int gid, const char *oid,
                      const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    int                val;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    val = atoi(value);
    if (val != 1 && val != 0)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    instance->is_server = val;
    openvpn_server_restart(instance);

    return 0;
}

/** Obtain the server's port */
static te_errno
openvpn_port_get(unsigned int gid, const char *oid,
                 char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    sprintf(value, "%u", instance->port);

    return 0;
}


/** Set the server's port */
static te_errno
openvpn_port_set(unsigned int gid, const char *oid,
                 const char *value, const char *instN, ...)
{
    te_openvpn_server *instance = openvpn_get_server(instN);
    char              *end = NULL;
    unsigned long      port;

    UNUSED(gid);
    UNUSED(oid);

    OPENVPN_CHECK(instance);

    port = strtoul(value, &end, 10);
    if (*end != '\0' || port > UINT16_MAX)
        return TE_RC(TE_TA_UNIX, TE_EINVAL);

    instance->port = (uint16_t)port;
    openvpn_server_restart(instance);

    return 0;
}

/**
 * Generate TLS verification script
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_tls_verify_script(te_openvpn_server *instance)
{
    user              *u;
    FILE              *f;
    te_errno           rc = 0;

    f = fopen(instance->tls_verify_script_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    FPRINTF(f, "#!/bin/bash\n");
    FPRINTF(f, "# Test Environment auto-generated script"
               " for TLS verification\n");

    /* Ignore CA checks */
    FPRINTF(f, "if [ \"${tls_digest_sha256_0}\" == \"\" ] ; then\n");
    FPRINTF(f, "exit 0\n");
    FPRINTF(f, "fi\n");

    /* Check certificate fingerprint */
    for (u = instance->users; u != NULL; u = u->next)
    {
        /* TODO: check all certificates in chain, now we check only CA -> cert
         */
        FPRINTF(f, "if [ \"${tls_digest_sha256_0}\" == \"%s\" ] ; then\n",
                u->fingerprint);
        FPRINTF(f, "exit 0\n");
        FPRINTF(f, "fi\n");
    }

    FPRINTF(f, "exit 1\n");

cleanup:
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}

/**
 * Generate user verification script
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_user_verify_script(te_openvpn_server *instance)
{
    user              *u;
    FILE              *f;
    te_errno           rc = 0;

    f = fopen(instance->user_verify_script_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    FPRINTF(f, "#!/bin/bash\n");
    FPRINTF(f, "# Test Environment auto-generated script"
               " for user verification\n");

    FPRINTF(f, "username=$(head -1 $1)\n");
    FPRINTF(f, "password=$(tail -1 $1)\n");

    /* Check users */
    for (u = instance->users; u != NULL; u = u->next)
    {
        FPRINTF(f, "if [ \"${username}\" == \"%s\" ] ; then\n", u->username);
        FPRINTF(f, "if [ \"${password}\" != \"%s\" ] ; then\n", u->password);
        FPRINTF(f, "exit 1\n");
        FPRINTF(f, "fi\n");
        FPRINTF(f, "fi\n");

        /* FIXME: Need to check against certificate's common name */
    }

    /*
     * FIXME: Assume all clients are allowed except those with explicit
     * username/password.
     */
    FPRINTF(f, "exit 0\n");

cleanup:
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}

/**
 * Generate updown script
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_updown_script(te_openvpn_server *instance)
{
    FILE              *f;
    te_errno           rc = 0;

    f = fopen(instance->updown_script_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    FPRINTF(f, "#!/bin/bash\n");
    FPRINTF(f, "# Test Environment auto-generated script for up/down events\n");

    FPRINTF(f, "if [ \"$1\" == \"up\" ] ; then\n");
    FPRINTF(f, "echo ${ifconfig_local} > %s\n", instance->status_path);
    FPRINTF(f, "else\n");
    FPRINTF(f, "echo -1 > %s\n", instance->status_path);
    FPRINTF(f, "fi\n");

    FPRINTF(f, "printenv dev > %s\n", instance->ifname_path);

cleanup:
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}

/**
 * Generate client connect handling script
 *
 * @param instance  Server instance.
 *
 * @return Status code.
 */
static te_errno
openvpn_server_generate_client_connect_script(te_openvpn_server *instance)
{
    user              *u;
    FILE              *f;
    te_errno           rc = 0;

    f = fopen(instance->client_connect_script_path, "w");
    if (f == NULL)
        return TE_OS_RC(TE_TA_UNIX, errno);

    FPRINTF(f, "#!/bin/bash\n");
    FPRINTF(f, "# Test Environment auto-generated script for up/down events\n");

    /* Match by common name */
    FPRINTF(f, "if [ -n \"${common_name}\" ] ; then\n");
    for (u = instance->users; u != NULL; u = u->next)
    {
        FPRINTF(f, "if [ \"${common_name}\" == \"%s\" ] ; then\n", u->username);
        FPRINTF(f, "if [ \"$1\" == \"up\" ] ; then\n");
        FPRINTF(f, "echo 1 > " OPENVPN_USER_STATUS_PATH_FMT "\n",
                instance->name, u->name);
        FPRINTF(f, "else\n");
        FPRINTF(f, "echo 0 > " OPENVPN_USER_STATUS_PATH_FMT "\n",
                instance->name, u->name);
        FPRINTF(f, "fi\n");
        FPRINTF(f, "exit 0\n");
        FPRINTF(f, "fi\n");
    }
    FPRINTF(f, "fi\n");

    /* Match by digest */
    FPRINTF(f, "digest=\"${tls_digest_sha256_1}\"\n");
    FPRINTF(f, "if [ -n \"${digest}\" ] ; then\n");
    for (u = instance->users; u != NULL; u = u->next)
    {
        FPRINTF(f, "if [ \"${digest}\" == \"%s\" ] ; then\n", u->fingerprint);
        FPRINTF(f, "if [ \"$1\" == \"up\" ] ; then\n");
        FPRINTF(f, "echo 1 > " OPENVPN_USER_STATUS_PATH_FMT "\n",
                instance->name, u->name);
        FPRINTF(f, "else\n");
        FPRINTF(f, "echo 0 > " OPENVPN_USER_STATUS_PATH_FMT "\n",
                instance->name, u->name);
        FPRINTF(f, "fi\n");
        FPRINTF(f, "fi\n");
    }
    FPRINTF(f, "fi\n");

cleanup:
    if (fclose(f) == EOF && rc == 0)
        rc = TE_OS_RC(TE_TA_UNIX, errno);

    return rc;
}

/** List instances */
static te_errno
openvpn_list(unsigned int gid, const char *oid,
             const char *sub_id, char **list, ...)
{
    te_openvpn_server *p = server_head;
    te_errno           rc;
    te_string          str = TE_STRING_INIT;

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(sub_id);

    while (p != NULL)
    {
        rc = te_string_append(&str,
                              p->next == NULL ? "%s" : "%s ",
                              p->name);
        if (rc != 0)
        {
            te_string_free(&str);
            return TE_RC(TE_TA_UNIX, rc);
        }

        p = p->next;
    }

    *list = str.ptr;
    return 0;
}

/**
 * Grab resources allocated by daemon.
 *
 * @param name Resource name.
 *
 * @return Status code.
 */
te_errno
openvpn_grab(const char *name)
{
    UNUSED(name);

    if (access(OPENVPN_PATH, X_OK) != 0)
    {
        ERROR("OpenVPN server executable was not found");
        return TE_RC(TE_TA_UNIX, TE_ENOENT);
    }

    return 0;
}

/**
 * Release resources allocated by daemon.
 *
 * @param name Resource name.
 *
 * @return Status code.
 */
te_errno
openvpn_release(const char *name)
{
    UNUSED(name);
    return 0;
}

/** Add a new server */
static te_errno
openvpn_add(unsigned int gid, const char *oid,
            const char *value, const char *openvpn, ...)
{
    te_openvpn_server  *instance;

    UNUSED(gid);
    UNUSED(oid);
    UNUSED(value);

    instance = openvpn_get_server(openvpn);
    if (instance != NULL)
    {
        ERROR("Server with such name already exists: %s", instance);
        return TE_RC(TE_TA_UNIX, TE_EEXIST);
    }

    instance = openvpn_server_create(openvpn);
    if (instance == NULL)
    {
        ERROR("Couldn't allocate server instance");
        return TE_RC(TE_TA_UNIX, TE_ENOMEM);
    }

    openvpn_add_server(instance);

    return 0;
}

/** Delete server */
static te_errno
openvpn_del(unsigned int gid, const char *oid,
            const char *openvpn, ...)
{
    te_openvpn_server *instance;
    te_errno           rc;

    UNUSED(gid);
    UNUSED(oid);

    instance = openvpn_get_server(openvpn);
    if (instance == NULL)
    {
        ERROR("Unknown server is ought to be stopped");
        return TE_RC(TE_TA_UNIX, TE_ENOENT);
    }

    if (instance->status)
    {
        rc = openvpn_server_stop(instance);
        if (rc != 0)
            WARN("Couldn't stop instance, continue removing anyway: %r", rc);
    }

    instance = openvpn_del_server(openvpn);
    if (instance == NULL)
    {
        ERROR("Unknown server is ought to be released");
        return TE_RC(TE_TA_UNIX, TE_ENOENT);
    }

    openvpn_server_free(instance);
    return 0;
}

/** Initialize the tree */
te_errno
ta_unix_conf_openvpn_init(void)
{
    return rcf_pch_add_node("/agent/", &node_openvpn);
}

RCF_PCH_CFG_NODE_RW(node_openvpn_client_password, "password",
                    NULL, NULL,
                    openvpn_client_password_get, openvpn_client_password_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_client_username, "username",
                    NULL, &node_openvpn_client_password,
                    openvpn_client_username_get, openvpn_client_username_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_client_peer_port, "port",
                    NULL, NULL,
                    openvpn_client_peer_port_get, openvpn_client_peer_port_set);

RCF_PCH_CFG_NODE_COLLECTION(node_openvpn_client_peer, "peer",
                            &node_openvpn_client_peer_port,
                            &node_openvpn_client_username,
                            openvpn_peer_add, openvpn_peer_del,
                            openvpn_peer_list, NULL);

RCF_PCH_CFG_NODE_RW(node_openvpn_client, "client",
                    &node_openvpn_client_peer, NULL,
                    NULL, NULL);

RCF_PCH_CFG_NODE_RO(node_openvpn_server_connected_users, "connected_users",
                    NULL, NULL,
                    openvpn_server_connected_users_get);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_user_certificate, "certificate",
                    NULL, NULL,
                    openvpn_server_user_certificate_get,
                    openvpn_server_user_certificate_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_user_password, "password",
                    NULL, &node_openvpn_server_user_certificate,
                    openvpn_server_user_password_get,
                    openvpn_server_user_password_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_user_username, "username",
                    NULL, &node_openvpn_server_user_password,
                    openvpn_server_user_username_get,
                    openvpn_server_user_username_set);

RCF_PCH_CFG_NODE_COLLECTION(node_openvpn_server_user, "user",
                            &node_openvpn_server_user_username,
                            &node_openvpn_server_connected_users,
                            openvpn_user_add, openvpn_user_del,
                            openvpn_user_list, NULL);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_require_certs, "require_certs",
                    NULL, &node_openvpn_server_user,
                    openvpn_server_require_certs_get,
                    openvpn_server_require_certs_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_pool_end, "end",
                    NULL, NULL,
                    openvpn_server_pool_end_get, openvpn_server_pool_end_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_pool_start, "start",
                    NULL, &node_openvpn_server_pool_end,
                    openvpn_server_pool_start_get,
                    openvpn_server_pool_start_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_pool, "pool",
                    &node_openvpn_server_pool_start,
                    &node_openvpn_server_require_certs,
                    NULL, NULL);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_dh_size, "size",
                    NULL, NULL,
                    openvpn_server_dh_size_get, openvpn_server_dh_size_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_dh, "dh",
                    &node_openvpn_server_dh_size, &node_openvpn_server_pool,
                    openvpn_server_dh_get, openvpn_server_dh_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_subnet_mask, "subnet_mask",
                    NULL, &node_openvpn_server_dh,
                    openvpn_server_subnet_mask_get,
                    openvpn_server_subnet_mask_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server_ip, "ip",
                    NULL, &node_openvpn_server_subnet_mask,
                    openvpn_server_ip_get,
                    openvpn_server_ip_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_server, "server",
                    &node_openvpn_server_ip, &node_openvpn_client,
                    NULL, NULL);

RCF_PCH_CFG_NODE_RW(node_openvpn_ip_facility, "ip_facility",
                    NULL, &node_openvpn_server,
                    openvpn_ip_facility_get, openvpn_ip_facility_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_port, "port",
                    NULL, &node_openvpn_ip_facility,
                    openvpn_port_get, openvpn_port_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_value, "value",
                    NULL, NULL,
                    openvpn_option_value_get, openvpn_option_value_set);

RCF_PCH_CFG_NODE_COLLECTION(node_openvpn_option, "option",
                            &node_openvpn_value,
                            &node_openvpn_port,
                            openvpn_option_add, openvpn_option_del,
                            openvpn_option_list, NULL);

RCF_PCH_CFG_NODE_RW(node_openvpn_interface_behind, "interface_behind",
                    NULL, &node_openvpn_option,
                    openvpn_interface_behind_get, openvpn_interface_behind_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_lzo, "lzo",
                    NULL, &node_openvpn_interface_behind,
                    openvpn_lzo_get, openvpn_lzo_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_proto, "proto",
                    NULL, &node_openvpn_lzo,
                    openvpn_proto_get, openvpn_proto_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_key, "key",
                    NULL, &node_openvpn_proto,
                    openvpn_key_get, openvpn_key_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_cert, "cert",
                    NULL, &node_openvpn_key,
                    openvpn_cert_get, openvpn_cert_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_ca, "ca",
                    NULL, &node_openvpn_cert,
                    openvpn_ca_get, openvpn_ca_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_tls_key, "tls_key",
                    NULL, &node_openvpn_ca,
                    openvpn_tls_key_get, openvpn_tls_key_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_digest, "digest",
                    NULL, &node_openvpn_tls_key,
                    openvpn_digest_get, openvpn_digest_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_cipher, "cipher",
                    NULL, &node_openvpn_digest,
                    openvpn_cipher_get, openvpn_cipher_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_key_direction, "key_direction",
                    NULL, &node_openvpn_cipher,
                    openvpn_key_direction_get, openvpn_key_direction_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_mode, "mode",
                    NULL, &node_openvpn_key_direction,
                    openvpn_mode_get, openvpn_mode_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_is_server, "is_server",
                    NULL, &node_openvpn_mode,
                    openvpn_is_server_get, openvpn_is_server_set);

RCF_PCH_CFG_NODE_RW(node_openvpn_status, "status",
                    NULL, &node_openvpn_is_server,
                    openvpn_status_get,
                    openvpn_status_set);

RCF_PCH_CFG_NODE_RO(node_openvpn_endpoint_ip, "endpoint_ip",
                    NULL, &node_openvpn_status,
                    openvpn_endpoint_ip_get);

RCF_PCH_CFG_NODE_RO(node_openvpn_ifname, "ifname",
                    NULL, &node_openvpn_endpoint_ip,
                    openvpn_ifname_get);

/* Configuration subtree root /agent/openvpn */
RCF_PCH_CFG_NODE_RW_COLLECTION(node_openvpn, "openvpn",
                               &node_openvpn_ifname, NULL,
                               openvpn_status_get, openvpn_status_set,
                               openvpn_add, openvpn_del, openvpn_list, NULL);
