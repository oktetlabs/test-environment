#! /bin/bash
#
# Test Environment Builder
#
# Collection of functions.
#
# Copyright (C) 2003-2018 OKTET Labs.
#
# Author Oleg Sadakov <Oleg.Sadakov@oktetlabs.ru>
#
# $Id$
#

##
# Replace invalid characters in variable names
#
te_ta_sanitize()
{
    sed 's/[-.]/_/g'
}

##
# Calculate a signature on the local machine
#
# @param CC    compiler with flags
#
te_ta_signature_local()
{
    local CC=$1

    # Use option '-print-multiarch' with different gcc versions
    # gives different results:
    #  - exit code @c 1 with message on stderr (for old gcc version in
    #    RHEL 6, Debian 6)
    #  - exit code @c 0 with empty message (for RHEL 7)
    #  - exit code @c 0 with correct triplet on stdout (for Ubuntu 14.04,
    #    Debian 7 or 8)
    local GCC_TARGET=$($CC -print-multiarch 2>/dev/null)
    if test -z "$GCC_TARGET" ; then
        # '-dumpmachine' returns triplet independently on options
        # '-m32' and '-m64'
        GCC_TARGET=$($CC -dumpmachine)

        # Determine architecture manually
        local march=i386
        if echo | $CC -E -dM - |
            grep -q '^#define\s*__x86_64__\s*1$' ; then
            march=x86_64
        fi

        # Fix the triplet if it is necessary
        case "$GCC_TARGET:$march" in
            x86_64-*:x86_64 ) ;;
            x86_64-*:i386 )   GCC_TARGET="i386-${GCC_TARGET#*-}" ;;
            *:x86_64 )        GCC_TARGET="x86_64-${GCC_TARGET#*-}" ;;
            *:* )             ;;
        esac
    fi
    case "$GCC_TARGET" in
        *-linux-gnu | \
        *-redhat-linux )
            local TEMP_IN="$(mktemp /tmp/tmp.XXXXXXXXXX.c)"
            echo '
                #include <stdio.h>
                #include <linux/version.h>
                int main() {
                    printf("%i.%i.%i",
                        LINUX_VERSION_CODE/0x10000,
                        LINUX_VERSION_CODE/0x100  %0x100,
                        LINUX_VERSION_CODE        %0x100);
                    return 0;
                }
            ' >$TEMP_IN
            local TEMP_OUT=$(mktemp)
            $CC $TEMP_IN -o $TEMP_OUT
            if test $? -ne 0; then
                echo "Cannot build application to get variable"\
                    "LINUX_VERSION_CODE" >&2
                exit 1
            fi
            local LIBC=`ldd $TEMP_OUT |
                sed -n "s/^\s*libc.so.6 => \(.*\)(0x[0-9a-f]*)$/\1/p"`
            local LINUX_VERSION_CODE=`$TEMP_OUT`
            rm -f $TEMP_OUT
            rm -f $TEMP_IN

            local LIBC_VERSION=`$LIBC |
                sed -n "s/.*version \([0-9\.]*\).*/\1/p;q"`
            local KERN_HEADERS=`$LIBC |
                sed -n "s/.*Linux \([0-9\.]*\).*/\1/p"`

            echo -n "${GCC_TARGET}"
            echo -n "_glibc${LIBC_VERSION}"
            echo -n "_with${KERN_HEADERS}"
            echo "_header${LINUX_VERSION_CODE}"
            ;;

        * ) echo "$GCC_TARGET" ;;
    esac | te_ta_sanitize
}


##
# Calculate a signature of the specified agent
#
# @param name of agent host
# @param compiler with flags
#
te_ta_signature()
{
    local HOST=$1
    local CC=$2
    { cat ${TE_BASE}/engine/builder/te_functions;  \
        echo -e "\nte_ta_signature_local '$CC'"; } | \
        ssh $HOST /bin/bash -
    local RES=$?
    test $RES -ne 0 && exit $RES
    return 0
}


##
# Executes the instructions on specified host
#
# @param platform signature
# @param instructions
#
te_eval_or_ssh() {
    local SSHVAR=${1}_SSH
    shift
    if test -z "${!SSHVAR}" ; then
        ( cd /tmp && eval "${@}" )
    else
        # SSH command may have arguments in double-quotes with spaces
        eval "${!SSHVAR} \"cd /tmp || exit 1 ; \${@}\""
    fi
}

##
# Executes the instructions on specified host in the same directory
# as current (assuming NFS).
#
# @param platform signature
# @param instructions
#
te_eval_or_ssh_pwd() {
    local SSHVAR=${1}_SSH
    shift
    if test -z "${!SSHVAR}" ; then
        ( eval "${@}" )
    else
        # SSH command may have arguments in double-quotes with spaces
        eval "${!SSHVAR} \"cd '\$PWD' || exit 1; \${@}\""
    fi
}


##
# Check if the @p list contains the @p target
#
# @param target String for search
# @param list   Elements list
#
# @return       @c 0 in case target argument is found,
#               else - @c 1 is returned.
#
te_is_in_list() {
    local target=$1
    shift
    for i in ${@} ; do
        if test "$target" = "$i" ; then
            return 0
        fi
    done
    return 1
}

##
# Check whether a given component is eligible for TCE
#
# @param platform  Platform name
# @param component Component name
#
# @return          @c 0 if TCE is supported
#                  @c 1 otherwise
te_check_tce() {
    local tcevar="TE_BS_TCE_${1}_${2}_SOURCES"
    if test -n "${!tcevar}"; then
        if test "${TE_DO_TCE}" = all ||
                te_is_in_list ${1} ${TE_DO_TCE}; then
            return 0
        fi
    fi
    return 1
}

##
# Recursively update Makefiles
#
# @param $1     Directory name
#
# @return exit code from @b make
#
recursive_update_makefiles() {
    local filename="$TE_BASE/auxdir/Makefile.update"
    make -C "$1" MASTER_FILE=Makefile MAKEFILE_UPDATE="$filename" \
        -f "$filename" update-recursive
    return $?
}

##
# Convert hostname to valid for sh variable name
#
# @param $1     Hostname
#
# @return       Valid name of variable
#
te_hostname2shname() {
    echo "$1" |
    sed '
        s/-/_1/g
        s/\./_2/g
        s/^[0-9]/_&/
    '
}

