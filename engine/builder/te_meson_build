#!/bin/bash
#
# Test Environment
#
# Build TE using meson/ninja.
#
# Copyright (C) 2018 OKTET Labs. All rights reserved.

set -e
set -E

SCRIPT_DIR="$(dirname "$0")"

with_config="$1"

# Put initial values to control variables
declare -a RSYNC
RSYNC+=(rsync)
RSYNC+=("--exclude=.git")
RSYNC+=(-a)

declare -a RSYNC_TO_ARGS
RSYNC_TO_ARGS+=(--delete-during)

# List of all available TAD protocols
TAD_PROTOCOLS_ALL="arp"
TAD_PROTOCOLS_ALL+=" atm"
TAD_PROTOCOLS_ALL+=" bridge"
TAD_PROTOCOLS_ALL+=" cli"
TAD_PROTOCOLS_ALL+=" dhcp"
TAD_PROTOCOLS_ALL+=" eth"
TAD_PROTOCOLS_ALL+=" flow"
TAD_PROTOCOLS_ALL+=" forw"
TAD_PROTOCOLS_ALL+=" geneve"
TAD_PROTOCOLS_ALL+=" gre"
TAD_PROTOCOLS_ALL+=" igmp"
TAD_PROTOCOLS_ALL+=" ipstack"
TAD_PROTOCOLS_ALL+=" iscsi"
TAD_PROTOCOLS_ALL+=" pcap"
TAD_PROTOCOLS_ALL+=" ppp"
TAD_PROTOCOLS_ALL+=" rte_mbuf"
TAD_PROTOCOLS_ALL+=" snmp"
TAD_PROTOCOLS_ALL+=" socket"
TAD_PROTOCOLS_ALL+=" vxlan"

error() {
    echo ERROR: $* >&2
    exit 1
}

warning() {
    echo WARNING: $* >&2
}

on_error() {
    error "Unhandled error at ${BASH_SOURCE[0]}:${BASH_LINENO[0]}"
}

trap on_error ERR

process_parameters() {
    local pfx="$1"; shift
    local msg="$1"; shift

    local parms_var="${pfx}PARMS"
    test -z "${!parms_var}" ||
        warning "${msg} parameters not supported: ${!parms_var}"

    local cppflags_var="${pfx}CPPFLAGS"
    test -z "${!cppflags_var}" ||
        warning "${msg} CPPFLAGS not supported: ${!cppflags_var}"

    local cflags_var="${pfx}_CFLAGS"
    test -z "${!cflags_var}" ||
        warning "${msg} CFLAGS not supported: ${!cflags_var}"

    local ldflags_var="${pfx}LDFLAGS"
    test -z "${!ldflags_var}" ||
        warning "${msg} LDFLAGS not supported: ${!ldflags_var}"

    local libs_var="${pfx}LIBS"
    test -z "${!libs_var}" ||
        warning "${msg} LIBS not supported: ${!libs_var}"
}

set_sniffers() {
    local val="${1}"; shift

    if test -n "${use_sniffers}" -a "${use_sniffers}" != "${val}" ; then
        error "The passed parameters --with/without-sniffers are inconsistent"
    else
        use_sniffers="${val}"
    fi
}

add_meson_lib_opt() {
    local l="$1"; shift
    local lrname="$1"; shift
    local name="$1"; shift
    local value="$@"

    test -z "${name}" -o -n "${name//[[:alnum:]_-]/}" &&
        error "Wrong meson option name: ${name}"

    local opt_name="${l//-/_}_${name//-/_}"
    meson_lib_opts+=" ${opt_name}"

    eval meson_lib_lname_${opt_name}=\"\${l}\"
    eval meson_lib_lrname_${opt_name}=\"\${lrname}\"
    eval meson_lib_opt_name_${opt_name}=\"\${name}\"
    eval meson_lib_opt_val_${opt_name}=\"\${value}\"
}

process_library_agentlib() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p

    for p in ${!parms_var} ; do
        case ${p} in
            --disable-dlfcn-lookup) ;;
            --enable-dlfcn-lookup)
                add_meson_lib_opt ${l} ${lrname} agentlib-dlfcn-lookup true ;;
            --disable-ftp) ;;
            --enable-ftp)
                add_meson_lib_opt ${l} ${lrname} agentlib-ftp true ;;
            --disable-power-sw) ;;
            --enable-power-sw)
                add_meson_lib_opt ${l} ${lrname} agentlib-power-sw true ;;
            --disable-telephony) ;;
            --enable-telephony)
                add_meson_lib_opt ${l} ${lrname} agentlib-telephony true ;;
            --disable-dlfcn-upnp) ;;
            --enable-dlfcn-upnp)
                add_meson_lib_opt ${l} ${lrname} agentlib-upnp true ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done
    eval ${parms_var}=\"${parms}\"
}

process_library_rcfpch() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p

    for p in ${!parms_var} ; do
        case ${p} in
            --with-sniffers=yes|--with-sniffers)
                set_sniffers true
                ;;
            --with-sniffers=no|--without-sniffers)
                set_sniffers false
                ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done
    eval ${parms_var}=\"${parms}\"
}

process_library_rpcserver() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p

    for p in ${!parms_var} ; do
        case ${p} in
            --with-agentlib=*)
                add_meson_lib_opt ${l} ${lrname} rpcserver-agentlib "${p#--with-agentlib=}" ;;
            --enable-plugins=no|--disable-plugins)
                add_meson_lib_opt ${l} ${lrname} rpcserver-idle-plugins false ;;
            --enable-mem=no|--disable-mem)
                add_meson_lib_opt ${l} ${lrname} rpcserver-smart-mem false ;;
            --with-tr069)
                add_meson_lib_opt ${l} ${lrname} rpcserver-tr069 true ;;
            --enable-static-rpc-lookup)
                add_meson_lib_opt ${l} ${lrname} static-rpc-lookup true ;;
            --enable-typesafe-rpc=no|--disable-typesafe-rpc)
                add_meson_lib_opt ${l} ${lrname} typesafe-rpc false ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done
    eval ${parms_var}=\"${parms}\"
}

process_library_rpcxdr() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p

    for p in ${!parms_var} ; do
        case ${p} in
            --with-rpcdefs=*)
                meson_args="${meson_args} -Drpcdefs=\"${p#--with-rpcdefs=}\"" ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done
    eval ${parms_var}=\"${parms}\"
}

update_tad_with_protocols() {
    local tad_protos="${1}"; shift
    local tad_proto

    for tad_proto in ${tad_protos} ; do
        local proto_add=true
        local tad_with_proto
        for tad_with_proto in ${tad_with_protocols} ; do
            if test "${tad_proto}" = "${tad_with_proto}" ; then
                proto_add=false
                break
            fi
        done
        test ${proto_add} && tad_with_protocols="${tad_with_protocols} ${tad_proto}"
    done
}

process_library_tad() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p
    local lib_tad_protocols=

    for p in ${!parms_var} ; do
        case ${p} in
            --without-cs)
                add_meson_lib_opt ${l} ${lrname} tad-cs false ;;
            --with-packet-mmap-rx-ring)
                add_meson_lib_opt ${l} ${lrname} tad-packet_mmap_rx_ring true ;;
            --with-*)
                lib_tad_protocols="${lib_tad_protocols} ${p#--with-}" ;;
            --without-static-libc)
                # default, in fact --with-static-libc is not supported yet
                ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done

    if test -z "${lib_tad_protocols}" ; then
        lib_tad_protocols="${TAD_PROTOCOLS_ALL}"
    else
        # tad protocol name may contain a hyphen (rte-mbuf)
        lib_tad_protocols="${lib_tad_protocols//-/_}"
    fi

    add_meson_lib_opt ${l} ${lrname} tad-protocols "${lib_tad_protocols}"

    update_tad_with_protocols "${lib_tad_protocols}"

    eval ${parms_var}=\"${parms}\"
}

process_library_tapi_tad() {
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local parms=
    local p

    for p in ${!parms_var} ; do
        case ${p} in
            --with-*)
                update_tad_with_protocols "${p#--with-}" ;;
            --without-*)
                tad_without_protocols="${tad_without_protocols} ${p#--without-}" ;;
            *)
                parms="${parms}${parms:+ }${p}" ;;
        esac
    done
    eval ${parms_var}=\"${parms}\"
}

process_library() {
    local p="$1"; shift
    local l="$1"; shift
    local lrname="$1"; shift
    local pfx="TE_BS_LIB_${p}_${l}_"
    local msg="Platform library ${p}/${l}"

    case "${lrname}" in
        agentlib)   process_library_agentlib "${pfx}" ;;
        rcfpch)     process_library_rcfpch "${pfx}" ;;
        rpcserver)  process_library_rpcserver "${pfx}" ;;
        rpcxdr)     process_library_rpcxdr "${pfx}" ;;
        tad)        process_library_tad "${pfx}" ;;
        tapi_tad)   process_library_tapi_tad "${pfx}" ;;
    esac


    process_parameters "${pfx}" "${msg}"
}

process_agent_unix_parms() {
    local p

    while test -n "$1" ; do
        p="$1"
        case "${p}" in
            --with-cfg-unix-daemons=*)
                daemons="${p#--with-cfg-unix-daemons=}"
                ;;
            --with-8021x)
                conf="${conf} 8021x" ;;
            --with-aggr)
                conf="${conf} aggr" ;;
            --with-bpf)
                conf="${conf} bpf" ;;
            --with-iptables)
                conf="${conf} iptables" ;;
            --with-libnetconf)
                # automatic if netconf library is built
                ;;
            --with-ntpd)
                conf="${conf} ntpd" ;;
            --with-ovs)
                conf="${conf} ovs" ;;
            --with-pam)
                conf="${conf} pam" ;;
            --enable-pci)
                conf="${conf} pci" ;;
            --with-pcre)
                # may be ignored since pulled as rpcs_job dependency in
                # the case of meson build
                ;;
            --with-rcf-rpc)
                # always
                ;;
            --with-serialparse)
                conf="${conf} serial-parser" ;;
            --with-serial)
                conf="${conf} serial" ;;
            --with-sfptpd)
                conf="${conf} sfptpd" ;;
            --with-sniffers=yes|--with-sniffers)
                set_sniffers true
                ;;
            --with-sniffers=no|--without-sniffers)
                set_sniffers false
                ;;
            --with-tc)
                conf="${conf} tc" ;;
            --with-tirpc)
                # added automatically
                ;;
            --with-tr069)
                conf="${conf} tr069" ;;
            --with-upnp_cp)
                conf="${conf} upnp_cp" ;;
            --with-vcm)
                conf="${conf} vcm" ;;
            --without-static-libc)
                # default, in fact --with-static-libc is not supported yet
                ;;
            --disable-networkmanager-check)
                conf="${conf} disable-networkmanager-check" ;;
            *)
                parms="${parms}${parms:+ }\"${p}\"" ;;
        esac
        shift
    done
}

make_meson_opt_array() {
    local option="$1"; shift
    local o
    local vals=""

    for o in ${option} ; do
        test -z "${vals}" && vals=${o} || vals+=",${o}"
    done
    echo ${vals}
}

process_agent_unix() {
    local ta="$1"; shift
    local pfx="$1"; shift
    local parms_var="${pfx}PARMS"
    local libs_var="${pfx}LIBS"
    local ta_platform="${pfx}PLATFORM"
    local parms=
    local conf=
    local daemons=

    meson_args="${meson_args} -Dagent-unix-name=${ta}"
    meson_args="${meson_args} -Dagent-unix-platform=${!ta_platform}"

    # eval is required interpret correctly parameter values with
    # whitespaces in quotes
    eval process_agent_unix_parms ${!parms_var}

    eval ${parms_var}=\"\${parms}\"

    test -z "${conf}" ||
        meson_args="${meson_args} -Dagent-unix-conf=\"$(make_meson_opt_array "${conf}")\""
    test -z "${daemons}" ||
        meson_args="${meson_args} -Dagent-unix-daemons=\"$(make_meson_opt_array "${daemons}")\""

    test -z "${!libs_var}" || {
        meson_args="${meson_args} -Dagent-unix-libs=\"$(make_meson_opt_array "${!libs_var}")\""
        eval ${libs_var}=
    }
}

process_agent() {
    local p="$1"; shift
    local ta="$1"; shift
    local pfx="TE_BS_TA_${ta}_"
    local msg="Agent ${ta}"

    local src_var="${pfx}SOURCES"
    local ta_src="$(basename "${!src_var}")"

    local ta_apps_var="TE_BS_TA_APPS_${ta}"

    build_agents="${build_agents} ${ta_src}"

    case "${ta_src}" in
        unix)   process_agent_unix "${ta}" "${pfx}" ;;
    esac

    process_parameters "${pfx}" "${msg}"
}

process_platform() {
    local p="$1"; shift
    local tad_protocols="${TAD_PROTOCOLS_ALL}"
    local tad_with_protocols=
    local tad_without_protocols=
    local use_sniffers=

    local parms_var="${p}_PARMS"
    if test -n "${!parms_var}" ; then
        warning "Platform parameters are not supported"
        warning "Requested platform parameters: ${!parms_var}"
    fi

    local te_cflags=
    for suffix in CPPFLAGS_VAR CFLAGS_VAR CPPFLAGS CFLAGS ; do
        local var=${p}_${suffix}
        local value=${!var}
        test -z "${value}" || te_cflags="${te_cflags} ${value}"
    done
    test -z "${te_cflags}" ||
        meson_args="${meson_args} -Dcflags=\"${te_cflags}\""

    local ldflags_var="${p}_LDFLAGS"
    if test -n "${!ldflags_var}" ; then
        local te_ldflags="${!ldflags_var}"
        meson_args="${meson_args} -Dldflags=\"${te_ldflags}\""
    fi

    local libs="${p}_LIBS"
    if test -n "${!libs}" ; then
        meson_args="${meson_args} -Dlibs=\"${!libs}\""
    fi

    for l in ${!libs} ; do
        local lrname
        local plsrc="TE_BS_LIB_${p}_${l}_SOURCES"
        if test -n "${!plsrc}" ; then
            # plsrc can point to sources outside of TE sources, but
            # we are trying to get the real name of the TE's library
            lrname=${!plsrc/${TE_BASE}\/lib\//}
        else
            lrname=${l}
        fi

        process_library ${p} ${l} ${lrname}
    done

    if test -n "${tad_with_protocols}" ; then
        tad_protocols="${tad_with_protocols}"
    elif test -n "${tad_without_protocols}" ; then
        local protocol
        local protocols=

        for protocol in ${tad_protocols} ; do
            echo "${tad_without_protocols}" | grep -wq "${protocol}" ||
                protocols="${protocols} ${protocol}"
        done
        tad_protocols="${protocols}"
    fi
    test -z "${tad_protocols}" ||
        meson_args="${meson_args} -Dtad-protocols=\"${tad_protocols}\""

    local build_agents=
    for ta in ${TE_BS_TA} ; do
        local platform="TE_BS_TA_${ta}_PLATFORM"
        test "${!platform}" != "${p}" || process_agent "${p}" "${ta}"
    done

    test -z "${use_sniffers}" ||
        meson_args="${meson_args} -Dsniffers=\"${use_sniffers}\""
    test -z "${build_agents}" ||
        meson_args="${meson_args} -Dagents=\"${build_agents}\""

    local papps="TE_BS_TA_APPS_$p"
    if test -n "${!papps}" ; then
        # Pass the list of agent apps to make sure the meson will build
        # static libraries for use with these apps
        meson_args="${meson_args} -Dagent-apps=\"${!papps}\""

        # Install headers and libraries
        meson_args="${meson_args} -Dinstall-dev=true"
    fi
}

process_engine_configurator() {
    local param="$1"; shift
    case "${param}" in
        --with-conf-yaml|--with-conf-yaml=yes)
            meson_args="${meson_args} -Dcs-conf-yaml=true" ;;
        --without-conf-yaml|--with-conf-yaml=no)
            meson_args="${meson_args} -Dcs-conf-yaml=false" ;;
        *) return 1 ;;
    esac
    return 0
}

process_engine_app() {
    local a="$1"; shift
    local pfx="TE_BS_APP_${a}_"
    local msg="Engine application ${a}"
    local p

    local parms_var="${pfx}PARMS"
    local parms=
    for p in ${!parms_var} ; do
        # Just ignore --with-large-logs since it is the default in meson build
        test "${a}" = logger -a "${p}" = "--with-large-logs" &&
            continue
        test "${a}" = rcf -a "${p}" = "--enable-ltdl-install" &&
            continue
        test "${a}" = configurator && process_engine_configurator "${p}" &&
            continue
        test "${a}" = tester -a "${p}" = "--with-trc" && {
            meson_args="${meson_args} -Dtrc=true"
            continue
        }
        parms="${parms}${parms:+ }${p}"
    done
    eval ${parms_var}=\"${parms}\"

    process_parameters "${pfx}" "${msg}"
}

process_engine_apps() {
    local a

    for a in ${TE_BS_APPS} ; do
        process_engine_app "${a}"
    done
}

process_engine_tool() {
    local t="$1"; shift
    local pfx="TE_BS_TOOL_${t}_"
    local msg="Engine tool ${t}"
    local p

    local parms_var="${pfx}PARMS"
    local parms=
    for p in ${!parms_var} ; do
        # Just ignore --with-large-logs since it is the default in meson build
        test "${t}" = rgt -a "${p}" = "--with-large-logs" &&
            continue
        if test "${t}" = trc ; then
            case ${p} in
                --with-spoilers)
                    meson_args="${meson_args} -Dtrc-spoilers=true" ;;
                --with-popups)
                    meson_args="${meson_args} -Dtrc-popups=true" ;;
                --with-log-urls)
                    meson_args="${meson_args} -Dtrc-log-urls=true" ;;
                --with-hidden-stats)
                    meson_args="${meson_args} -Dtrc-hidden-stats=true" ;;
                --with-ext-scripts=*)
                    meson_args="${meson_args} -Dtrc-ext-scripts=\"${p#--with-ext-scripts=}\"" ;;
                *)
                    parms="${parms}${parms:+ }${p}" ;;
            esac
        else
            parms="${parms}${parms:+ }${p}"
        fi
    done
    eval ${parms_var}=\"${parms}\"

    process_parameters "${pfx}" "${msg}"
}

process_engine_tools() {
    local t

    for t in ${TE_BS_TOOLS} ; do
        process_engine_tool "${t}"
    done
}

# Checks for host programs.
process_host_exec() {
    local i

    for i in $TE_BS_HOST_EXEC ; do
        which $i &>/dev/null || error "No host tool $i"
    done
}

# rsync_to PLATFORM SRC.. DST
rsync_to() {
    local p="$1"; shift
    local src="$1"; shift
    local dst="$1"; shift
    local sshvar="${p}_SSH"
    local ssh="${!sshvar}"

    while test -n "$1" ; do
        src="${src} \"${dst}\""
        dst="$1"
        shift
    done

    if test -n "${ssh}" ; then
        "${RSYNC[@]}" "${RSYNC_TO_ARGS[@]}" -e "${ssh% *}" ${src} "${ssh##* }:${dst}"
    else
        "${RSYNC[@]}" "${RSYNC_TO_ARGS[@]}" ${src} "${dst}"
    fi
}

rsync_from() {
    local p="$1"; shift
    local src="$1"; shift
    local dst="$1"; shift
    local sshvar="${p}_SSH"
    local ssh="${!sshvar}"

    if test -n "${ssh}" ; then
        "${RSYNC[@]}" -e "${ssh% *}" "${ssh##* }:${src}" "${dst}"
    else
        "${RSYNC[@]}" "${src}" "${dst}"
    fi
}

mk_platform_src() {
    local p="$1"; shift
    local src_ws="$1"; shift
    local l

    rsync_to "${p}" "${TE_BASE}"/ "${src_ws}"

    local libs="${p}_LIBS"
    for l in ${!libs} ; do
        local src_var="TE_BS_LIB_${p}_${l}_SOURCES"
        local src="${!src_var}"
        test -z "${src}" -o "${src}" = "${TE_BASE}/lib/${l}" ||
            rsync_to "${p}" "${src}"/ "${src_ws}/lib/${l}"
    done
}

process_builder_conf() {
    local config="$1"

    # Parse configuration file
    echo TE_BASE=$TE_BASE
    echo TE_BUILD=$TE_BUILD
    echo TE_INSTALL=$TE_INSTALL
    echo TE_INSTALL_NUT=$TE_INSTALL_NUT
    echo TE_INSTALL_SUITE=$TE_INSTALL_SUITE

    # Defaults
    echo TE_BS_APPS=\"builder rcf logger tester configurator\"

    if test -n "${config}" ; then
        if test ! -e "${config}" ; then
            error "Cannot find ${config}"
        fi
        cat "${TE_BASE}/engine/builder/builder.m4" "${config}" |
            m4 -I"$(dirname "${config}")"
    fi
    echo 'TE_PATH=${TE_INSTALL}/${TE_HOST}/bin'
}

read_processed_builder_conf() {
    local builder_conf_processed="$1"

    # Dummy loop to avoid breaking in the case of error
    while test 1 ; do
        . "${builder_conf_processed}"
        break
    done
    if test -n "$TE_BS_CONF_ERR" ; then
        echo $TE_BS_CONF_ERR >&2
        exit 1
    fi
    ( set -o posix ; set ) >/tmp/vars
}

process_platforms() {
    local p

    for p in ${TE_BS_PLATFORMS} ; do
        local build=${p}_BUILD

        test "${!build}" = autotools && continue

        # Non-volatile arguments which require build workspace bootstrap
        # --libdir is required to avoid host type subdir in lib/
        local meson_nv_args="--prefix=${TE_INSTALL}/${p} --libdir=lib"
        # Volatile argument which require workspace reconfigure
        local meson_args="-Dagentsdir=${TE_INSTALL}/agents"

        local meson_lib_opts=

        process_platform "${p}"

        if test ${p} = "${TE_HOST}" ; then
            meson_args="${meson_args} -Dengine=true"
            process_host_exec
            meson_args="${meson_args} -Dengine-apps=\"${TE_BS_APPS}\""
            process_engine_apps
            test -z "${TE_BS_TOOLS}" || {
                meson_args="${meson_args} -Dtools=\"${TE_BS_TOOLS}\""
                process_engine_tools
            }
        else
            # Build only static libraries for non-default platforms
            meson_nv_args="${meson_nv_args} --default-library=static"
        fi

        local clo=
        local opt
        for opt in ${meson_lib_opts} ; do
            local plname="meson_lib_lname_${opt}"
            local plrname="meson_lib_lrname_${opt}"
            local popt_name="meson_lib_opt_name_${opt}"
            local popt_val="meson_lib_opt_val_${opt}"
            test -n "${clo}" && clo+=","
            clo+="'${!plname}:${!plrname}:${!popt_name}:${!popt_val}'"
        done
        clo="-Dcustom-lib-opts=\"[${clo}]\""

        meson_args="${meson_args} ${clo}"

        eval TE_BS_MESON_${p}_NV_ARGS=\"\${meson_nv_args}\"
        eval TE_BS_MESON_${p}_ARGS=\"\${meson_args}\"
    done
}

make_workspace() {
    local p="$1"
    local ws_file="${p}.ws"
    local ws_base_dir="/tmp"

    if [ -n "$TE_WORKSPACE_DIR" ]; then
        te_eval_or_ssh "${p}" "test -d '${TE_WORKSPACE_DIR}'" &&
            ws_base_dir="${TE_WORKSPACE_DIR}"
    fi

    # Workspace directory
    if test ! -f "${ws_file}" ; then
        local hash=$(pwd | md5sum | awk --posix '{ print $1 }')
        local ws_dir="${ws_base_dir}/te_ws_${hash}"
        te_eval_or_ssh "${p}" "mkdir -p ${ws_dir}"
        echo "$ws_dir" > "$ws_file"
    fi
    ws="$(cat "${ws_file}")"
    echo Platform $p workspace is $ws

    te_eval_or_ssh "${p}" "mkdir -p \"${ws}\""

    # Make source workspace
    mk_platform_src "${p}" "${ws}"/src "${rsync}"

    # If non-local build, sync build directory
    if test "${ws}" != . ; then
        if test -d build ; then
            rsync_to "${p}" build "${ws}"
        else
            te_eval_or_ssh "${p}" "rm -rf \"${ws}\"/build"
        fi
    fi
}

build_ext_process_cmd() {
    local p="$1" ; shift
    local ws="$1" ; shift
    local pext="$1" ; shift
    local exec="$1" ; shift

    test "${exec:0:1}" = / -a -x "${exec}" || return 0

    local remote_extbuild="${ws}/ext/${pext}/build.sh"
    rsync_to "${p}" "${exec}" "${remote_extbuild}"
    extbuild="${remote_extbuild} $@"
}

build_ext() {
    local p="$1"; shift

    local pcppflags="${p}_CPPFLAGS"
    local pcflags="${p}_CFLAGS"
    local pldflags="${p}_LDFLAGS"
    local pexts="TE_BS_EXT_${p}"
    local pext

    local ext_inst="${ws}/destdir${TE_INSTALL}"
    for pext in ${!pexts}; do
        local ws_ext_src="${ws}/ext/${pext}/src"
        local ws_ext_builddir="${ws}/ext/${pext}/build"

        local pextsrc="TE_BS_EXT_${p}_${pext}_SOURCES"
        local pextprep="TE_BS_EXT_${p}_${pext}_PREPARE"
        local pextbuilddir="TE_BS_EXT_${p}_${pext}_BUILDDIR"
        local pextbuild="TE_BS_EXT_${p}_${pext}_BUILD"
        local pextinsth="TE_BS_EXT_${p}_${pext}_INSTALL_HEADERS"
        local pextinstl="TE_BS_EXT_${p}_${pext}_INSTALL_LIBS"
        local pextenv="TE_BS_EXT_${p}_${pext}_ENV_VARS"
        local enable_tce=""
        local extbuild

        te_eval_or_ssh "$p" "mkdir -p $ws_ext_src $ws_ext_builddir"
        rsync_to "$p" "${!pextsrc}/" "$ws_ext_src"

        local local_ext_builddir="ext/${pext}/build"
        if test -d "${local_ext_builddir}"; then
            rsync_to "$p" "${local_ext_builddir}/" "${ws_ext_builddir}"
        else
            mkdir -p "${local_ext_builddir}"
        fi

        # Extention build command is a script, make remote copy and use it
        extbuild="${!pextbuild}"
        build_ext_process_cmd "${p}" "${ws}" "${pext}" ${extbuild}

        te_check_tce "${p}" "${pext}" && enable_tce="--tce"
        ${SCRIPT_DIR}/te_build_ext --prefix="${ext_inst}" \
            --platform="$p" \
            --cppflags="${!pcppflags}" \
            --cflags="${!pcflags}" \
            --ldflags="${!pldflags}" \
            --srcdir="${ws_ext_src}" \
            --prepare="${!pextprep}" \
            --builddir="${ws_ext_builddir}" \
            --build="${extbuild}" \
            --expheaders="${!pextinsth}" \
            --explibs="${!pextinstl}" \
            --envvars="${!pextenv}" $enable_tce --build-meson || exit 1

        rsync_from "$p" "${ws_ext_builddir}/" "${local_ext_builddir}"
    done
}

build_agent_apps() {
    local p="$1"; shift
    local pcppflags="${p}_CPPFLAGS"
    local pcflags="${p}_CFLAGS"
    local pldflags="${p}_LDFLAGS"
    local papps="TE_BS_TA_APPS_$p"
    local app

    local app_inst="${ws}/destdir${TE_INSTALL}"
    for app in ${!papps}; do
        local ws_app_src="${ws}/apps/${app}/src"
        local ws_app_builddir="${ws}/apps/${app}/build"
        local ws_platform_bin="${app_inst}/${p}/bin"

        local ptatypes="TE_BS_TA_APPS_${p}_${app}_TATYPES"
        local pappsrc="TE_BS_TA_APPS_${p}_${app}_SOURCES"
        local pappprep="TE_BS_TA_APPS_${p}_${app}_PREPARE"
        local pappbuilddir="TE_BS_TA_APPS_${p}_${app}_BUILDDIR"
        local papplibs="TE_BS_TA_APPS_${p}_${app}_LIBS"
        local pappbuild="TE_BS_TA_APPS_${p}_${app}_BUILD"
        local pappinstbin="TE_BS_TA_APPS_${p}_${app}_INSTALL_BIN"
        local pappenv="TE_BS_TA_APPS_${p}_${app}_ENV_VARS"
        local enable_tce=""
        local appbuild

        local teincludes=
        local telib
        for telib in ${!papplibs}; do
            local plibsrc="TE_BS_LIB_${PLATFORM}_${telib}_SOURCES"
            local libsrc="${!plibsrc}"
            # We assume that if a library is built several times, it may have
            # a separate include subdirectory for each 'non-default' build
            if test -n "$libsrc" -a "$libsrc" != "${TE_BASE}/lib/${telib}"; then
                teincludes="${teincludes} ${telib}"
            fi
        done

        te_eval_or_ssh "$p" "mkdir -p $ws_app_src $ws_app_builddir"
        rsync_to "$p" "${!pappsrc}/" "$ws_app_src"

        local local_app_builddir="apps/${app}/build"
        if test -d "${local_app_builddir}"; then
            rsync_to "$p" "${local_app_builddir}/" "${ws_app_builddir}"
        else
            mkdir -p "${local_app_builddir}"
        fi

        # Extention build command is a script, make remote copy and use it
        appbuild="${!pappbuild}"
        if test -x "${appbuild}" ; then
            local remote_appbuild="${ws}/apps/${app}/build.sh"
            rsync_to "$p" "${appbuild}" "${remote_appbuild}"
            appbuild="${remote_appbuild}"
        fi

        te_check_tce "${p}" "${app}" && enable_tce="--tce"
        ${SCRIPT_DIR}/te_build_ext --prefix="${app_inst}" \
            --tatypes="${!ptatypes}" \
            --platform="$p" \
            --cppflags="${!pcppflags}" \
            --cflags="${!pcflags}" \
            --ldflags="${!pldflags}" \
            --srcdir="${ws_app_src}" \
            --prepare="${!pappprep}" \
            --builddir="${ws_app_builddir}" \
            --telibs="${!papplibs}" \
            --includes="${teincludes}" \
            --build="${appbuild}" \
            --expbin="${!pappinstbin}" \
            --envvars="${!pappenv}" \
            --bin="${ws_platform_bin}" $enable_tce --build-meson || exit 1

        rsync_from "$p" "${ws_app_builddir}/" "${local_app_builddir}"
    done
}

build_platform() {
    local p="$1" ; shift
    local meson_nv_args="$1" ; shift
    local meson_args="$1" ; shift
    local result=0
    local ws
    local remote_build=false
    local destdir

    echo "${meson_nv_args}" >meson.nv_args.new
    echo "${meson_args}" >meson.args.new

    if diff -q meson.nv_args meson.nv_args.new 2>/dev/null ; then
        rm meson.nv_args.new
    else
        rm -rf build meson.nv_args meson.args
    fi

    make_workspace "${p}"

    test "${ws}" = . || remote_build=true

    build_ext "${p}"

    # handle m32 option
    local build_m32=false
    local suffix
    for suffix in CPPFLAGS_VAR CFLAGS_VAR CPPFLAGS CFLAGS ; do
        local var=${p}_${suffix}
        local value=${!var}

        test "${value/-m32/}" = "${value}" && continue
        build_m32=true
        break
    done

    if test ! -d build ; then
        te_eval_or_ssh "${p}" \
            "cd \"${ws}\" || exit $? ;
             ${build_m32} && source ${ws}/src/engine/builder/te_meson_m32_exports ;
             meson ${meson_nv_args} ${meson_args} -Dworkspace=${ws} src build"
        echo "${meson_nv_args}" >meson.nv_args
        echo "${meson_args}" >meson.args
    elif ! diff -q meson.args meson.args.new 2>/dev/null ; then
        te_eval_or_ssh "${p}" \
            "cd \"${ws}\"/build || exit $? ;
             ${build_m32} && source ${ws}/src/engine/builder/te_meson_m32_exports ;
             meson configure ${meson_args}"
        echo "${meson_args}" >meson.args
    fi

    ${remote_build} && destdir="DESTDIR=\"${ws}/destdir\""

    if test "${p}" != "${TE_HOST}" -a -n \
        "${TE_RCF_CONSISTENCY_CHECKS_EXT_FILES}" ; then
        te_eval_or_ssh "${p}" \
            "${ws}/src/engine/builder/te_rcf_consistency_checks \
                --extfiles-del \"${ws}/build/\" ;
            echo \"${TE_RCF_CONSISTENCY_CHECKS_EXT_FILES}\" | sed \"s/ /\n/g\" |
                ${ws}/src/engine/builder/te_rcf_consistency_checks \
                    --extfiles-add \"${ws}/build/\""
    fi

    te_eval_or_ssh "${p}" \
        "which ninja >/dev/null 2>&1 && NINJA=ninja || NINJA=ninja-build ;
         TE_BASE=\"${ws}\"/src ${destdir} \$NINJA -C \"${ws}\"/build install" ||
        result=$?

    if test ${result} -eq 0 ; then
        build_agent_apps "${p}" || result=$?
    fi

    if ${remote_build} ; then
        rsync_from "${p}" "${ws}"/build . ||
            error "Sync build from remote failed"

        if test "${result}" -eq 0 ; then
            # Get installed platform data
            te_eval_or_ssh "${p}" \
                "test ! -d \"${ws}/destdir/${TE_INSTALL}/${p}\"" ||
            rsync_from "${p}" "${ws}"/destdir/"${TE_INSTALL}/${p}"/ \
                "${TE_INSTALL}/${p}" ||
                error "Sync install from remote failed"

            # Get installed agents
            te_eval_or_ssh "${p}" \
                "test ! -d \"${ws}/destdir/${te_agents}\"" ||
            rsync_from "${p}" "${ws}/destdir/${te_agents}"/ \
                "${te_agents}" ||
                error "Sync agents from remote failed"
        fi
    fi

    return ${result}
}

do_build() {
    local p
    local te_agents="${TE_INSTALL}"/agents

    mkdir -p "${te_agents}"

    . "${SCRIPT_DIR}"/te_functions

    for p in ${TE_BS_PLATFORMS} ; do
        local build=${p}_BUILD

        case "${!build}" in
            autotools)
                ${SCRIPT_DIR}/te_cross_build_autotools \
                    "${TE_INSTALL}" "${p}" "${BUILD_TA}" \
                    || error "Platform ${p} cross build using autotools failed"
                ;;
            ""|meson)
                local pmeson_nv_args="TE_BS_MESON_${p}_NV_ARGS"
                local pmeson_args="TE_BS_MESON_${p}_ARGS"

                mkdir -p platforms/"${p}" "${TE_INSTALL}/${p}"
                pushd platforms/"${p}"

                build_platform "${p}" \
                    "${!pmeson_nv_args}" "${!pmeson_args}" \
                    || error "Platform ${p} build failed"
                popd
                ;;
            *)
                error "Unknown build system '${!build}' for platform '$p'"
        esac

    done
}


build_all () {
    # List of all platforms
    local TE_BS_PLATFORMS=
    # TE_BS_TOOLS - what tools should be built by "make all" command.
    local TE_BS_TOOLS=
    # List of Test Agents
    local TE_BS_TA=
    # List of suites
    local TE_BS_SUITES=

    process_builder_conf "${with_config}" >builder.conf.processed

    # builder.conf.processed variables are required in both process_platforms() and do_build()
    while test 1 ; do
        . builder.conf.processed
        break
    done
    if test -n "$TE_BS_CONF_ERR" ; then
        echo $TE_BS_CONF_ERR >&2
        exit 1
    fi

    process_platforms

    do_build
}


cd "${TE_BUILD}"
build_all
