/**

<!-- @page te_engine_tester Test Engine: Tester -->

@defgroup te_engine_tester Test Engine: Tester
@ingroup te_engine
@{

@section te_engine_tester_introduction Introduction

@ref te_engine_tester is an application of @ref te_engine that controls running tests
according to configuration files.

@image html ten_tester_context.png "Tester context in TE"

<!--
@startditaa "ditaa ten_tester_context.png -S"
                                  +-----------------+
 +---------------+   Build tests  | cGRE            |
 |    Builder    |<---------------+      Tester     |
 +---------------+                |                 |
                                  +--+-----------+--+
                                     |           |
                    +-------------+  |           | cfg_create_backup
                 +--| Package.xml |--+           | cfg_verify_backup
                 |  |     {d}     |              | cfg_restore_backup
                 |  +-------------+              v
                 |                     +--------------------+
                 | Run                 |  Configurator API  |
                 v                     +---------+----------+
          +-------------+                        | IPC
          |    Tests    |                        v
          +-------------+              +--------------------+
                                       |                    |
                                       |    Configurator    |
                                       |        {s}         |
                                       +--------------------+
@endditaa
-->

In the context of Test Environment tests are organized in groups called Test
Packages. From the Tester point of view, the Test Package is a set of
executables (binary or script files can be run in @prog{shell} with set of
parameters passed via command line) accompanied by a file @path{package.xml}
describing how to run these scripts (execution order, test parameter values,
etc.). See @ref te_engine_tester_concepts for more details.

<!--
It may be specified that some tests of the package should be run one-by-one
(a test is started after finishing the previous test) or simultaneously
(separate threads (processes) should be started for all the tests).
Moreover, a test may be started under a debugger (@prog{gdb} or
@prog{valgrind}).
-->

It is possible to run the same test with different parameters. Parameters
for a test are specified in @path{package.xml} file. Tests may be iterated
with different combinations of parameter values. Such iterations are
performed by @ref te_engine_tester.

@ref te_engine_tester has complex parameters iteration and multiplication
logic, see @ref te_engine_tester_iteration.

Some tests may be marked as (associated with) checking the particular
requirement(s) of the product. @ref te_engine_tester allows to run tests
checking a particular set of requirements. See @ref te_engine_tester_req.

@ref te_engine_tester may be asked to build the tests from sources.
In this case tests should be built using GNU tools
(@prog{make}/@prog{autoconf}/@prog{automake}).
All TE libraries used by the tests should be specified in the
@ref te_engine_builder configuration file and be built/installed before
@ref te_engine_tester starting.

@ref te_engine_tester is responsible for the error recovery.
It utilizes a service provided by @ref te_engine_conf to make a backup
configuration for each package and test and to restore backups if necessary.

@ref te_engine_tester utilizes logging facilities provided by
@ref te_engine_logger to log test/package starting and finishing events.
This information is then used by Report Generator to split the log to
sections corresponding to particular tests/packages.

@section te_engine_tester_concepts Tester Concepts

@b Test is a complete sequence of actions required to achieve a specific
purpose (check that tested system provides a required functionality,
complies a standard, etc.) and producing a verdict pass/fail (possibly
accompanied by additional data).

@b Test @b Package is a group of tightly related tests or test packages,
which may share internal libraries and usually run together (one-by-one or
simultaneously). Test Package may consist of one test. It may have a
prologue (performing some initialization) and epilogue (releasing resources
and restoring TE configuration).

@b Test @b Script is a test which is a minimal structural unit of a test harness.

@b Test @b Suite is a Test Package which may be considered as standalone entity from
organisational point of view and build issues.

The hierarchy of these objects is:
- Test Suite consists of several Test Packages;
- Test Package includes several Tests;
- each Test has a corresponding Test Script.

@section te_engine_tester_req Test Requirements

Requirements are string labels which describe:
- product features;
- configuration features;
- scenario description.

Test can be associated with a set of requirements. I.e.
- @b LINUX -- the test should be executed only on Linux;
- @b LINUX-3.2 -- specific kernel version is required;
- @b PRODUCTION_BUILD -- test should be executed only on production build
(non-debug);
- @b SELECT -- test checks select() function behaviour;
- @b IGMP -- test checks IGMP-support of the product;
- @b LONG -- test scenario is really long;
- @b BROKEN -- test scenario is broken - avoid!.

Requirements can be normal and sticky. Sticky requirements are inherited by
all descendants (see the hierarchy description in @ref te_engine_tester_concepts).

Tester can be asked to run test satisfying certain requirements
via @prog_option{--tester-req} option which can be set to logical
expression where logical variables are test requirements and logical
operators are ! (not; should be escaped in bash), | (or) and & (and).
For example,

<pre class="fragment">
$ @prog{dispatcher.sh} @prog_option{--tester-req=\!BROKEN} : skip broken tests
$ @prog{dispatcher.sh} @prog_option{--tester-req="MSG_MORE|TCP_CORK"} : run all the tests involving MSG_MORE flag or TCP_CORK socket option
</pre>

If you specify multiple @prog_option{--tester-req} options, it works as
if their values are concatenated into a single logical expression by
means of & (and) logical operator and passed with a single
@prog_option{--tester-req} option.

<pre class="fragment">
$ @prog{dispatcher.sh} @prog_option{--tester-req=IGMP} @prog_option{--tester-req=\!LONG} : run fast IGMP tests
</pre>

@section te_engine_tester_conf Configuration File

@subsection te_engine_tester_conf_root Tester Root Configuration File

Tester configuration file is a root of testing scenario. This file contains
some auxiliary information like description and list of maintainers as well
as information about test suites.

XSD schema of @ref te_engine_tester configuration file can be found at
@path{${TE_BASE}/doc/xsd/tester_config.xsd} file.

@ref te_engine_tester configuration file can look like:
@code
<?xml version="1.0"?>
<tester_cfg version="1.0">
    <maintainer name="Oleg Kravtsov" mailto="Oleg.Kravtsov@oktetlabs.ru"/>

    <description>IPv6 Protocol Testing</description>

    <suite name="ipv6_host" src="${TE_TS_IPV6_HOST}"/>
    <suite name="ipv6_router" bin="${TE_TS_IPV6_ROUTER_BIN}"/>

    <run>
        <package name="ipv6_host"/>
    </run>
    <run>
        <package name="ipv6_router"/>
    </run>
</tester_cfg>
@endcode

Here is some description of used TAGs of configuration file:
- @attr_name{maintainer} - specify information about the maintainer
  of this configuration;
- @attr_name{description} - optional description of this configuration.
  Please note that this is rather configuration file description and it has
  nothing in common to the description of test suite(s) - you can refer to
  the same test suite from different @ref te_engine_tester
  configuration files;
- @attr_name{suite} - specify information about the location of top level
  test package (test suite). This directive tells @ref te_engine_tester
  where to find sources or binaries of a test suite. The only suites
  mentioned in @attr_name{suite} directives are built (if necessary) by
  the @ref te_engine_tester.<br/>
  @attr_name{suite} tag can keep the following attributes:
  - @attr_name{name} - specifies test suite name that is used as
    an identifier associated with this test suite;
  - @attr_name{src} - tells @ref te_engine_tester where to find sources of
    mentioned test suite;
  - @attr_name{bin} - tells @ref te_engine_tester where to find binarires
    of mentioned test suite (please note that @attr_name{src} and
    @attr_name{bin} attributes are mutualy exclusive, only one of them can
    present at the same time in @attr_name{suite} directive).<br/>
    It is possible not to have both @attr_name{src} and @attr_name{bin}
    attributes in @attr_name{suite} tag, which means you ask
    @ref te_engine_tester to build a test suite located under
    @path{${TE_BASE}/suites/[suite name]} directory.
  .
- @attr_name{run} - a block of tests, packages to run.
.

In the above example we tell @ref te_engine_tester :
- to build a test suite located under @path{${TE_TS_IPV6_HOST}} directory.
  @ref te_engine_tester will ask @ref te_engine_builder to build and install
  this test suite;
- to associate a directory @path{${TE_TS_IPV6_ROUTER_BIN}} with installed
  version of test suite reffered as @attr_val{ipv6_router};
- to run a test suite named @attr_val{ipv6_host} (it will be run from the
  place where it is installed by @ref te_engine_builder);
- to run a test suite named @attr_val{ipv6_router} (it will be run from
  @path{${TE_TS_IPV6_ROUTER_BIN}}directory that is previously associated
  with @attr_name{bin} attribute of @attr_name{suite} directive.
.

If you only need to build a set of test suites you can have
@ref te_engine_tester configuration file as following:
@code
<?xml version="1.0"?>
<tester_cfg version="1.0">
    <maintainer name="Oleg Kravtsov" mailto="Oleg.Kravtsov@oktetlabs.ru"/>
    <description>Build IPv6 related test suites</description>

    <suite name="ipv6_host" src="${TE_TS_IPV6_HOST}"/>
    <suite name="ipv6_router"/>
</tester_cfg>
@endcode

This configuration file asks @ref te_engine_tester to:
- build a test suite whose sources located at
  @path{${TE_TS_IPV6_HOST}} directory;
- build a test suite located at @path{${TE_BASE}/suites/ipv6_router}
  directory.
.


@subsection te_engine_tester_conf_pkg Tester Package Description File

Test package description files contain nodes of testing scenario tree.
Testing scenario tree is built of test script nodes to be executed with
particular set of parameters and particular execution order.

In order to group some test scripts together there are entities called
sessions and packages.

Test script is an external applications to be called by Tester. Test session
is a complex structure that can include different components to run.
Test sessions may have prologue that is run at the start of a session,
epilogue that is executed after the session and keep-alive validation to run
before and after each test script execution.

XSD schema of Package description files can be found at
@path{${TE_BASE}/doc/xsd/test_package.xsd}.

Here is an example of the simplest package description file:
@code
<?xml version="1.0"?>
<package version="1.0">
  <description>Device LED operation Test Suite</description>

    <author mailto="Oleg.Kravtsov@oktetlabs.ru"/>

    <session>
        <enum name="led_type">
            <value>Power</value>
            <value>USB</value>
            <value>Ethernet</value>
            <value>Error</value>
        </enum>

        <keepalive>
            <script name="notify_test_step"/>
        </keepalive>

        <prologue>
            <script name="led_prologue"/>
        </prologue>

        <epilogue>
            <script name="led_epilogue"/>
        </epilogue>

        <run>
            <script name="led_on_off"/>
            <arg name="led" type="led_type"/>
        </run>
            <script name="led_blink"/>
            <arg name="led" type="led_type"/>
        <run>
    </session>
</package>
@endcode

This package description file has:
- @attr_name{session} - mandatory part of package description file.
- @attr_name{prologue} - prologue entry. This entry defines execution
  subtree that is run by @ref te_engine_tester on package start-up.
  In our case we run only one script called @attr_val{led_prologue},
  which means that in test suite installation directory in corresponding
  place there should be a binary file or executable script
  with name @prog{led_prologue};
- @attr_name{epilogue} - epilogue entry. This entry defines execution
  subtree that is run by @ref te_engine_tester on package termination
  (after processing of all @attr_name{run} entries);
- @attr_name{keepalive} - this is an entry that @ref te_engine_tester
  runs after processing each @attr_name{run} entry;
- @attr_name{run} - an item to run. @attr_name{run} directive can contain
  one of the following:
  - @attr_name{script} - to ask @ref te_engine_tester run a single
    executable (a number of times with different parameters);
  - @attr_name{package} - to ask @ref te_engine_tester process another
    package, in which case @ref te_engine_tester will process a separate
    package description file recursively;
  - @attr_name{session} - to have nested @attr_name{session} syntax;
  .
  In our case we have plain @attr_name{script} directives that point
  to particular executables with names @attr_val{led_on_off} and
  @attr_val{led_blink};
- at the beginning of the @attr_name{session} we define enumeration
  with @attr_name{enum} TAG that we can later refer while specifying test
  parameters. In our sample we define enumeration type that can be reffered
  by name @attr_val{led_type};
- we refer to enumeration type inside @attr_name{run} TAG when specify
  parameters for scripts. In our case we define parameter @attr_val{led}
  that has values of type @attr_val{led_type}, which means the same
  executable will be run as many number of times as the number of possible
  values in type @attr_val{led_type}.
.

@subsection te_engine_tester_package_syntax Package File Syntax

XML schema for @ref te_engine_tester configuration file may be found in
@path{doc/xsd/tester_config.xsd} file.

@section te_engine_tester_iteration Iteration and usecases

@subsection te_engine_tester_iteration_parameters Parameters

Every test has a set of parameters and every parameter has certain
values. In the @path{package.xml} file it's represented as:

@code
<session>
  <run>
    <script name="test1"/>
    <arg name="arg1">
       <value>val1</value>
       <value>val2</value>
       <value>val3</value>
    </arg>
   </run>
</session>
@endcode

So test @b test1 has one argument @b arg1 which has three possible values
@b val1, @b val2 and @b val3.

When executed it will result in:
<pre class="fragment">
$ ./run.sh --tester-run=myts/mypackage/test1
....
Staring package mypackage
Starting test test1             PASSED     <- arg1=val1
Starting test test1             PASSED     <- arg1=val2
Starting test test1             PASSED     <- arg1=val3
Done package mypackage PASSED
</pre>

You can run test with specific argument value or values:

<pre class="fragment">
$ ./run.sh --tester-run=mysuite/mypkg/test1:arg1=val2
or
$ ./run.sh --tester-run=mysuite/mypkg/test1:arg1={val1, val3}
</pre>

@prog_option{\-\-tester-run-from} and @prog_option{\-\-tester-run-to} can be
used to run part of the sequence.

To run the second iteration one should call:

<pre class="fragment">
$ ./run.sh --tester-run=mysuite/mypkg/test1%2
...
Staring package mypackage
Starting test test1             PASSED     <- arg1=val2
Done package mypackage PASSED
</pre>

You can also specify a step with @prog_option(test1%1+2) sytax, this will
run only odd iterations.

Iteration is specified with an asterisk:

<pre class="fragment">
$ ./run.sh --tester-run=mysuite/mypkg/test1%2*3
...
Staring package mypackage
Starting test test1             PASSED     <- arg1=val2
Starting test test1             PASSED     <- arg1=val2
Starting test test1             PASSED     <- arg1=val2
Done package mypackage PASSED
</pre>

Negation with tilda:

<pre class="fragment">
$ ./run.sh --tester-run=myts/mypackage/test1:arg1~=val2
....
Staring package mypackage
Starting test test1             PASSED     <- arg1=val1
Starting test test1             PASSED     <- arg1=val3
Done package mypackage PASSED
</pre>

@subsection te_engine_tester_iteration_types Types

Arguments can have certain types. If explicit values are specified:

@code
<session>
  <run>
    <script name="test1"/>
    <arg name="arg1" type="boolean">
       <value>True</value>
       <value>False</value>
    </arg>
   </run>
</session>
@endcode

then they are checked agains given type. If no values then all values of the
type are iterated:

@code
<enum name="sock_type">
  <value>SOCK_STREAM</value>
  <value>SOCK_DGRAM</value>
</enum>
<session>
  <run>
    <script name="test1"/>
    <arg name="socket_type" type="sock_type"/>
   </run>
</session>
@endcode

@subsection te_engine_teste_iteration_multiplication Multiplication

Set of argument values are multiplied:

@code
<session>
  <run>
    <script name="test1"/>
    <arg name="arg1">
       <value>val1</value>
       <value>val2</value>
    </arg>
    <arg name="arg2">
       <value>val3</value>
       <value>val4</value>
    </arg>
   </run>
</session>
@endcode

results into

<pre class="fragment">
$ ./run.sh --tester-run=mysuite/mypkg/test1
...
Staring package mypackage
Starting test test1             PASSED     <- arg1=val1, arg2=val3
Starting test test1             PASSED     <- arg1=val1, arg2=val4
Starting test test1             PASSED     <- arg1=val2, arg2=val3
Starting test test1             PASSED     <- arg1=val2, arg2=val4
Done package mypackage PASSED
</pre>

If full multiplication should not be performed then @b list attribute should
be used:

@code
<session>
  <run>
    <script name="test1"/>
    <arg name="arg1" list="mylist">
       <value>val1</value>
       <value>val2</value>
    </arg>
    <arg name="arg2" list="mylist">
       <value>val3</value>
       <value>val4</value>
    </arg>
   </run>
</session>
@endcode

results into

<pre class="fragment">
$ ./run.sh --tester-run=mysuite/mypkg/test1
...
Staring package mypackage
Starting test test1             PASSED     <- arg1=val1, arg2=val3
Starting test test1             PASSED     <- arg1=val2, arg2=val4
Done package mypackage PASSED
</pre>

Important points:
- number of values for all arguments in the same list should be equal;
- multiplication and lists can be compbined;
- multiplication significantly increases number of test iterations, so one
should be sure that he wants to check all combinations.

@subsection te_engine_teste_iteration_variable Variables

You can specify variables in package description file and later refer to
values of these variables when specifying values for test arguments.

@code
<session>
  <var name="long_path" global="true">
    <value>/this/is/very/long/path/to/a/file/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</value>
  </var>
  <var name="up_case_name">
    <value>AAAAAA.TXT</value>
  </var>

  <run>
    <script name="readdir"/>
    <arg name="path">
       <value>/</value>
       <value>/dir</value>
       <value ref="long_path"/>
    </arg>
  </run>

  <run>
    <script name="file_open"/>
    <arg name="path">
       <value ref="up_case_name"/>
    </arg>
  </run>
</session>
@endcode

In this sample we create two variables @b long_path and @b up_case_name with particular values.
Later we can refer to these variables using @attr_name{ref} attribute - as one of values for @b path
parameter of @b readdir test or as the value for @b path parameter of @b file_open test.

@todo More details should be added.

@} <!-- END te_engine_tester -->
 */

