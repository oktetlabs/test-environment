/**
@defgroup te Test Environment
@{

@section te_introduction Introduction

OKTET Labs Test Environment (TE) is a software product that is
intended to ease creating automated test suites.  The history of TE
goes back to 2000 year when the first prototype of software was
created. At that time the product was used for testing SNMP MIBs and
CLI commands. Two years later (in 2002) software was extended to
support testing of IPv6 protocol.

Few years of intensive usage the software in testing projects showed
that a deep re-design was necessary to make the architecture flexible
and extandable for new and new upcoming features. In 2003 year it was
decided that the redesign should be fulfilled. Due to the careful and
well-thought design decisions made in 2003 year, the overall TE
architecture (main components and interconnections between them) are
still valid even though a lot of new features has been added since
then.

@section te_conventions Conventions

Throught the documentation the following conventions are used:
- directory paths or file names marked as: @path{/usr/bin/bash},
  @path{Makefile};
- program names (scripts or binary executables) marked as: @prog{gdb},
  @prog{dispatcher.sh};
- program options are maked as: @prog_option{--help}, @prog_option{-q};
- environment variables are marked as: @var{TE_BASE}, @var{${PATH}};
- different directives in configuration files are marked as:
  @func{TE_LIB_PARMS}, @func{include};
- configuration pathes as maked as: @conf_path{/agent/interface},
  @conf_path{/local:/net:A};
- names of different attributes (mainly names of XML element attributes)
  are marked as: @attr_name{type}, @attr_name{src};
- values of different attributes are marked as: @attr_val{unix},
  @attr_val{${TE_BASE}/suites/ipv6-demo};
- different kind of commands or modes are marked as: @cmd{Unregister}, 
  @cmd{live}.
.

@section te_abrev_term Abbreviations and Terminology

See @ref te_terminology for the abbreviations and terminology.

@section te_architecture Test Environment Architecture

From the high level point of view TE consists of two main parts:
- @ref te_engine;
- @ref te_agents.

The following picture shows high level decomposition of TE components:

@image html hl-decomposition.png "High Level Decomposition of Test Environment components"

There are several kinds of Test Agents (see the diagram below):

- Test Agent running on an auxiliary station and controlling this station:
Test Protocol is used over a network and all commands are applied to the
station on which Test Agent runs.
- Test Agent running on an auxiliary station and controlling the NUT: @ref
te_engine_rcf_test_proto is used over a network and all commands are applied
to the NUT (Test Agent interacts with the NUT via a NUT-specific interface).
- Test Agent running on a NUT and controlling the NUT: Test Protocol is used
over a network or over some other transport (for example, over a serial port
or Ethernet) and all commands are applied to the NUT.

Seletion of appropriate usage scenario depends on the object being
tested. If it's a network device the Test Agent can run either on the device
itself or (if black box testing is performed or device hardware is not
capable of running the agent) on an auxiliary station. If a network library
is tested then the agent should probably be running on the NUT itself (in
such case NUT is the host on which the service that uses the library is
running).

Apart from these three kinds of agents (or should they be called 'Test Agent
usage scenarios') there can exist arbitrary number of agents running on
other equipments which participates in the testing process. Examples
include:
- other hosts which are used for traffic generation;
- proxy agents which are used to control various sevices used for network
envrionment creation or DUT configuration via managemnt protocols;
- agents used for debug information collection, for instance serial logs.

The below diagram shows various scenarios and Test Agents locations.

@image html te_agent_types.png Stations and applications participating in the testing process

TE subsystems and @ref te_agents are distributed among several applications
running on different stations.  Apart from other things @ref te_engine
controls @ref te_agents by means of so-called @ref te_engine_rcf_test_proto
- a text-based protocol used in communication between @ref te_engine and
@ref te_agents.

According to initial design @ref te_engine runs on Linux platform and there
is no intend to port it to any other OS type, but @ref te_agents can be run
on different platforms providing particular set of mandatory features for
@ref te_engine. @ref te_agents are the subject to be ported to
hardware/software specific components of test infrastructure.

@section te_tools Test Environment Tools

Apart from main components, TE provides the following set of tools:
- <b>Report Generator</b> tool representing logs in different formats
  (<em>RGT</em> tool, see [TODO]);
- <b>Testing Coverage Estimation</b> tool that gives some report about
  the quality of test suite we run against the software under test;
- <b>Test Result comparator</b> tool that can be used to check the
  difference between different test runs (TRC tool);
- <b>Test Package Generator</b> tool.
.


@section te_services Test Environment Services

From end-users (test writers) point of view TE is a set of services that
allow creating complex and full-functional tests. All services exported by TE
accessible via a set of libraries. Here is the list of libraries available
that are useful while writing this or that test cases:

- @ref te_lib_rpc

- @link logger_api.h API Usage: Logger API @endlink
- @ref confapi
- @ref rcfapi
.

- @ref tapi_conf
.

@} <!-- END te -->
*/
