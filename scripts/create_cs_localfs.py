#!/usr/bin/env python3

# Create xml document contains Configurator subtree local file system which
# is used in TAPI storage. It scans particular directory file system and
# extract it structure as well as files' properties end put this information
# into xml document.
# Example to use: $0 <path> [<cs_subtree_prefix>]
# Parameters:
#  1st  path to the files, will be used as content directory environment;
#  2nd  subtree prefix (optional, by default it is "/local/fs").

# Note. pymediainfo package is required to extract metadata.
#       See https://pypi.python.org/pypi/pymediainfo

# @TODO
# 1. Escaping of illegal characters (when configurator will support escaping).

import os
import sys
import argparse
import xml.etree.ElementTree as et
from pymediainfo import MediaInfo


# Name of file where document will be saved
FILE_NAME = "cs.conf.local_fs"
# Default configurator subtree
DEFAULT_SUBTREE = "/local/fs"


# Parse for command-line options and arguments
parser = argparse.ArgumentParser()
parser.add_argument("path",
                    help = "path to the files, will be used as content"
                           " directory environment")
parser.add_argument("cfg_subtree",
                    nargs='?',
                    default = DEFAULT_SUBTREE,
                    help = "configurator subtree prefix (optional, by default"
                           " it is \"{0}\"".format(DEFAULT_SUBTREE))
args = parser.parse_args()


# Path to the files
root_path = os.path.normpath(args.path)
# Configurator subtree prefix
subtree_pfx = os.path.normpath(args.cfg_subtree)
# Make subtree instance prefix, i.e. transform local/fs to local:/fs:
subtree_inst_pfx = '/' + ':/'.join(filter(None, subtree_pfx.split('/')))+':'


# Create xml backbone
root = et.Element('history')

root.append(et.Comment("PLEASE DO NOT EDIT THIS FILE! IT WAS GENERATED BY "
                       "{0} SCRIPT.".format(os.path.basename(sys.argv[0]))))

root.append(et.Comment("Register of local fs objects"))
reg = et.SubElement(root, 'register')

root.append(et.Comment("Instances of local fs files and directories"))
add_inst = et.SubElement(root, 'add')

root.append(et.Comment("Directory where the files are placed on real"
                       " (physical) file system"))
add_dir = et.SubElement(root, 'add')


# Add an object to the xml document
def add_object_to_xml(parent, oid, obj_type = "string"):
    et.SubElement(parent, "object", {
        "oid":    oid,
        "access": "read_create",
        "type":   obj_type,
    })


# Add an instance to the xml document
def add_instance_to_xml(parent, oid, value = None):
    el = et.SubElement(parent, "instance", {"oid": oid})
    if value:
        el.set("value", value)


# Add to xml document a directory object
def add_dir_object(path):
    add_object_to_xml(reg, path)


# Add to xml document a file object
def add_file_object(path):
    add_object_to_xml(reg, path + "/file")
    add_object_to_xml(reg, path + "/file/property")
    add_object_to_xml(reg, path + "/file/metadata")


# Add to xml document a directory instance
def add_dir_instance(path):
    if path == ".":
        return subtree_inst_pfx
    dir_inst = "/directory:".join([subtree_inst_pfx] + path.split('/'))
    add_instance_to_xml(add_inst, dir_inst)
    return dir_inst


# Add to xml document a file metadata
def get_title(media_info, pathname):
    for track in media_info.tracks:
        if track.track_type == 'General':
            if track.title:
                return track.title
            elif track.track_name:
                return track.track_name
    # Title not found, return a basename of file without path and extension
    return os.path.splitext(os.path.basename(pathname))[0]


# Add to xml document a file instance
def add_file_instance(dir_inst, path, filename):
    pathname = os.path.join(path, filename)
    prop = dir_inst + "/file:" + filename + "/property:"
    meta = dir_inst + "/file:" + filename + "/metadata:"
    info = os.stat(pathname)
    add_instance_to_xml(add_inst, dir_inst + "/file:" + filename)
    add_instance_to_xml(add_inst, prop + "size", str(info.st_size))
    add_instance_to_xml(add_inst, prop + "date", str(int(info.st_ctime)))
    media_info = MediaInfo.parse(os.path.join(pathname))
    add_instance_to_xml(add_inst, meta + "title",
        get_title(media_info, pathname))


# Add to xml document the root object
add_object_to_xml(reg, subtree_pfx, "none")

# Add to xml document the root instance
add_instance_to_xml(add_inst, subtree_inst_pfx)

# Walk through directories tree, extract files' info, and add them to the
# xml document as instances
max_nesting_deep = 0
for dirpath, dirs, files in os.walk(root_path):
    relpath = os.path.relpath(dirpath, root_path)
    max_nesting_deep = max(max_nesting_deep, len(relpath.split('/')))
    dir_inst = add_dir_instance(relpath)
    for f in files:
        add_file_instance(dir_inst, dirpath, f)


# Add to xml document an objects
dir_object = subtree_pfx
add_file_object(dir_object)
for i in range(max_nesting_deep):
    dir_object += "/directory"
    add_dir_object(dir_object)
    add_file_object(dir_object)

# Add to xml document the real path to contents
add_instance_to_xml(add_dir, "/local:/env:STORAGE_CONTENT_DIR", root_path)



# PRINT TO FILE

# Make xml document human readable (pretty print)
# Source: https://norwied.wordpress.com/2013/08/27/307/
def indent(elem, level=0):
  i = "\n" + level*"  "
  if len(elem):
    if not elem.text or not elem.text.strip():
      elem.text = i + "  "
    if not elem.tail or not elem.tail.strip():
      elem.tail = i
    for elem in elem:
      indent(elem, level+1)
    if not elem.tail or not elem.tail.strip():
      elem.tail = i
  else:
    if level and (not elem.tail or not elem.tail.strip()):
      elem.tail = i

indent(root)

# debug print of xml document
#~ et.dump(root)

# Save to file
tree = et.ElementTree(root)
with open(FILE_NAME, 'wb') as f:
    tree.write(f, xml_declaration=True, encoding='utf-8')
