#!/usr/bin/env python3

# Create xml document contains Configurator subtree local file system which
# is used in TAPI storage. It scans particular directory file system and
# extract it structure as well as files' properties end put this information
# into xml document.
# Example to use: $0 <path> [<cs_subtree_prefix>]
# Parameters:
#  1st  path to the files, will be used as content directory environment;
#  2nd  subtree prefix (optional, by default it is "/local/fs").

# @TODO
# 1. Escaping of illegal characters (when configurator will support escaping).
# 2. Extract metadata of files.

import os
import sys
import xml.etree.ElementTree as et


# Name of file where document will be saved
FILE_NAME = "cs.conf.local_fs"
# Default configurator subtree
DEFAULT_SUBTREE = "/local/fs"


if (len(sys.argv) < 2 or len(sys.argv) > 3):
    print("""Example to use: {0} <path> [<cs_subtree_prefix>]
Parameters:
 1st - path to the files, will be used as content directory environment;
 2nd - subtree prefix (optional, by default it is "local/fs").
""".format(os.path.basename(sys.argv[0])))
    exit()

# 1st argument
root_path = os.path.normpath(sys.argv[1])
# 2nd argument
if len(sys.argv) < 3:
    subtree_pfx = os.path.normpath(DEFAULT_SUBTREE)
else:
    subtree_pfx = os.path.normpath(sys.argv[2])
# Make subtree instance prefix, i.e. transform local/fs to local:/fs:
subtree_inst_pfx = '/' + ':/'.join(filter(None, subtree_pfx.split('/')))+':'


# Create xml backbone
root = et.Element('history')

root.append(et.Comment("PLEASE DO NOT EDIT THIS FILE! IT WAS GENERATED BY "
                       "{0} SCRIPT.".format(os.path.basename(sys.argv[0]))))

root.append(et.Comment("Register of local fs objects"))
reg = et.SubElement(root, 'register')

root.append(et.Comment("Instances of local fs files and directories"))
add_inst = et.SubElement(root, 'add')

root.append(et.Comment("Directory where the files are placed on real "
                       "(physical) file system"))
add_dir = et.SubElement(root, 'add')


# Add an object to the xml document
def add_object_to_xml(parent, oid, obj_type = "string"):
    et.SubElement(parent, "object", {
        "oid":    oid,
        "access": "read_create",
        "type":   obj_type,
    })


# Add an instance to the xml document
def add_instance_to_xml(parent, oid, value = None):
    el = et.SubElement(parent, "instance", {"oid": oid})
    if value:
        el.set("value", value)


# Add to xml document a directory object
def add_dir_object(path):
    add_object_to_xml(reg, path)


# Add to xml document a file object
def add_file_object(path):
    add_object_to_xml(reg, path + "/file")
    add_object_to_xml(reg, path + "/file/property")
    add_object_to_xml(reg, path + "/file/metadata")


# Add to xml document a directory instance
def add_dir_instance(path):
    if path == ".":
        return subtree_inst_pfx
    dir_inst = "/directory:".join([subtree_inst_pfx] + path.split('/'))
    add_instance_to_xml(add_inst, dir_inst)
    return dir_inst

# Add to xml document a file instance
def add_file_instance(dir_inst, path, filename):
    pathname = os.path.join(path, filename)
    prop = dir_inst + "/file:" + filename + "/property:"
    info = os.stat(pathname)
    add_instance_to_xml(add_inst, dir_inst + "/file:" + filename)
    add_instance_to_xml(add_inst, prop + "size", str(info.st_size))
    add_instance_to_xml(add_inst, prop + "date", str(int(info.st_ctime)))


# Add to xml document the root object
add_object_to_xml(reg, subtree_pfx, "none")

# Add to xml document the root instance
add_instance_to_xml(add_inst, subtree_inst_pfx)

# Walk through directories tree, extract files' info, and add them to the
# xml document as instances
max_nesting_deep = 0
for dirpath, dirs, files in os.walk(root_path):
    relpath = os.path.relpath(dirpath, root_path)
    max_nesting_deep = max(max_nesting_deep, len(relpath.split('/')))
    dir_inst = add_dir_instance(relpath)
    for f in files:
        add_file_instance(dir_inst, dirpath, f)


# Add to xml document an objects
dir_object = subtree_pfx
add_file_object(dir_object)
for i in range(max_nesting_deep):
    dir_object += "/directory"
    add_dir_object(dir_object)
    add_file_object(dir_object)

# Add to xml document the real path to contents
add_instance_to_xml(add_dir, "/local:/env:STORAGE_CONTENT_DIR", root_path)



# PRINT TO FILE

# Make xml document human readable (pretty print)
# Source: https://norwied.wordpress.com/2013/08/27/307/
def indent(elem, level=0):
  i = "\n" + level*"  "
  if len(elem):
    if not elem.text or not elem.text.strip():
      elem.text = i + "  "
    if not elem.tail or not elem.tail.strip():
      elem.tail = i
    for elem in elem:
      indent(elem, level+1)
    if not elem.tail or not elem.tail.strip():
      elem.tail = i
  else:
    if level and (not elem.tail or not elem.tail.strip()):
      elem.tail = i

indent(root)

# debug print of xml document
#~ et.dump(root)

# Save to file
tree = et.ElementTree(root)
with open(FILE_NAME, 'wb') as f:
    tree.write(f, xml_declaration=True, encoding='utf-8')
