#!/usr/bin/env gawk -f
# SPDX-License-Identifier: Apache-2.0
# Copyright (C) 2016-2022 OKTET Labs Ltd. All rights reserved.

# This script extracts comments from a `package.xml' file and converts them
# to the form suitable for Doxygen processing
#
# Features:
# - Extracts Doxygen comments and directives (@page, @defgroup, etc.)
# - Handles @autogroup and @autogroupprefix for automatic group generation
# - Processes <enum> and <var> elements
# - Extracts <script> objectives (single and multi-line)
# - Handles nested <session> elements within <run> elements
# - Extracts requirements from <req> elements and reqs attributes
# - Supports <run-template> elements
# - Documents list attribute groupings
# - Ignores <prologue> elements as per design

BEGIN {
    script_objective = "";
    script_objective_body = "";
    script_reqs = "";
    session_depth = 0;
}

# Extract and format requirement IDs from accumulated reqs
function format_requirements()
{
    if (script_reqs != "") {
        gsub(/^[ \t]+|[ \t]+$/, "", script_reqs);
        gsub(/[ \t]+/, " ", script_reqs);
        return "<b>Requirement ids:</b> " script_reqs "\n\n";
    }
    return "";
}

function objective_handle(str, do_next)
{
    if (sub(/@objective/, str)) {
        in_objective = 1;
        objective = ""
    }

    if (in_objective) {
        # if we were in objective - it's time to leave
        if (!match(str, /@objective/) && (match(str, /@/) || match(str, /<run/))) {
            gsub(/ [ ]+/, " ", objective);
            # we need another newline
            printf("@objective %s\n\n", objective);
            in_objective = 0;
            objective = "";
        }
    }

    if (in_objective) {
        objective_line = str;
        gsub("<!---", "", objective_line);
        gsub("-->", "", objective_line);
        gsub("@objective ", "", objective_line);
        gsub(" *[\n]+$", "", objective_line);
        objective = objective " " objective_line;

        if (do_next)
            next
    }
}

function process(str)
{
    # Check for @autogroup first before any substitutions
    is_autogroup = match(str, /@autogroup/);

    # Check for @autogroupall first before any substitutions
    is_autogroupall = match(str, /@autogroupall/);

    if (sub(/-->.*/, " ", str)) {
        objective_handle(str, 1);
        in_dox_comment = 0;
    }
    else
        in_dox_comment = 1;

    if ((sub(/@page/, str) || sub(/@defgroup/, str) \
        || sub(/@ingroup/, str) || sub(/@addtogroup/, str) \
        || sub(/@autogroup/, str)) && !is_autogroupall) {
        if (in_page) {
            if (run_found && auto_group) {
                printf("\n@run_name %s\n", run_name);
            }
            if (in_run) {
                print "@endcode"
            }
            print "*/";
        }

        print "/**";
        in_page = 1;

        run_found = 0;
    }

    if (sub(/@endpage/, str) || sub(/@}/, str)) {
        if (in_page) {
            sub(/[ \t]+/, "", str);
            print str
            print "*/";
        }
        in_page = 0;
        in_group = 0;
        run_found = 0;
    }

    if (is_autogroupall) {
        sub("[ \t]+", "", str)
        sub("@autogroupall", "", str)
        default_group = str;
        has_default_group = 1
        # we should start the comment!
        print "/**"
        next;
    }
    else if (sub(/@autogroupprefix/, str)) {
        gsub("[ \t]+", "", str)
        gsub("@autogroupprefix", "", str)
        default_group_prefix = str;
        next;
    }
    else if (is_autogroup) {
        auto_group = 1;
        in_page = 1;
        run_found = 0;
        in_run = 0;
        script_objective = "";
        script_objective_body = "";
        next;
    }

    if (in_dox_comment) {
        objective_handle(str, 1)
    }

    if (in_page) {
        print str;
    }

    return;
}

in_dox_comment && /^[[:space:]]*\*/ { sub(/^[[:space:]]*\*/, ""); }

/<!---/ {
    line = $0;
    gsub(".*<!--- ", "", $line);
    process($line);

    next;
}

/@{/ {
    in_group = 1;
    sub(/[ \t]+/, "");
    print $0
    next
}

/@}/ {
    in_group = 0;
    sub(/[ \t]+/, "");
    print $0
    next
}

in_dox_comment {
    objective_handle($0, 1)
}

in_dox_comment && /@ingroup/ {
    sub(/[ \t]+/, "");
    print;
    next
}

in_dox_comment && /-->/ {
    sub(/.*-->.*/, "\n");
    if ($0)
        print;
    in_dox_comment = 0;
    next;
}

!in_run && /<enum / {
  if (has_default_group)
      printf("@ingroup %s\n", default_group);
  else if (! in_page)
      next;

  in_enum = 1;
  if (match($0, /description=/)) {
      printf("@defgroup %s %s\n@{\n\n%s\n",
             gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
             gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0),
             gensub(/.* description="(.*)".*/, "\\1", 1, $0))
  }
  else {
      printf("@defgroup %s %s\n@{\n",
             gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
             gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0))
  }
  next;
}

in_enum && /<value/ {
  sub(/<\/value>/, ",");
}

in_enum && /req=/ {
  sub(/.*req="/, "-# (req=");
  sub(/">/, ") ");
  print $0;
  next;
}

in_enum && /<value[ ]+ref="/ {
  sub(/.*<value[ ]+ref="/, "-# ");
  sub(/".*\/>/, "");
  print $0;
  next;
}

in_enum && /<value/ {
  sub(/.*>/, "-# ");
  print $0;
  next;
}

in_enum && /<\/enum>/ {
  sub(/ *<\/enum>/, "@}");

  in_enum = 0;
  print $0;
  next;
}

/<var / {
    in_var = 1;
    if (!has_default_group) {
        print "/**";
    }
    if (has_default_group)
        printf("@ingroup %s\n", default_group);

    if (match($0, /description=/)) {
        printf("@defgroup %s %s\n@{\n\n%s\n",
               gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
               gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0),
               gensub(/.* description="(.*)".*/, "\\1", 1, $0))
    }
    else {
        printf("@defgroup %s %s\n@{\n",
               gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
               gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0))
    }
    next;
}

in_var && /<value/ {
    rc = sub(/<\/value>/, "");
    sub(/<value.*>/, "");
    print "@code"
    print $0
    if (rc)
        print "@endcode"
    next;
}

in_var && /<\/value>/ {
    sub(/<\/value>/, "\n@endcode");
    print $0;
    next;
}

/<\/var>/ {
    sub(/ *<\/var>/, "@}");

    in_var = 0;
    print $0;
    if (!has_default_group)
        print "*/";
    next;
}

in_var {
    print $0
    next
}

# Ignore prologue elements as per design
/<prologue>/ {
    in_prologue = 1;
    next;
}

in_prologue && /<\/prologue>/ {
    in_prologue = 0;
    next;
}

in_prologue {
    next;
}

# Handle run-template elements - document them like var/enum
/<run-template / {
    if (!has_default_group) {
        print "/**";
    }
    if (has_default_group)
        printf("@ingroup %s\n", default_group);

    if (match($0, /description=/)) {
        printf("@defgroup %s %s\n@{\n\n%s\n",
               gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
               gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0),
               gensub(/.* description="(.*)".*/, "\\1", 1, $0))
    }
    else {
        printf("@defgroup run-template-%s %s\n@{\n",
               gensub(/\./, "-", "g", gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0)),
               gensub(/.* name="([a-zA-Z0-9._]+)".*/, "\\1", 1, $0))
    }
    print "@par Template Definition";
    print "@code";
    in_run_template = 1;
    next;
}

/<\/run-template>/ {
    if (in_run_template) {
        print "@endcode"
        print "@}";
        if (!has_default_group)
            print "*/";
        in_run_template = 0;
    }
    next;
}

in_run_template {
    print $0;
    next;
}

in_page && /<run>/ {
    run_code_line = $0
    in_run = 1;
    next;
}

function group_start(str)
{
    if (auto_group) {
        group_description = (script_objective != "") ? script_objective : script_name;

        # Create a unique group identifier by incorporating objective text
        if (script_objective != "") {
            group_suffix = script_objective;
            # Sanitize the objective for use in group identifier
            gsub(/[^a-zA-Z0-9]/, "-", group_suffix);
            gsub(/-+/, "-", group_suffix);
            gsub(/^-|-$/, "", group_suffix);
            group_suffix = tolower(group_suffix);
            group_id = script_name "-" group_suffix;
        } else {
            group_id = script_name;
        }

        if (run_found) {
            printf("@defgroup %s%s-run %s\n",
                   default_group_prefix, group_id, group_description)
            printf("@ingroup %s%s %s%s\n",
                   default_group_prefix, run_name,
                   default_group_prefix, script_name);
        }
        else {
            printf("@defgroup %s%s-run %s\n",
                   default_group_prefix, group_id, group_description)
            printf("@ingroup %s%s\n",
                   default_group_prefix, script_name);
        }
        printf("@{\n");

        # Include objective body if available
        if (script_objective_body != "") {
            print script_objective_body;
            print "";
        }

        # Include requirements if available
        req_output = format_requirements();
        if (req_output != "") {
            print req_output;
        }

        print "@code"
    }
}

/<run name/ {
    if (in_page) {
        run_code_line = $0
        run_name = $0
        gsub(" .*<run name=\"", "", run_name);
        gsub("\".*>", "", run_name);
        run_found = 1;
        in_run = 1

        next
    }
}

/<script name/ {
    if (in_page) {
        code_line = $0
        script_name = $0
        gsub(" .*<script name=\"", "", script_name);
        gsub("\".*>", "", script_name);

        script_objective = "";
        script_objective_body = "";
        script_reqs = "";
        script_lines = run_code_line "\n" code_line;
        in_run = 1

        # Check if this is a self-closing script tag
        if (match($0, /\/>/)) {
            # Self-closing tag - do the same as </script>
            group_start();
            print script_lines;
            in_script = 0;
        } else {
            # Regular opening tag - wait for </script>
            in_script = 1;
        }
        next
    }
}

in_script && /<req id=/ {
    req_id = $0;
    gsub(/.*<req id="/, "", req_id);
    gsub(/".*/, "", req_id);
    if (script_reqs != "") {
        script_reqs = script_reqs ", " req_id;
    } else {
        script_reqs = req_id;
    }
    script_lines = script_lines "\n" $0;
    next;
}

in_script && /<objective>/ {
    line = $0;
    gsub(".*<objective>", "", line);
    if (match(line, /<\/objective>/)) {
        # Single line objective - process completely here
        gsub("</objective>.*", "", line);
        script_objective = line;
        gsub(/^[ \t\n]+|[ \t\n]+$/, "", script_objective);
        script_objective_body = "";
        # Don't set in_objective_tag for single-line objectives
    } else {
        # Multi-line objective starts
        in_objective_tag = 1;
        objective_content = line;
    }
    script_lines = script_lines "\n" $0;
    next;
}

in_script && in_objective_tag && /<\/objective>/ {
    line = $0;
    gsub("</objective>.*", "", line);
    objective_content = objective_content "\n" line;

    # Process the complete objective content
    split(objective_content, obj_lines, "\n");
    script_objective = "";
    script_objective_body = "";

    # Find first non-empty line as title
    prev_was_list = 0;
    for (i = 1; i <= length(obj_lines); i++) {
        gsub(/^[ \t]+|[ \t]+$/, "", obj_lines[i]);
        if (obj_lines[i] != "" && script_objective == "") {
            script_objective = obj_lines[i];
        } else if (obj_lines[i] != "" && script_objective != "") {
            if (script_objective_body != "") {
                script_objective_body = script_objective_body "\n";
            }

            # Check if current line is a list item
            is_list = match(obj_lines[i], /^[ \t]*-[ \t]/);

            # If previous was list and current is not, add empty line
            if (prev_was_list && !is_list) {
                script_objective_body = script_objective_body "\n";
            }

            # Convert markdown lists to Doxygen format
            if (is_list) {
                gsub(/^[ \t]*-[ \t]*/, "- ", obj_lines[i]);
                prev_was_list = 1;
            } else {
                prev_was_list = 0;
            }

            script_objective_body = script_objective_body obj_lines[i];
        }
    }

    in_objective_tag = 0;
    script_lines = script_lines "\n" $0;
    next;
}

in_script && in_objective_tag {
    objective_content = objective_content "\n" $0;
    script_lines = script_lines "\n" $0;
    next;
}

in_script && /<\/script>/ {
    script_lines = script_lines "\n" $0;
    group_start();
    print script_lines;
    in_script = 0;
    next;
}

in_script {
    script_lines = script_lines "\n" $0;
    next;
}

/<session/ {
    session_depth++;
    if (in_page && auto_group) {
        script_objective = "";
        script_objective_body = "";
        script_reqs = "";
        # Only start group for first session or nested sessions
        if (session_depth == 1 || in_run) {
            group_start()
            print run_code_line
            print $0
        } else {
            print $0
        }
        next
    }
}

/<\/session>/ {
    session_depth--;
    if (in_run_template) {
        print $0;
        next;
    }
    if (in_prologue) {
        next;
    }
}

auto_group && in_run && /<\/run>/ {
    print $0
    print "@endcode"
    print "@}"
    print "*/"
    run_found = 0
    in_run = 0;
    in_page = 0;
    auto_group = 0;
    script_objective = "";
    script_objective_body = "";
    script_reqs = "";
    next
}

in_run {
    print $0
    next
}

in_group {
    print $0
    next
}

in_dox_comment {
    print $0
    next
}

END {
    if (in_page && !auto_group) {
        if (run_found) {
            printf("\n@run_name %s\n", run_name);
        }
        print "*/";
    }
    if (has_default_group) {
        print "*/";
    }
}
