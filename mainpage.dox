/** @mainpage

@defgroup te Test Environment
@{

@section te_introduction Introduction

OKTET Labs Test Environment (TE) is a software product that is intended to
ease creating automated test suites.
The history of TE goes back to 2000 year when the first prototype of software
was created. At that time the product was used for testing SNMP MIBs and
CLI commands. Two years later (in 2002) software was extended to support
testing of IPv6 protocol.

Few years of intensive usage the software in testing projects showed that
a deep re-design was necessary to make the architecture flexible and
extandable for new and new upcoming features. In 2003 year it was decided
that the redesign should be fulfilled. Due to the careful and well-thought
design decisions made in 2003 year, the overall TE architecture
(main components and interconnections between them) are still valid even
though a lot of new features has been added since then.

@section te_conventions Conventions

Throught the documentation the following conventions are used:
- directory pathes or file names marked as: @path{/usr/bin/bash},
  @path{Makefile};
- program names (scripts or binary executables) marked as: @prog{gdb},
  @prog{dispatcher.sh};
- program options are maked as: @prog_option{--help}, @prog_option{-q};
- environment variables are marked as: @var{TE_BASE}, @var{${PATH}};
- different directives in configuration files are marked as:
  @func{TE_LIB_PARMS}, @func{include};
- configuration pathes as maked as: @conf_path{/agent/interface},
  @conf_path{/local:/net:A};
- names of different attributes (mainly names of XML element attributes)
  are marked as: @attr_name{type}, @attr_name{src};
- values of different attributes are marked as: @attr_val{unix},
  @attr_val{${TE_BASE}/suites/ipv6-demo};
- different kind of commands or modes are marked as: @cmd{Unregister}, 
  @cmd{live}.
.

@section te_abbreviations Abbreviations

@tdt_start
@tdt_term DUT
@tdt_def  Device Under Test
@tdt_term RCF
@tdt_def  Remote Control Facility
@tdt_term TA
@tdt_def  Test Agent
@tdt_term TE
@tdt_def  Test Environment
@tdt_term TEN
@tdt_def  Test Engine
@tdt_end

@section terminology Terminology

@tdt_start
@tdt_term Communication Service Access Point
@tdt_def An object, which could be created on a Test Agent to send/receive
some data (packets, frames, cells, CLI commands, etc.) A set of primitives
to create and destroy CSAP, receive and send data is associated with each
type of CSAP.
@tdt_term Device Under Test (DUT)
@tdt_def Station where a tested hardware/software is located.
@tdt_term RCF Application Domain
@tdt_def A semantically independent set of services provided by RCF
(for example, TA configuration service).
A set of API functions, protocol commands and routines of TA libraries for
command handling, corresponds to a particular application domain.
Some application domains may be unsupported by some Test Agents.
@tdt_term Test
@tdt_def A complete sequence of actions required to achieve a specific purpose
(e.g., a check that tested system provides a required functionality, complies
to a standard, etc.) and producing a verdict pass/fail (possibly accompanied
by additional data).
@tdt_term Test Package
@tdt_def Group of tightly related tests or test packages, which may share
internal libraries and usually run together (one-by-one or simultaneously).
Test Package may consist of one test. It may have a prologue
(performing some initialization) and epilogue (releasing resources and
restoring TE configuration).
@tdt_termTest Agent
@tdt_defAn application running on the NUT or other station and performing
some actions (configuring NUT or itself, interacting with the tested system,
sending/receiving packets, etc.) according to instructions provided by
the Test Engine. All interactions with the tested system should be performed
via Test Agent only.
@tdt_term Test Engine
@tdt_def Set of applications performing testing of tested subsystem according
to Test Package(s) and configuration specified by a user.
It is responsible for:
- preparing executables for Test Packages, Test Agents and TE Subsystems as
  well as bootable NUT images;
- starting Test Agents and configuring the environment and NUT via
  Test Protocol as well as providing configuration information to tests;
- executing tests in mode and order specified by a user;
- interacting with Test Agents on behalf of tests;
- logging and generation of reports.
.
@tdt_term Test Protocol
@tdt_def Protocol used for Test Engine and Test Agent interaction.
@tdt_term Test Environment (TE)
@tdt_def Software product, which includes:
- software applications (Test Agent, Test Engine, tools, etc.) allowing to
  perform the sequence of actions specified by the test scenario and obtain
  results in convenient form;
- set of libraries supporting specific protocols, platforms and features;
- set of documents describing test creation framework and software tools
  simplifying this task;
- set of documents describing TE enhancement framework
  (creation of new libraries, support of new platforms, etc.) and
  software tools simplifying this task;
- user guides describing TE usage (how to run tests, possible log formats,
  libraries API, etc.).
.
Note, that tests are not considered as part of the TE.
@tdt_term Test Environment Subsystem
@tdt_def A mandatory and logically separate module
(which may include software, data, documents) of the Test Environment
responsible for one of main services provided by TE.
The TE Subsystem can provide service to:
- TE user (for example, TA Creation Framework);
- tests or
- other TE subsystems.
.
TE Subsystem may run in one or several threads (processes),
or on one or several stations (including NUT).
@tdt_end


@section te_deps Test Environment Dependencies

Test Environment depends on a set of 3-rd party libraries and packages.

For building TE components from sources you need:
- @prog{autoconf} version 2.61 or higher;
- @prog{automake} 1.9.6 (note: 1.10.* does not work).
.

For @ref te_engine build and run (in square brackets - debian package names):
- @lib_name{libxml2-devel} at least 2.6.x (2.6.10)
  [@lib_name{libxml2} @lib_name{libxml2-dev}];
- @lib_name{glib2-devel} (@lib_name{glib-2.0} package we use 2.4.8)
  [@lib_name{libglib2-dev}];
- @lib_name{popt-devel} (@lib_name{libpopt-dev} on Debian)
  [@lib_name{libpopt-dev}];
- @lib_name{libreadline} (for @ref te_engine_tester interactive)
  [@lib_name{libreadline-common}, @lib_name{libreadline-dev},
  @lib_name{libreadline-5}];
- @prog{tcl} (and @lib_name{tcl-devel}, if applicable, e.g. on Fedora Core 2)
  [@lib_name{tcl}, @lib_name{tcl-dev}];
- @lib_name{libxslt} (we use 1.1.6)
  [@lib_name{libxslt1-dev}, @lib_name{libxslt-1.1}];
- @lib_name{libexpat} [@lib_name{libexpat1}, @lib_name{libexpat1-dev}];
- @lib_name{flex} >= 2.5.31-31 from sourceforge; @lib_name{flex} 2.5.4a
  from gnu.org will not work [@lib_name{flex}];
- @prog{gawk} (@prog{mawk} will not work) [@lib_name{gawk}];
- any @lib_name{curses} library (@lib_name{ncurses} will work) with
  development files [@lib_name{ncurses}, @lib_name{ncurses-dev}];
- @lib_name{perl-Time-HiRes} package on Redhat/Fedora is very usefull
  (it allows to avoid mixture in log because of unprecise timestamps in
  messages logged by @ref te_engine_dispatcher (via logging script));
- @lib_name{libgss0} (>=0.0.18) [@lib_name{libgss0}];
- Wireless tools - development files [@lib_name{libiw-dev}];
- PPPoE [@lib_name{pppoe}] [@lib_name{pppoeconf}];
- @lib_name{curl} libraries [not from debian, should be taken from storage];
- @lib_name{libusb}, @lib_name{libusb-dev};
- @lib_name{libpam0g-dev};
- @lib_name{libperl-dev};
- @lib_name{bison}.
.

@ref te_agents_unix :

- @lib_name{expect} and @lib_name{expect-dev} (for TAD CLI only)
  [@lib_name{expect}, @lib_name{expect-dev}];
- @lib_name{flex} >= 2.5.31 from sourceforge;
  @lib_name{flex} 2.5.4a from gnu.org does not work;
- @lib_name{libexpat};
- @lib_name{libpcap0.8-dev} (for TAD PCAP only) [@lib_name{libpcap0.8-dev}];
- @lib_name{libpam} (0.76-22) (not required but suggested)
  [@lib_name{libpam}];
- @lib_name{libnl-devel}.
.

@ref te_agents_win :

- @lib_name{cygwin}, cross-toolchain;
- @lib_name{libpcap} (crosscompiled for @lib_name{cygwin}).
  Should be put into standard @path{include/lib} paths of
  @lib_name{cygwin} cross-compiler - required for TAD library.
  @lib_name{Winpcap} runtime has to be installed on Windows host.

Of course, @prog{gcc}, @prog{make}, @prog{sed} and other standard development
tools are required to build sources.


@section te_architecture Test Environment Architecture

The following picture shows high level decomposition of TE components:

@image html hl-decomposition.png "High Level Decomposition of Test Environment components" 

From the high level point of view TE consists of two main parts:
- @ref te_engine;
- @ref te_agents.

TE subsystems and @ref te_agents are distributed among several applications
running on different stations.
Apart from other things @ref te_engine controls @ref te_agents by means of
so-called Test Protocol - a text-based protocol used in communication
between @ref te_engine and @ref te_agents.

According to initial design @ref te_engine runs on Linux platform and there is
no intend to port it to any other OS type, but @ref te_agents can be run on
different platforms providing particular set of mandatory features for
@ref te_engine. @ref te_agents are the subject to be ported to hardware/software
specific components of test infrastructure.


@section te_run_time Test Environment operation

The following sequence of events happen each time when you launch
Test Environment:

-# @ref te_engine_dispatcher script starts with some command line options
   (for more information on @ref te_engine_dispatcher options read
    @ref te_engine_dispatcher_options);
-# @ref te_engine_dispatcher runs @prog{te_log_init} script to initialize
   script based logging facility. All further actions can be logged via
   script based interface (@prog{te_log_message} script). Please note that
   @ref te_engine_logger application hasn't started yet;
-# @ref te_engine_dispatcher starts @ref te_engine_builder to prepare
   libraries and executables for all TE Subsystems
   (except @ref te_engine_dispatcher), Test Packages, @ref te_agents and
   bootable NUT image(s).
   @ret te_engine_builder is passed a configuration file that describes
   a set of executables to be built with a set of options for building
   process.<br/>
   @ref te_engine_builder configuration file name specified via
   @prog_option{--conf-builder} option of @ref te_engine_dispatcher.<br/>
   (For information about @ref te_engine_builder configuration file
   read @ref te_engine_builder_conf_file).<br/>
   Please note that traces of building process are output into the console
   (they are not accumulated in log file);
-# As soon as @ref te_engine_builder successfully built and installed all
   required components, @ref te_engine_dispatcher starts launching
   @ref te_engine componentns. First component to start is
   @ref te_engine_logger. @ref te_engine_logger is passed a configuration
   file whose name can be specified via @prog_option{--conf-logger}
   @ref te_engine_dispatcher command line option (for information about
   the format of @ref te_engine_logger configuration file refer to
   @ref te_engine_logger_conf_file).<br/>
   @ref te_engine_logger starts listening for incoming log requests that
   can come from tests and other TEN components;
-# @ref te_engine_dispatcher starts @ref te_engine_rcf. @ref te_engine_rcf
   is passed a configuration file that describes @ref te_agents to be started
   (for information about the format of @ref te_engine_rcf configuration file
   refer to @ref te_engine_rcf_conf_file).<br/>
   As a part of initialization @ref te_engine_rcf establishes communication
   with @ref te_agents using Test Protocol;
-# As soon as @ref te_engine_rcf has initialized, @ref te_engine_logger
   starts a thread that is responsible for polling @ref te_agents Test Agents
   in order to gather log messages accumulated on Test Agent side. Polling
   interval is configured via @ref te_engine_logger configuration file;
-# @ref te_engine_dispatcher starts @ref te_engine_conf. @ref te_engine_conf
   is passed a configuration file that describes configuration objects to
   register as well as object instances to add (for information about
   the format of @ref te_engine_conf configuration file refer to 
   @ref te_engine_conf_file). On start-up @ref te_engine_conf retrives
   configuration information from @ref te_agents and initializes local trees
   of objects and instances;
-# @ref te_engine_dispatcher starts @ref te_engine_tester.
   @ref te_engine_tester processes configuration file and if necessary asks
   @ref te_engine_builder to build test suites (test executables).
   Then @ref te_engine_tester processes test package description files
   and runs tests in corresponding order and with specified set of parameter
   values. (For information about @ref te_engine_tester configuration file
   format refer to @ref te_engine_tester_conf section).<br/>
   Before running tests, @ref te_engine_tester asks @ref te_engine_conf to
   make a backup of configuration tree. When all tests are finished
   @ref te_engine_tester restores the initial configuration from initial
   backup. To prevent tests from interfering, a backup is created and
   optionally restored before each test as well.
-# When @ref te_engine_tester returns (all tests finished),
   @ref te_engine_dispatcher stops @ref te_engine_conf;
-# Flushing of the log from all Test Agents is performed;
-# @ref te_engine_dispatcher stops @ref te_engine_rcf.
   During its shutdown, @ref te_engine_rcf performs a shutdown of
   all @ref te_agents;
-# @ref te_engine_dispatcher stops @ref te_engine_logger.
   @ref te_engine_dispatcher calls Report Generator tool to convert the log
   from a raw format to the text and/or HTML format;
-# @ref te_engine_dispatcher script finishes its work.
.


@section te_tools Test Environment Tools

Apart from main components, TE provides the following set of tools:
- <b>Report Generator</b> tool representing logs in different formats
  (<em>RGT</em> tool, see [TODO]);
- <b>Testing Coverage Estimation</b> tool that gives some report about
  the quality of test suite we run against the software under test;
- <b>Test Result comparator</b> tool that can be used to check the
  difference between different test runs (TRC tool);
- <b>Test Package Generator</b> tool.
.


@section te_services Test Environment Services

From end-users (test writers) point of view TE is a set of services that
allow creating complex and full-functional tests. All services exported by TE
accessible via a set of libraries. Here is the list of libraries available
that are useful while writing this or that test cases:

- @ref te_lib_rpc

- @link logger_api.h API Usage: Logger API @endlink
- @ref confapi
- @ref rcfapi
.

- @ref tapi_conf
.

@} <!-- END te -->



@defgroup te_user TE: User Guide
@ingroup te
@{

@section te_user_introduction Introduction

This page gives step by step guideline on where to start with TE and
how to create a new test suite.

TE can be supplied in two release types:
- pre-installed form (external headers and binaries are available);
- source code form (all sources of TE components are available).
.

@section te_user_build Building TE components

When you get TE in source code form you need to build TE before
it can be used for testing.

In order to build sources you will need to prepare project-specific
@ref te_engine_builder configuration file. For the details on how to write
that configuration file please read @ref te_engine_builder_conf_file section.

For example @path{builder.conf} file for a sample test suite located under
@path{${TE_BASE}/suites/ipv6-demo} is following:

@code
@USER_EXPAND{INCLUDE_FILE} suites/ipv6-demo/conf/builder.conf
@endcode

When you prepared a @ref te_engine_builder configuration file, you are ready
to start builing process.

Before starting building process you should export @var{TE_BASE} environment
variable that points to the root directory of Test Environment sources.

In your @path{~/.bashrc} file add:
@code
export TE_BASE=/path/to/TE_root_dir
@endcode

Suppose we have the following structure under our project directory
(a directory where we run Test Environment building procedure):
<pre class="fragment">
@path{${PRJ_ROOT}}
  +-- @path{conf_ipv6}
       +-- @path{builder.conf.ipv6_demo}
</pre>

To start building process we should run the following command:
<pre class="fragment">
cd $PRJ_ROOT
@path{${TE_BASE}}/@prog{dispatcher.sh} @prog_option{--conf-dir=}@path{conf_ipv6} @prog_option{--conf-builder=}@path{builder.conf.ipv6_demo} @prog_option{--build-only} @prog_option{--no-tester}
</pre>

If you get some errors during building procedure, you should first check
if your have all necessary packages installed on your development platform.
Please refer to @ref te_deps section to check the list of required packages
and libraries.

If you do not specify @var{TE_BUILD} environment variable,
@ref te_engine_builder creates @path{build} directory under your
@path{${PRJ_ROOT}} where it calls @prog{configure} scripts and
calls @prog{make}.

@section te_user_run Running TE components

There is no much sense running TE if you do not have a test suite, but anyway
it could be useful to run TE without @ref te_engine_builder to check if
configuration files for @ref te_engine_conf and @ref te_engine_rcf are well
formatted and they reflect real infrastructure settings.

@subsection te_user_run_rcf Running RCF

@ref te_engine_rcf configuration file specifies the list of Test Agents to
run with a a set of parameters associated with them. For the detailed
information on how to write @ref te_engine_rcf configuration file please
refer to @ref te_engine_rcf_conf_file section.

More likely you will already have some @ref te_engine_rcf configuration file
or you will need to do your own version of configuration file based on
existing one.

First thing that you need to take into account while writing
@ref te_engine_rcf configuration file is the how and where you are going to
organize testing process.

Suppose you need to test some communication API between two end-points
(for example it could be Socket API) and you have the following network
topology:

@image html te_user_net_conf_rcf_sample1.png "Sample network topology"

You would like to test communication between end point pairs:
- BSD and Windows;
- BSD and Linux;
- Windows and Linux.
.

The API to be tested is the same on all platforms, which means we can use
the same test suite for each pair. The only thing specific for our test
set-up is where to run Test Agent that supports interface to be tested
(assume we exported interface to be tested via @ref te_lib_rpc_tapi).

For testing BSD vs Windows configuration we should use the following set-up:

@image html te_user_net_conf_rcf_sample2.png "TE components location for testing BSD vs Windows configuration"

In this scenario @ref te_engine_rcf configuration file would look like:

@code
<?xml version="1.0"?>
<rcf>
  <ta name="Agt_A" type="bsd" rcflib="rcfunix" confstr="gollum:5000:sudo:"/>
  <ta name="Agt_B" type="win" rcflib="rcfunix" confstr="aule:5000:sudo:"/>
</rcf>
@endcode

Please note that we use the same @ref te_engine_rcf_comm_lib_unix,
but different Test Agent types.

For testing BSD vs Linux configuration we should use the following set-up:

@image html te_user_net_conf_rcf_sample3.png "TE components location for testing BSD vs Linux configuration"

In this scenario @ref te_engine_rcf configuration file would look like:

@code
<?xml version="1.0"?>
<rcf>
  <ta name="Agt_A" type="bsd" rcflib="rcfunix" confstr="gollum:5000:sudo:"/>
  <ta name="Agt_B" type="linux" rcflib="rcfunix" confstr=":5000:sudo:"/>
</rcf>
@endcode

Note that we can avoid specifying host name for Test Agent @attr_val{Agt_B},
because it runs on the same host as @ref te_engine.

Similar set-up would be for testing  Windows vs Linux set-up.

Now we have @ref te_engine_rcf configuration files ready and we can run TE
with @ref te_engine_rcf.

Our project tree has the following structure:
<pre class="fragment">
@path{${PRJ_ROOT}}
  +-- @path{conf_ipv6}
       +-- @path{builder.conf.ipv6_demo}
       +-- @path{rcf.conf.bsd_win}
       +-- @path{rcf.conf.bsd_linux}
       +-- @path{rcf.conf.linux_win}
</pre>

To start TE with @ref te_engine_rcf, but still without @ref te_engine_conf
and @ref te_engine_tester, run:
<pre class="fragment">
@path{${TE_BASE}}/@prog{dispatcher.sh} @prog_option{--conf-dir=}@path{conf_ipv6} @prog_option{--conf-builder=}@path{builder.conf.ipv6_demo} @prog_option{--conf-rcf=}@path{rcf.conf.bsd_win} @prog_option{--no-cs} @prog_option{--no-tester}
</pre>

If you have some problems with copying Test Agent images to set-up hosts or
if you have problems with connection to these Agents you should first check
that you are able to enter these hosts without password prompt
(read @ref te_engine_rcf_comm_lib_unix for more information).

Anyway when @prog{dispatcher.sh} script finishes you can check results in
text log file @path{build/log.txt}.

@subsection te_user_run_logger Running Logger

@ref te_engine_logger configuration file depends on @ref te_engine_rcf
configuration file in case we need to specify log polling intervals on
per Test Agent basis, but in most cases logger configuration file specifies
common polling interval to use for accessing all Test Agents.

For more information on @ref te_engine_logger configuration file read
@ref te_engine_logger_conf_file.

More often @ref te_engine_logger configuration file is the same for
different test set-ups, so preferably if its name is @path{logger.conf},
because @ref te_engine_dispatcher uses this file name as the default
@ref te_engine_logger configuration file.

@subsection te_user_run_conf Running Configurator

To run @ref te_engine_conf you need to prepare a configuration file whose
name is passed to @prog{dispatcher.sh} script.
For the details on @ref te_engine_conf configuration file read
@ref te_engine_conf_file section.

Assuming our @ref te_engine_conf configuration file is split into two parts
we would have the following directory tree structure:
<pre class="fragment">
@path{${PRJ_ROOT}}
  +-- @path{conf_ipv6}
       +-- @path{builder.conf.ipv6_demo}
       +-- @path{rcf.conf.bsd_win}
       +-- @path{rcf.conf.bsd_linux}
       +-- @path{rcf.conf.linux_win}
       +-- @path{logger.conf}
       +-- @path{cs.conf.common}
       +-- @path{cs.conf.bsd_win}
       +-- @path{cs.conf.bsd_linux}
       +-- @path{cs.conf.linux_win}
</pre>

Where @path{cs.conf.bsd_win} file can look as following:
<pre class="fragment">
<?xml version="1.0"?>
<history>
  <xi:include href="cs.conf.common" parse="xml"
              xmlns:xi="http://www.w3.org/2003/XInclude"/>
  &lt;!-- BSD vs Win specific objects and instances descriptions --&gt;
</pre>

To start TE with @ref te_engine_rcf, @ref te_engine_conf, but without
@ref te_engine_tester, run:
<pre class="fragment">
@path{${TE_BASE}}/@prog{dispatcher.sh} @prog_option{--conf-dir=}@path{conf_ipv6} @prog_option{--conf-builder=}@path{builder.conf.ipv6_demo} @prog_option{--conf-rcf=}@path{rcf.conf.bsd_win} @prog_option{--conf-cs=}@path{cs.conf.bsd_win} @prog_option{--no-tester}
</pre>

@subsection te_user_run_tester Running Tester

Running @ref te_engine_tester requires some test suite to be availabe.

@} <!-- END te_user -->








@defgroup te_ts TE: Test Suite
@ingroup te
@{

@section te_ts_terminology Terminology

@tdt_start
@tdt_term Test Package
@tdt_def Group of tightly related tests or test packages, which may share
internal libraries and usually run together (one-by-one or simultaneously).
Test Package may consist of one test. It may have a prologue (performing
some initialization) and epilogue (releasing resources and restoring
TE configuration).
@tdt_term Test Script
@tdt_def A test which is a minimal structural unit of a test harness.
@tdt_term Test Suite
@tdt_def Test Package which may be considered as standalone entity from
organisational point of view and build issues.
@tdt_tend

@section te_ts_tree_structure Directory tree structure

Test suite can be distributed in two forms:
-# pre-installed binary form;
-# source based form.
.

For pre-installed binary test suite does not require building procedure,
which is why there is no need to have build related files.

Pre-installed binary test suite has the following directory structure:
<pre class="fragment">
@path{${TS_ROOT}}
  +-- @path{package.xml}
  +-- @path{prologue}
  +-- @path{epilogue}
  +-- @path{p1_test1}
  +   ...
  +-- @path{p1_testN}
  +-- @path{subpackage}
       +-- @path{package.xml}
       +-- @path{prologue}
       +-- @path{epilogue}
       +-- @path{p2_test1}
       +   ...
       +-- @path{p2_testN}
  ...
</pre>

A test suite consists of a set of packages each containing a number of
test executables and package description file. For the details on the format
of @path{package.xml} files refer to @ref te_engine_tester_conf_pkg section.

Source based test suite additionally has build-specific files. As any other
component of TE, a source based test suite is expected to be built with the
help of @ref te_engine_builder. @ref te_engine_builder uses autotools in
the backgroud, which means a top level package directory shall include:
- @path{Makefile.in} file;
- @prog{configure} script.
.

More often source based test suite will have base files of autotools:
- @path{Makefile.am};
- @path{configure.ac}.
.

The directory structure of source-based test suite is following:
<pre class="fragment">
@path{${TS_ROOT}}
  +-- @path{package.xml}
  +-- @path{configure.ac}
  +-- @path{Makefile.am}
  +-- @path{prologue.c}
  +-- @path{epilogue.c}
  +-- @path{p1_test1.c}
  +   ...
  +-- @path{p1_testN.c}
  +-- @path{subpackage}
       +-- @path{package.xml}
       +-- @path{Makefile.am}
       +-- @path{prologue.c}
       +-- @path{epilogue.c}
       +-- @path{p2_test1.c}
       +   ...
       +-- @path{p2_testN.c}
  ...
</pre>

@section te_ts_min Minimal Test Suite

Minimal test suite can be found under @path{suites/minimal/suite} directory.
This test suite has simplest package description file:
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/suite/package.xml
@endcode

Package description file specifies one test executable @prog{sample1} to run.



@} <!-- END te_user -->

 */
