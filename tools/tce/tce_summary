#! /bin/sh
#
# Test Coverage Estimation
#
# Script to generate HTML representation of the TCE report
#
#
# Copyright (C) 2005 Test Environment authors (see file AUTHORS in
# the root directory of the distribution).
#
# Test Environment is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# Test Environment is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
# MA  02111-1307  USA
#
#
# Author: Artem V. Andreev <Artem.Andreev@oktetlabs.ru>
#
# $Id$
#

usage ()
{
    cat >&2 <<EOF
USAGE: tce_summary <log-file-name> [<options>...] [<output-file>]
Converts a TCE log into HTML form. If <output-file> is not given,
standard output is assumed.

Options:
--datadir=<directory>  If given, <output-file> will only contain
                        an index of files, actual annotated sources
                        being placed into <directory>, one file per source
--map-file=<mapfile>   The name of a file containing name-to-module map
--modules=<modulename> The space-separated list of modules 
                       to measure coverage of
                       ("-" denotes user-land code)
--totals-to=<filename> If this option is present, <filename> will be
                       generated containing totals in text format
--conditionals=<list>  The space-separated list of preprocessor conditionals 
                       which are taken into account 
--sort-by=<MODE>       The mode of sorting the index of files:
                            branches  by covered branches percentage
                                      (the default)
                            lines     by covered lines percentage
                            sources   by filename
                            modules   by module

EOF
exit 0
}

outputfile="/dev/stdout"
sortmode=""
for arg; do
    case "$arg" in
        --datadir=*) datadir="${arg#--datadir=}/"; mkdir -p "$datadir"
            ;;
        --sort-by=*) for sm in ${arg#--sort-by}; do
                        case "$sm" in
                            branches) sortmode="$sortmode -k5,5g -k6,6nr" ;;
                            lines) sortmode="$sortmode -k1,1g -k2,2nr" ;;
                            sources) sortmode="$sortmode -k9,9" ;;
                            modules) sortmode="$sortmode -k10.33,10" ;;
                            *) usage "Unknown sort mode $sm" ;;
                        esac
                     done ;;
        --map-file=*) mapfile=${arg#--map-file=} ;;
        --totals-to=*) totalfile=${arg#--totals-to=} ;;
        --modules=*)  modules=${arg#--modules=} ;;
        --conditionals=*) conditionals=${arg#--conditionals=} ;;
        --help) usage ;;
        --*) echo "Unrecognized option $arg" >&2; usage; exit 1 ;;
        *)
        if test -z "$sourcefile"; then
            sourcefile="$arg"
        else
            outputfile="$arg"
        fi
        ;;
    esac
done

if test -z "$sortmode"; then
    sortmode='-k5,5g -k6,6nr' # by branches
fi


if test -z "$sourcefile"; then
    echo "Log file name must be given" >&2
    usage
    exit 1
fi

if test "$outputfile" == "/dev/stdout" -a -n "$totalfile"; then
    echo "An explicit output filename must be given " \
        "when --totals-to is present" >&2
    usage
    exit 1
fi

if test -z "$modules" -a -n "$mapfile"; then
    modules=`awk '{ print $2; }' $mapfile | sort | uniq`
fi

if test -n "$conditionals"; then
    cb=`echo $conditionals | sed 's/^[[:space:]]*//
                                  s/[[:space:]]*$//
                                  s/[[:space:]][[:space:]]*/|/g'`
    begincond="[0-9]+:#if(def)?[[:space:]]*($cb)[[:space:]]*\$"
    endcond="[0-9]+:#endif.*($cb)"
fi

cat >$outputfile <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
  <TITLE>TCE Summary</TITLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 ALIGN=CENTER>TCE Summary</H1>
<!-- totals -->
`ar p "$sourcefile" | tce_count - '^branch[[:space:]]*[0-9]+ (never executed|taken 0)' \
    '^branch[[:space:]]*[0-9]+ taken[[:space:]]*[1-9][0-9]*' "$begincond" "$endcond" |
(
    read ratio sum
    echo "<H2>Grand Total: $ratio% of $sum branches covered</H2>" 
)
ar p "$sourcefile" | tce_count - '^[[:space:]]*#+:' '^[[:space:]]*[0-9]+:' "$begincond" "$endcond" |
(
    read ratio sum
    echo "<H2>Grand Total: $ratio% of $sum lines covered</H2>" 
)
`
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=3>
<TH>Module</TH>
<TH>% of taken branches</TH>
<TH>% of executed lines</TH>
`for m in $modules; do
echo "<TR><TD>$m</TD>"
ar t "$sourcefile" | awk "/\\.$m\$/ { print }"  | xargs -n1 ar p $sourcefile |
tce_count - '^branch[[:space:]]*[0-9]+ (never executed|taken 0)' \
    '^branch[[:space:]]*[0-9]+ taken[[:space:]]*[1-9][0-9]*' "$begincond" "$endcond" | 
(
    read ratio sum
    echo "<TD>$ratio% of $sum</TD>" 
)
ar t "$sourcefile" | awk "/\\.$m\$/ { print }" | xargs -n1 ar p $sourcefile |
tce_count - '^[[:space:]]*#+:' '^[[:space:]]*[0-9]+:' "$begincond" "$endcond" |
(
    read ratio sum
    echo "<TD>$ratio% of $sum</TD>" 
)
done
`
<!-- end totals -->
</TABLE>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=3>
<TH>% of taken branches</TH>
<TH>Total branches</TH>
<TH>% of executed lines</TH>
<TH>Total lines</TH>
<TH>Module</TH>
<TH>Source file</TH>

EOF

if test -n "$totalfile"; then
    awk '/^<!-- totals -->/, /^<!-- end totals -->/ {
                                      line = $0
                                      if ($0 ~ /<(TR)/) print "";
                                      gsub(/<[^>]*>/, "", line);
                                      if (line)
                                      {
                                          printf "%-20.20s", line
                                      }
                                      if ($0 ~ /<(TABLE|H2)/) print "";
                                      }
                                  END { print ""; }' $outputfile > $totalfile
fi

if test -z "$modules"; then
    modulefilter="{ print }"
else
    m=`echo $modules | sed 's/^[[:space:]]*//
                            s/[[:space:]]*$//
                            s/[[:space:]][[:space:]]*/|/g'`
    modulefilter="/\\.($m)\$/ { print }"
fi


ar t $sourcefile | awk "$modulefilter" | \
    xargs -n1 tce_summary_file $sourcefile "$begincond" "$endcond" >${sourcefile}.summary
cat ${sourcefile}.summary | sort $sortmode | \
    awk -vSUBDIR=$datadir \
    '$2 != 0 { fname=$9; gsub(/\//, "-", fname); modname=$10; sub(/^[^.]*\./, "", modname);
                                printf "<tr><td>%s<td>%s<td>%s<td>%s<td>%s<td><a href=\"%s\">%s</a></tr>\n",
                                $5, $6, $1, $2, modname, (SUBDIR ? SUBDIR fname ".html" : "#" $10) , $9 }' >>$outputfile

echo "</TABLE>" >>$outputfile

if test -n "$datadir"; then
    echo "</BODY>" >>$outputfile
    echo "</HTML>" >>$outputfile
fi

awk -vSUBDIR=$datadir -vSOURCEFILE=$sourcefile -vBC="$begincond" -vEC="$endcond" '$2 != 0 {
          if (!SUBDIR) 
              myfile="/dev/stdout";
          else
          {
             name=$9
             gsub(/\//, "-", name)
             myfile=SUBDIR name ".html"
             print "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">" >myfile
             print "<html>" >>myfile
             print "<head>" >>myfile
             print "<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">" >>myfile
             print "<title>TCE Annotated Source for " filename "</title>" >>myfile
             print "</head>" >>myfile
             print "<body lang=\"en-US\" dir=\"LTR\">" >>myfile
          }
          printf "<h2>%s</h2>\n", $9 >> myfile;
          printf "<p><a name=\"%s\"></a><table border=\"1\" align=\"center\">", $10 >> myfile;
          printf "<tr><td>%s of %d lines executed\n" \
                 "<tr><td>%s of %d branches executed\n" \
                 "<tr><td>%s of %d branches taken at least once\n" \
                 "<tr><td>%s of %d calls executed\n" \
                 "</table>\n<pre>",
                 $1, $2, $3, $4, $5, $6, $7, $8 >> myfile;
         excluded = 0
         thefile = $10
         while ((("ar p " SOURCEFILE " " thefile) | getline srcline) > 0)
         {
             if (BC && srcline ~ BC)
             {
                 print "</pre>\n<table>\n<tr><td bgcolor='#AAAAAA'><pre>" >>myfile;
                 startline = FNR
                 excluded = 1;
             }
             else if (excluded && srcline ~ EC)
             {
                 excluded = 0;
                 print "</pre>\n</table>\n<pre>" >>myfile
             }
             gsub(/&/, "\\&amp;", srcline); 
             gsub(/</, "\\&lt;", srcline); 
             gsub(/>/, "\\&gt;", srcline); 
             gsub(/"/, "\\&quot;", srcline); 
             if (!excluded && (srcline ~ /^[[:space:]]*#+:/))
                 srcline = "<strong>" srcline "</strong>"
             else if (srcline ~ /^[[:space:]]*(call|branch|function)/)
                 srcline = "<small>" srcline "</small>"
             print srcline >>myfile
         }
         if (excluded)
         {
             print "Unclosed conditional detected at " thefile ":" startline >"/dev/stderr"
         }
         close("ar p " SOURCEFILE " " thefile);
         print "</pre>" >>myfile
         if (SUBDIR)
             print"</body></html>" >>myfile
         close(myfile);
      }' $sourcefile.summary >>$outputfile


