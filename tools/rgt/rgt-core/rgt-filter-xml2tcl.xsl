<?xml version="1.0"?>

<!--
    This is a XSL stylesheet that converts filter configuration XML file
    into TCL procedures that allow to filter log messages by their attributes
    (log level, entity name, user name, timestamp).
    The main procedure, to be generated, for filtering by this class is 
    "rgt_msg_filter".
    
    Also it generates "rgt_branch_filter" procedure for filtering by 
    test/package names.

    Copyright (C) 2003 Test Environment authors (see file AUTHORS
    in the root directory of the distribution).

    Test Environment is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later
    version.
            
    Test Environment is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
    PURPOSE. See the GNU General Public License for more details.
            
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330,
    Boston, MA  02111-1307  USA
    
    Author: Oleg N. Kravtsov <Oleg.Kravtsov@oktetlabs.ru>
   
    $ld: $
  -->

<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:output method="text"/>

<xsl:template match="/">

<xsl:text>
#
# This file was generated by rgt-filter-prepare from XML filter file.
# You can modify it for your purposes, but you MUST remain "rgt_msg_filter"
# and "rgt_branch_filter" procedures that are obligatory.
#
</xsl:text>

    <xsl:apply-templates/>
    
    <xsl:if test="count(/filters/entity-filter)=0">
        <xsl:call-template name="entity-filter"/>
    </xsl:if>
    <xsl:if test="count(/filters/time-filter)=0">
        <xsl:call-template name="time-filter"/>
    </xsl:if>
    <xsl:if test="count(/filters/duration-filter)=0">
        <xsl:call-template name="duration-filter"/>
    </xsl:if>
    <xsl:if test="count(/filters/branch-filter)=0">
        <xsl:call-template name="branch-filter"/>
    </xsl:if>

<xsl:text>

# rgt_msg_filter --
#    Determines if log message with particular "entity name",
#    "user name" and "timestamp" passed through the filters.
#
# PARAMETERS:
#    level     - Log level
#    entity    - Entity name
#    user      - User name
#    timestamp - Message timestamp
#
# RETURNS:
#    pass - Message with the particular attributes passed through the filters.
#    fail - Otherwise.
#
proc rgt_msg_filter { level entity user timestamp } {

    if {[string compare [rgt_entity_filter $entity $user] "pass"] == 0 &amp;&amp;
        [string compare [rgt_time_filter $timestamp] "pass"] == 0} {
        return "pass"
    }

    return "fail"
}

</xsl:text>

</xsl:template>


<xsl:variable name="incl-value">pass</xsl:variable>
<xsl:variable name="excl-value">fail</xsl:variable>
<xsl:variable name="max_timestamp_value">40000</xsl:variable>
<xsl:param name="def-mode" select="$incl-value"/>

<!-- 
     Template that generates procedure for filtering by entity and user names.
  -->
<xsl:template match="entity-filter" name="entity-filter">

    <!-- Create rgt_entity_filter procedure -->

<xsl:text>

# rgt_entity_filter --
#    Procedure that checks if a pair of "entity name", "user name" 
#    conforms user specified filter.
# 
# PARAMETERS:
#    entity - Entity name to be checked.
#    user   - User name to be checked.
#
# RETURNS:
#    In the case when the pair passes through user filter 
#    it returns "pass" string, otherwise "fail".
#
proc rgt_entity_filter { entity user } {
    switch $entity {
</xsl:text>

        <xsl:variable name="empty_entity_name" 
                      select="count(include[@entity=''] | 
                                    exclude[@entity=''])"/>

        <!-- Process include/exclude elements -->
        <xsl:for-each select="include | exclude">
        <xsl:sort select="@entity" data-type="text" order="descending"/>

            <!-- Create new case branch only if we haven't met such 
                 entity name before.
              -->
            <xsl:if test="count(
                            preceding-sibling::*[@entity=current()/@entity])=0">
                <!-- 
                     There might be two possible cases:
                     
                     1. There is one empty include or exclude element 
                        (with the same entity name as current element).
                        It means user wants to include/exclude all messages 
                        from particular entity by default.
                     2. There is no such empty element, so the default 
                        behaviour is applied.
                  -->
                
                <xsl:choose>
                    <xsl:when test="count(following-sibling::*[
                        @entity=current()/@entity][count(child::*)=0] | 
                                          self::*[count(child::*)=0])&gt;0">

<!-- THE FIRST CASE -->

    <!-- 
        Define default mode for particular entity name 
        TODO: There might be only one "empty" element. 
        So for-each element can be reduced.
      -->
    <xsl:for-each select="
        following-sibling::*[@entity=current()/@entity][count(child::*)=0] | 
        self::*[count(child::*)=0]">

        <!-- Default behaviour depends on element type (include or exclude) -->
        <xsl:choose>
            <xsl:when test="name()='include'">
                <xsl:call-template name="process_new_entity_name">
                    <xsl:with-param name="entity" select="@entity"/>
                    <xsl:with-param name="def-match" select="$incl-value"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when test="name()='exclude'">
                <xsl:call-template name="process_new_entity_name">
                    <xsl:with-param name="entity" select="@entity"/>
                    <xsl:with-param name="def-match" select="$excl-value"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>

    </xsl:for-each>

<!-- END THE FIRST CASE -->
                   
                    </xsl:when>

                    <xsl:otherwise>

<!-- THE SECOND CASE -->
    <!-- 
        There is no empty element specified: 
        apply default behaviour 
      -->

    <xsl:choose>
    <xsl:when test="$empty_entity_name!=0">
        <xsl:choose>
            <xsl:when test="
                name(preceding-sibling::*[@entity=''][count(child::*)=0] | 
                     following-sibling::*[@entity=''][count(child::*)=0] | 
                     self::*[@entity=''][count(child::*)=0])='include'">
      <xsl:call-template name="process_new_entity_name">
          <xsl:with-param name="entity" select="@entity"/>
          <xsl:with-param name="def-match" select="$incl-value"/>
      </xsl:call-template>
            </xsl:when>
            <xsl:when test="
                name(preceding-sibling::*[@entity=''][count(child::*)=0] | 
                     following-sibling::*[@entity=''][count(child::*)=0] | 
                     self::*[@entity=''][count(child::*)=0])='exclude'">
      <xsl:call-template name="process_new_entity_name">
          <xsl:with-param name="entity" select="@entity"/>
          <xsl:with-param name="def-match" select="$excl-value"/>
      </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
      <xsl:call-template name="process_new_entity_name">
          <xsl:with-param name="entity" select="@entity"/>
          <xsl:with-param name="def-match" select="$def-mode"/>
      </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="process_new_entity_name">
          <xsl:with-param name="entity" select="@entity"/>
          <xsl:with-param name="def-match" select="$def-mode"/>
      </xsl:call-template>
    </xsl:otherwise>
    </xsl:choose>
    
<!-- END THE SECOND CASE -->

                    </xsl:otherwise>
                    
                </xsl:choose>
                
            </xsl:if>

        </xsl:for-each> <!-- END <xsl:for-each select="include | exclude"> -->

<!-- 
    If there is no one "include" or "exclude" element with entity="" we
    should provide default branch.
-->
        <xsl:if test="$empty_entity_name=0">
            <xsl:call-template name="process_new_entity_name">
                <xsl:with-param name="entity"></xsl:with-param>
                <xsl:with-param name="def-match" select="$def-mode"/>
            </xsl:call-template>
        </xsl:if>
<xsl:text>
    }
}
# end of rgt_entity_filter procedure
</xsl:text>
    
</xsl:template>


<!-- 
    process_new_entity_name -
    
    This template generates a pair (pattern body), where pattern is the value 
    passed in ${entity} parameter and body is a Tcl switch statement.

    If ${entity} equals to '' (empty string) pattern will be "default"
    
    It extracts all elements (include and exclude) where "entity" attribute 
    equals to ${entity} argument and generates the following switch statement:

    switch $user {
        pattern body
        ...
        pattern body

        default { return "${def-match}" }
    }
    
    Where all patterns are all user names mentioned in (include and exclude) 
    elements. A body of particular pattern depends on the element name 
    under which user name is placed.
    
    For include element body looks as: { return "${incl-value}" }
    For exclude element body looks as: { return "${excl-value}" }

    PARAMETERS:
        entity    - Entity name that will be used as a pattern string in 
                    switch statement.
        def-match - This value will be inserted as a default return value.
    
  -->
<xsl:template name="process_new_entity_name">
    <xsl:param name="entity"/>
    <xsl:param name="def-match"/>
    
    <!-- Generate switch statement by user name value -->

    <xsl:text>
        </xsl:text>
        
        <xsl:choose>
            <xsl:when test="$entity=''">
                <xsl:text>default</xsl:text>
            </xsl:when>

            <xsl:otherwise>
                <xsl:text>"</xsl:text>
                    <xsl:value-of select="$entity"/>
                <xsl:text>"</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    
<xsl:text> {
            switch $user {
</xsl:text>

            <!-- 
                 Select all include/exclude elements with particular 
                 entity name 
              -->
            <xsl:for-each select="
                preceding-sibling::*[@entity=$entity] | 
                following-sibling::*[@entity=$entity] | 
                self::*">
                
                <!-- Create branches for particular users -->
                <xsl:for-each select="user">

                    <xsl:text>                </xsl:text>
                    <xsl:text>"</xsl:text>
                        <xsl:value-of select="@name"/>
                    <xsl:text>"</xsl:text>
                    <xsl:text> { return "</xsl:text>

                    <xsl:choose>
                        <xsl:when test="name(parent::node()[1])='include'">
                            <xsl:value-of select="$incl-value"/>
                        </xsl:when>

                        <xsl:when test="name(parent::node()[1])='exclude'">
                            <xsl:value-of select="$excl-value"/>
                        </xsl:when>
                    </xsl:choose>
                    
                    <xsl:text>" }&#xA;</xsl:text>

                </xsl:for-each>
                
            </xsl:for-each>

            <xsl:if test="$entity!=''">
            <xsl:for-each select="
                preceding-sibling::*[@entity=''] | 
                following-sibling::*[@entity='']">
                <xsl:for-each select="user">

                    <xsl:text>                </xsl:text>
                    <xsl:text>"</xsl:text>
                        <xsl:value-of select="@name"/>
                    <xsl:text>"</xsl:text>
                    <xsl:text> { return "</xsl:text>

                    <xsl:choose>
                        <xsl:when test="name(parent::node()[1])='include'">
                            <xsl:value-of select="$incl-value"/>
                        </xsl:when>

                        <xsl:when test="name(parent::node()[1])='exclude'">
                            <xsl:value-of select="$excl-value"/>
                        </xsl:when>
                    </xsl:choose>
                    
                    <xsl:text>" }&#xA;</xsl:text>

                    
                </xsl:for-each>
            </xsl:for-each>
            </xsl:if>

        <!-- Output default branch -->
        <xsl:text>                </xsl:text>
        <xsl:text>default { return "</xsl:text>
            <xsl:value-of select="$def-match"/>
        <xsl:text>" }</xsl:text>
        <xsl:text>
            }
        }
    </xsl:text>
    
</xsl:template>


<!--
     This templates responsible for generation time interval filter routine.
  -->
<xsl:template match="time-filter" name="time-filter">
    <!-- Create rgt_entity_filter procedure -->

<xsl:text>
# rgt_time_filter --
#    Procedure that checks if time value conforms user specified filter.
# 
# PARAMETERS:
#    timestamp - Time value to be checked.
#
# RETURNS:
#    In the case when the timestamp passes through user filter 
#    it returns "pass" string, otherwise "fail".
#
proc rgt_time_filter { timestamp } {
</xsl:text>

        <!-- Process include/exclude elements -->
        <xsl:for-each select="/filters/time-filter/*">
            <xsl:if test="position()=1">
                <xsl:call-template name="process_time_interval">
                    <xsl:with-param name="lower_bound" select="0"/>
                    <xsl:with-param name="upper_bound" 
                                    select="$max_timestamp_value"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:for-each>
        
<xsl:text>
    return "</xsl:text><xsl:value-of select="$def-mode"/><xsl:text>"
}
# end of rgt_time_filter procedure
</xsl:text>

</xsl:template>


<!--
    process_time_interval -

    This template selects all nodes with: 
      @start > ${lower_bound} && @end < ${upper_bound}
      
    For the node with the least @start value it generates:

    if { $timestamp > ${@start} && $timestamp < ${@end} } {

    After that it reqursively calls itself with (@start, @end) arguments.
    
    When the recursion is finised it outputs the following:
    
        return "${[in|ex]cl-value}"
    }

    Then it tries to process the nodes with @start value less than the least
    @start attribute and with @end attribute less than @end attribute in the 
    node with the least @start attribute.
    
  -->
<xsl:template name="process_time_interval">
    <xsl:param name="lower_bound"/>
    <xsl:param name="upper_bound"/>

    <xsl:for-each select="
        preceding-sibling::*[@start &gt;= $lower_bound and 
                             @end &lt; $upper_bound] | 
        following-sibling::*[@start &gt;= $lower_bound and 
                             @end &lt; $upper_bound] |
        self::*[@start &gt;= $lower_bound and @end &lt; $upper_bound]">
    <xsl:sort select="@start" data-type="number" order="ascending"/>
            
        <xsl:choose>
            <!-- Process internal intervals -->
            <xsl:when test="position()=1">
                
                <xsl:text>if { $timestamp &gt;= </xsl:text>
                <xsl:value-of select="@start"/>
                <xsl:text> &amp;&amp; $timestamp &lt; </xsl:text>
                <xsl:value-of select="@end"/>
                <xsl:text> } {&#xA;</xsl:text>
                
                <xsl:call-template name="process_time_interval">
                    <xsl:with-param name="lower_bound" select="@start"/>
                    <xsl:with-param name="upper_bound" select="@end"/>
                </xsl:call-template>

                <xsl:text>return "</xsl:text>
                
                <xsl:choose>
                    
                    <xsl:when test="name()='include'">
                        <xsl:value-of select="$incl-value"/>
                    </xsl:when>
                    
                    <xsl:when test="name()='exclude'">
                        <xsl:value-of select="$excl-value"/>
                    </xsl:when>
                    
                </xsl:choose>

                <xsl:text>"}&#xA;</xsl:text>
                
            </xsl:when>

            <xsl:when test="position()=2">
                <xsl:call-template name="process_time_interval">
                    <xsl:with-param name="lower_bound" 
                             select="preceding-sibling::*[position()=1]/@end"/>
                    <xsl:with-param name="upper_bound" select="$upper_bound"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise/>
        </xsl:choose>
        
    </xsl:for-each>

</xsl:template>


<!--
     This templates responsible for generation duration filter routine.
  -->
<xsl:template match="duration-filter" name="duration-filter">
    <!-- Create rgt_duration_filter procedure -->

<xsl:text>
# rgt_duration_filter --
#    Procedure that checks if duration value conforms user specified filter.
# 
# PARAMETERS:
#    node_type  - Type of the node ("TEST", "SESSION" or "PACKAGE")
#    duration   - Duration value in seconds to be checked
#
# RETURNS:
#    In the case when the timestamp passes through user filter 
#    it returns "pass" string, otherwise "fail".
#
proc rgt_duration_filter { node_type duration } {
    return "</xsl:text><xsl:value-of select="$def-mode"/><xsl:text>"
}
# end of rgt_duration_filter procedure
</xsl:text>

</xsl:template>


<!--
     This templates responsible for generation branch filter routines.
  -->
<xsl:template match="branch-filter" name="branch-filter">

<xsl:text>
# rgt_branch_filter --
#    Procedure that defines filtering mode for specific flow tree node.
# 
# PARAMETERS:
#    path - Path of node to be checked.
#
# RETURNS:
#    In the case when the node is in include filtering mode returns "pass" 
#    otherwise "fail". If filtering mode isn't determined for the node it 
#    returns "default".
#
proc rgt_branch_filter { path } {
    switch $path {
</xsl:text>
    
    <xsl:for-each select="/filters/branch-filter/*">
        <xsl:text>        </xsl:text>
        <xsl:value-of select="@package"/>

        <xsl:choose>
            <xsl:when test="contains(name(), 'test')">
                <xsl:text>/</xsl:text><xsl:value-of select="@test"/>
            </xsl:when>
        </xsl:choose>
        
        <xsl:text> { return "</xsl:text>
        <xsl:choose>
            <xsl:when test="contains(name(), 'include')">
                <xsl:text>pass</xsl:text>
            </xsl:when>

            <xsl:otherwise>
                <xsl:text>fail</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        
        <xsl:text>" }&#xA;</xsl:text>
    </xsl:for-each>

<xsl:text>
        default { return "default" }
    }
}
</xsl:text>

</xsl:template>



<xsl:template match="text()"/>

</xsl:stylesheet>


