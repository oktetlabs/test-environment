#!/usr/bin/perl

use strict;
use warnings;
use Date::Manip;
use File::Temp qw/ tempfile /;
use IPC::Open2;
use File::Basename;
use Data::Dumper;
use English;
use Time::HiRes qw( time gettimeofday tv_interval );
use Storable qw/nstore retrieve dclone/;
use POSIX;

umask 0027;

my @tmp_files = ();
my $date_from;
my $date_to;
my $last_log_date = new Date::Manip::Date;
my @log_paths;
my $verbose = 0;
my $night_results_fn = "night_results.html";
my $tag_expr;
my $use_remote_path = 1;
my $include_compromised = 0;
my $update_cache_path;
my $cached_logs_path;
my $benchmarks = 0;
my $with_err_only = 0;

my $tester_logs_dir = "testdir";
my $default_cache_path = "/home/izbitsky/cached_v5_tot/";
my $loaded_logs = {};
my $one_xml_log_parsed = 0;

my %night_results = (
  tests => {},
);

my %tests_filter = ();

my %timestamps = (
    download => 0,
    unpack => 0,
    process => 0,
    fsize => 0,
    );

my $global_start = [gettimeofday];
my $start = 0;
my $end = 0;

# List of compromised logs stored in results cache
my %compromised_logs = ();

sub log_in_compromised
{
    my $log = $_[0];

    $log =~ s/\/html\/.*$/\//;
    $log =~ s/[\/]+/\//g;
    $log =~ s/^(.*):\//$1:\/\//;

    return defined($compromised_logs{$log});
}

sub get_timestamp
{
    use POSIX qw(strftime);
    my $cur_time = strftime "%a %b %e %H:%M:%S %Y", localtime;

    return if ($benchmarks == 0);

    # print sprintf("%s: %s %s\n", $cur_time, $_[0], $_[1]);

    if ($_[1] =~ 'start') 
    {
        $start = [gettimeofday];
    }
    else
    {
        $end = [gettimeofday];
    }

    $timestamps{$_[0]} += tv_interval($start);

    printf("Exectution time=%.2f =? (down=%.2f + unpack=%.2f + process=%.2f = %.2f) ; downloaded=%d\n",
           tv_interval($global_start),
           $timestamps{'download'},
           $timestamps{'unpack'},
           $timestamps{'process'}, 
           $timestamps{'download'} + $timestamps{'unpack'} + $timestamps{'process'},
           $timestamps{'fsize'}
        );
}

sub escape_str
{
    my $str = $_[0];
    $str =~ s/([\\"\$])/\\$1/g;
    return $str;
}

sub system_call
{
    my $cmd = $_[0];

    return system("trap \"kill -s 10 ".$PID."\" SIGINT ; ".$cmd);
}

sub download_log
{
    my $file_to_load = $_[0];
    my $file_to_save = $_[1];

    if ($file_to_load =~ m/https:\/\//)
    {
        return system_call("curl -L -s -u : --negotiate ".
                           $file_to_load." -f".
                           " -o ".$file_to_save);
    }
    else
    {
        return system_call("scp -q ".$file_to_load.
                           " ".$file_to_save);
    }
}

sub is_log_compromised
{
    my $path = $_[0];

    $path =~ s/[^\/]*$//;
    $path = $path."trc_compromised.js";

    if ($path =~ m/^(.*):/) # Protocol name, i.e. download from
    # remote location
    {
        (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");

        system_call("curl -L -s -u : --negotiate ".
                    $path." -f".
                    " -o ".$tmp_files[$#tmp_files]);
        if ((-s $tmp_files[$#tmp_files]) > 0)
        {
            return 1;
        }
    }
    else
    {
        if ( -e $path && (-s $path) > 0)
        {
            return 1;
        }
    }

    return 0;
}

sub download_prepare_log
{
    my $file_to_load = $_[0];
    my $is_compromised = 0;

    if ($verbose)
    {
        print "Download/Prepare $file_to_load\n";
    }

    my $log_name;
    my $file_name = "";

    $file_to_load =~ /.*\/([^\/]*)[\/]?\s*$/;
    $log_name = $1;
    $file_to_load =~ s/\s*$//;

    if ($file_to_load =~ m/\/$/)
    {
        $file_to_load = $file_to_load."trc-log.bz2";
    }

    $is_compromised = is_log_compromised($file_to_load);
    if ($is_compromised > 0 && $include_compromised == 0)
    {
        return (-1, $is_compromised);
    }

    (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
    if ($file_to_load =~ m/^(.*):/) # Protocol name, i.e. download from
    # remote location
    {
        my $rc = 0;

        get_timestamp('download', 'start');
        $rc = download_log($file_to_load, $tmp_files[$#tmp_files]);

        if ($rc != 0)
        {
            warn "Failed to fetch XML log";
            return (-1, 0);
        }

        get_timestamp('download', 'end');

        $timestamps{'fsize'} += (stat $tmp_files[$#tmp_files])[7];
        $file_name = $tmp_files[$#tmp_files];
    }
    else
    {
        $file_name = $file_to_load;
    }

    get_timestamp('unpack', 'start');

    (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
    if (system_call("cp ".escape_str($file_name)." ".
                    $tmp_files[$#tmp_files]) != 0)
    {
        warn "Failed to copy XML log";
        return (-1, 0);
    }
    $file_name = $tmp_files[$#tmp_files];

    if ($file_to_load =~ m/^(.*)[.]bz2\s*$/)
    {
        (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
        if (system_call("bzcat ".$file_name." > ".
                        $tmp_files[$#tmp_files]) != 0)
        {
            warn "Failed to unzip XML log";
            return (-1, 0);
        }
        $file_name = $tmp_files[$#tmp_files];
    }

    get_timestamp('unpack', 'end');

    return (0, $is_compromised);
}

sub free_tmp_files
{
    system("rm -f ".join(" ", @tmp_files));
    @tmp_files = ();
}

sub compare_str_hashes
{
    my $hash1 = $_[0];
    my $hash2 = $_[1];

    for my $key (keys %$hash1)
    {
        return 0 if (defined($hash1->{$key}) != defined($hash2->{$key}) ||
                     $hash1->{$key} ne $hash2->{$key});
    }

    for my $key (keys %$hash2)
    {
        return 0 if (defined($hash1->{$key}) != defined($hash2->{$key}) ||
                     $hash1->{$key} ne $hash2->{$key});
    }

    return 1;
}

sub compare_str_arrays
{
    my $i = 0;
    my $arr1 = $_[0];
    my $arr2 = $_[1];

    return 0 if (scalar(@$arr1) != scalar(@$arr2));

    for ($i = 0; $i < scalar(@$arr1); $i++)
    {
        return 0 if ($arr1->[$i] ne $arr2->[$i]);
    }

    return 1;
}

sub match_test_paths
{
    my $path1 = $_[0];
    my $path2 = $_[1];

    my $path_reg = qr/$path1/;
    if ($path2 =~ /^[\/]?${path_reg}[\/]?$/)
    {
        return 1;
    }

    return 0;
}

sub match_params
{
    my $iter_params = $_[0];
    my $filter_params = $_[1];

    foreach my $name (keys %$filter_params)
    {
        return 0 if (!defined($iter_params->{$name}) ||
                     $iter_params->{$name} ne $filter_params->{$name});
    }

    return 1;
}

sub match_iter_params
{
    my $cur_path = $_[0];
    my $iter = $_[1];
    my $matched = 0;

    foreach my $test_path (keys %tests_filter)
    {
        next if (match_test_paths($test_path, $cur_path) == 0);

        if (defined($tests_filter{$test_path}->{"hash"}))
        {
            if (defined($iter->{"hashes"}) &&
                scalar(keys %{$iter->{"hashes"}}) > 0)
            {
                foreach my $hash (keys %{$iter->{"hashes"}})
                {
                    if ($tests_filter{$test_path}->{"hash"} eq $hash)
                    {
                        $matched = 1;
                        last;
                    }
                }
            }
            else
            {
                $matched = 1;
            }
        }
        else
        {
            foreach my $filter_params (@{$tests_filter{$test_path}->{"params"}})
            {
                if (match_params($iter->{"params"},
                                 $filter_params))
                {
                    $matched = 1;
                }
            }
            $matched = 1
                  if (scalar(@{$tests_filter{$test_path}->{"params"}}) == 0);
        }
    }
    $matched = 1 if (scalar(keys %tests_filter) == 0);

    return $matched;
}

sub hash2str
{
    my $hash = $_[0];
    my $str = "";

    foreach my $key (sort(keys %{$hash}))
    {
        $str .= $key." => ".$hash->{$key}."; ";
    }

    return $str;
}

sub test_add_iter
{
    my $test = $_[0];
    my $cur_iter = $_[1];
    my $iter_found = 0;

    my $iter_key;

    $iter_key = hash2str($cur_iter->{"params"});

    if (!defined($test->{"iters"}->{$iter_key}))
    {
        $test->{"iters"}->{$iter_key} = dclone($cur_iter);
    }
    else
    {
        my $iter = $test->{"iters"}->{$iter_key};

        if (defined($cur_iter->{"hashes"}))
        {
            foreach my $hash (keys %{$cur_iter->{"hashes"}})
            {
                $iter->{"hashes"}->{$hash} =
                              $cur_iter->{"hashes"}->{$hash};
            }
        }

        foreach my $cur_result (@{$cur_iter->{"results"}})
        {
            my $result_found = 0;

            foreach my $result (@{$iter->{"results"}})
            {
                if ($result->{"result"} eq
                      $cur_result->{"result"} &&
                    $result->{"err"} eq
                      $cur_result->{"err"} &&
                    compare_str_arrays(
                      $result->{"verdicts"},
                      $cur_result->{"verdicts"}))
                {
                    $result_found = 1;

                    if ($cur_result == $result)
                    {
                        die "Result duplication encountered which ".
                            "can lead to infinite loop\n";
                    }
                    foreach my $cur_log (@{$cur_result->{"logs"}})
                    {
                        push(@{$result->{"logs"}}, $cur_log)
                    }

                    last;
                }
            }

            if ($result_found == 0)
            {
                push(@{$iter->{"results"}},
                     dclone($cur_result));
            }
        }
    }
}

sub night_results_add_iter
{
    my $cur_path_str = $_[0];
    my $cur_iter = $_[1];
    my $matched = 0;

    $matched = match_iter_params($cur_path_str, $cur_iter);
    return if (!$matched);

    if (!$night_results{"tests"}->{$cur_path_str})
    {
        my $test_descr = { iters =>
            { hash2str($cur_iter->{"params"}) => dclone($cur_iter) } };

        $night_results{"tests"}->{$cur_path_str} = $test_descr;
    }
    else
    {
        test_add_iter($night_results{"tests"}->{$cur_path_str},
                      $cur_iter);
    }
}

sub remove_extra_slashes
{
    my $str = $_[0];

    $str =~ s/^\s*//;
    $str =~ s/\s*$//;
    $str =~ s/\/+/\//g;

    if ($str =~ /([^[:space:]]*):\/(.*)$/)
    {
        $str = $1."://".$2;
    }

    return $str;
}

# We must reference HTML logs in https://oktetlans/~tester-l5/,
# not in local file system.
sub fix_html_log_path
{
    my $log_path = $_[0];

    if ($log_path =~ s/\/home\/([^\/]*)\/$tester_logs_dir/~$1/)
    {
        $log_path = "https://oktetlabs.ru/".$log_path;
    }

    return $log_path;
}

# Caching already evaluated tags to speed up
# tag filtering
my %tags_eval_cache = ();

sub match_tags
{
    my $tags = $_[0];
    my $tag_expr = $_[1];
    my $comp = "";
    my $rc = 0;
    my %tag_names = ();
    my $tag_name;
    my $saved_tags;

    if (!defined($tag_expr) || length($tag_expr) == 0)
    {
        return 1;
    }

    if (defined($tags_eval_cache{$tags}))
    {
        return $tags_eval_cache{$tags};
    }

    $saved_tags = $tags;
    $tags =~ s/^\s*//;
    while ($tags =~ /^([^\s]+)\s*/)
    {
        my $tag = $1;

        $tag =~ s/[.-]/_/g;
        $tag =~ s/:/=/;

        $tag_name = $tag;
        $tag_name =~ s/=.*$//;
        $tag_names{$tag_name} = 1;

        if (!($tag =~ /=/))
        {
            $tag = $tag."=1";
        }

        $comp = $comp."\$$tag;\n ";

        $tags =~ s/^([^\s]+)\s*//;
    }

    foreach $tag_name (keys %tag_names)
    {
        $comp = "my \$$tag_name;\n".$comp;
    }

    $comp = $comp."\nif ($tag_expr) { \$rc = 1; } ".
            "else { \$rc = 0; }\n";

    eval($comp);

    $tags_eval_cache{$saved_tags} = $rc;
    if ($rc == 0)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

sub parse_xml_log
{
    my $download_path = $_[0];
    my $log = $_[1];
    my $is_compromised = $_[2];
    my @cur_path;
    my $cur_path_str = "";
    my $cur_iter;
    my $cur_tags;
    my $cur_ts;
    my $skip_test = 0;
    my $fixed_log_path = fix_html_log_path($download_path);

    my $date_parser = new Date::Manip::Date;
    my $first_date = 1;

    if ($verbose)
    {
        print "Processing XML log from $download_path\n";
    }

    get_timestamp('process', 'start');

    open FILE, $log or return -1;

    my $k = 0;

    while (<FILE>)
    {
        my $line = $_;
        my $rc;

        $k++;

        if ($line =~ /<msg.* user="TRC tags".*>(.*?)<\/msg>/)
        {
            my $tags = $1;

            $cur_tags = $tags;
            if (defined($tag_expr))
            {
                if (match_tags($tags, $tag_expr) == 0)
                {
                    if ($verbose)
                    {
                        print "Skipping XML log\n";
                    }
                    last;
                }
            }
        }
        elsif ($line =~ /<start-ts>(.*)<\/start-ts>/)
        {
            $cur_ts = $1;
        }
        elsif ($line =~ /<pkg.*name="([^\s]*?)".*>/)
        {
            push(@cur_path, $1);
        }
        elsif ($line =~ /<test\s+.*name="([^\s]*?)".*/)
        {
            my $tin = "0";
            my $result = "";
            my $err = "";
            my $found = 0;

            push(@cur_path, $1);
            $cur_path_str = join("/", @cur_path);

            if ($line =~ /\s+result="([^\s]*?)"/)
            {
                $result = $1;
            }

            if ($line =~ /\s+err="(.*?)"/)
            {
                $err = $1;
            }

            if ($with_err_only > 0 && length($err) == 0)
            {
                $skip_test = 1;
                next;
            }

            foreach my $test_path (keys %tests_filter)
            {
                if (match_test_paths($test_path, $cur_path_str))
                {
                    $found = 1;
                    last;
                }
            }
            $found = 1 if (scalar(keys %tests_filter) == 0);

            if (!$found)
            {
                $skip_test = 1;
            }
            else
            {
                my $date = "";
                my $timestamp;
                my %hashes = ();

                $skip_test = 0;
                if ($line =~ /<test.*tin="([0-9]*)".*>/)
                {
                    $tin = $1;
                }

                if ($line =~ /<test.*hash="([^\s]*)".*>/)
                {
                    $hashes{$1} = 1;
                }

                if ($fixed_log_path =~
                            /.*([0-9]{2}[.][0-9]{2}[.][0-9]{2}).*/)
                {
                    $date = $1." ".$cur_ts;
                }

                $date_parser->parse_format("%y\\.%m\\.%d %H\\:%M\\:%S",
                                           $date);
                $timestamp = $date_parser->printf("%s") + 0;

                if ($first_date == 1 && $date_parser->cmp($last_log_date) > 0)
                {
                    $last_log_date->parse($date_parser->printf("%Y.%m.%d"));
                }
                $first_date = 0;

                $cur_iter = { results => [ { 
                                  result => $result, err => $err,
                                  verdicts => [],
                                  logs => [ {
                                    log => remove_extra_slashes(
                                              $fixed_log_path.
                                              "/html/node_".$tin.".html"),
                                    tags => $cur_tags,
                                    date => $date,
                                    timestamp => $timestamp,
                                    compromised => $is_compromised } ]
                              } ],
                              hashes => \%hashes,
                              params => {} };
            }
        }
        elsif (!$skip_test &&
               $line =~ /<param.*name="([^\s]*)".*value="(.*)".*>/)
        {
            if (defined($cur_iter))
            {
                $cur_iter->{"params"}->{$1} = $2;
            }
        }
        elsif (!$skip_test &&
               $line =~ /<verdict>(.*)<\/verdict>/)
        {
            if (defined($cur_iter))
            {
                push (@{$cur_iter->{results}->[0]->{"verdicts"}}, $1);
            }
        }
        elsif ($line =~ /<\/pkg>/ || $line =~ /<\/test>/)
        {
            pop @cur_path;

            if (!$skip_test && $line =~ /<\/test>/)
            {
                if (defined($cur_iter))
                {
                    night_results_add_iter($cur_path_str, $cur_iter);
                    $cur_iter = undef;
                }
            }
        }
    }

    close FILE;

    $one_xml_log_parsed = 1;
    get_timestamp('process', 'end');
}

sub process_logs
{
    my $start_date = $_[0];
    my $end_date = $_[1];
    my $log_path = $_[2];
    my @cur_logs = ();
    my $s;
    my $folder_name;

    if ($log_path =~ /^(.*)([0-9]{2}[.][0-9]{2}-.*)$/)
    {
        @cur_logs = ( $2 );
        $log_path = $1;
    }
    else
    {
        if ($log_path =~ /^[^\/]*:/)
        {
            @cur_logs = `curl -L -s -u : --negotiate $log_path`;
        }
        else
        {
            @cur_logs = `ls -F --format=single-column $log_path`;
        }
    }

    foreach $s (@cur_logs)
    {
        if ($s =~ /src="\/icons\/folder.gif".*<a.*href="(.*)"/ ||
            $s =~ /([0-9]{2}[.][0-9]{2}-.*$)/ ||
            $s =~ /^([0-9]{2}[.][0-9]{2}[\/]?)\s*$/ ||
            $s =~ /^(session_[0-9]{2}[.][0-9]{2}[.][0-9]{2}[\/]?)$/)
        {
            my $log_date = new Date::Manip::Date;

            $folder_name = $1;
            if ($folder_name =~
                 /([0-9]{2}[.][0-9]{2}-)/)
            {
#                $log_date->parse_format("%y\\.%m\\.%d\\-%H\\.%M", $1);

#                if ($log_date->cmp($start_date) >= 0 &&
#                    $log_date->cmp($end_date) <= 0)
#                {
                my $download_path =
                      remove_extra_slashes($log_path."/".$folder_name);
                my $is_compromised;
                my $rc;

                if ($folder_name =~ /([0-9]{2}[.][0-9]{2}[.][0-9]{2})/)
                {
                    my $date_str = $1;

                    $log_date->parse_format("%y\\.%m\\.%d", $date_str);
                    next if $log_date->cmp($end_date) > 0;
                    $log_date->parse_format("%y\\.%m\\.%d",
                                            "$date_str 23:59:59");
                    next if $log_date->cmp($start_date) < 0;
                }

                next if (defined($loaded_logs->{$download_path}));

                print "downloading from $download_path \n";
                ($rc, $is_compromised) =
                          download_prepare_log($download_path);
                if ($rc != 0)
                {
                    if ($is_compromised)
                    {
                        print "Skipped because of ".
                              "compromised log\n";
                    }
                    else
                    {
                        print "Failed to retrieve log\n";
                        $loaded_logs->{$download_path} = 2;
                    }
                }
                else
                {
                    my $xml_log_fn = $tmp_files[$#tmp_files];

                    $loaded_logs->{$download_path} = 1;
                    parse_xml_log($download_path, $xml_log_fn,
                                  $is_compromised);
                    free_tmp_files();
                }
#                }
            }
            else
            {
                if ($folder_name =~ /([0-9]{2}[.][0-9]{2})/)
                {
                    $log_date->parse_format("%y\\.%m\\.%d", $1.".01");
                    next if $log_date->cmp($end_date) > 0;
                    $log_date->parse($log_date->printf("last day of %B %Y\n"));
                    next if $log_date->cmp($start_date) < 0;
                }
                if ($folder_name =~ /(session_[0-9]{2}[.][0-9]{2}[.][0-9]{2})/)
                {
                    $log_date->parse_format("%y\\.%m\\.%d", $1);
                    next if $log_date->cmp($end_date) > 0;
                    next if $log_date->cmp($start_date) < 0;
                }
                if (!($folder_name =~ /(\.\.\/)/))
                {
                    process_logs($start_date, $end_date,
                                 $log_path."/".$folder_name);
                }
            }
        }
    }
}

foreach my $arg (@ARGV)
{
    if ($arg =~ m/^--verbose$/ || $arg =~ m/^-v$/)

    {
        $verbose = 1;
    }
    elsif ($arg =~ m/^--from=(.*)$/ || $arg =~ m/^-f(.*)$/)
    {
        $date_from = new Date::Manip::Date;
        $date_from->parse($1);
        $date_from->set("time", [0, 0, 0]);
    }
    elsif ($arg =~ m/^--to=(.*)$/ || $arg =~ m/^-t(.*)$/)
    {
        $date_to = new Date::Manip::Date;
        $date_to->parse($1);
        $date_to->set("time", [23, 59, 59]);
    }
    elsif ($arg =~ m/^--include-compromised$/)

    {
        $include_compromised = 1;
    }
    elsif ($arg =~ m/^--with-err-only$/)

    {
        $with_err_only = 1;
    }
    elsif ($arg =~ m/^--update-cache=(.*)$/)

    {
        $update_cache_path = $1."/";
    }
    elsif ($arg =~ m/^--cached-logs=(.*)$/)
    {
        $cached_logs_path = $1."/";
    }
    elsif ($arg =~ m/^--default-cache$/)
    {
        $cached_logs_path = $default_cache_path;
    }
    elsif ($arg =~ m/^--local-logs=(.*)$/ || $arg =~ m/^--local-logs$/)
    {
        my $tmp = $1;

        $use_remote_path = 0;

        if (defined($tmp) && length($tmp) > 0)
        {
            if (!($tmp =~ /^file:\/\//))
            {
                $tmp = "/home/tester-l5/$tester_logs_dir/night-testing/".$tmp;
            }
            else
            {
                $tmp =~ s/^file://;
            }

            push(@log_paths, $tmp);
        }
    }
    elsif ($arg =~ m/^--log-path=(.*)$/ || $arg =~ m/^-l(.*)$/)
    {
        my $tmp = $1;

        $use_remote_path = 1;

        if (defined($tmp) && length($tmp) > 0)
        {
            if (!($tmp =~ /^http[s]?:\/\//))
            {
                $tmp = "https://oktetlabs.ru/~tester-l5/night-testing/".$tmp;
            }
            push(@log_paths, $tmp);
        }
    }
    elsif ($arg =~ m/^--out-file=(.*)$/)
    {
        $night_results_fn = $1;
    }
    elsif ($arg =~ m/^--test=(.*)$/)
    {
        my $def = $1;
        my $path;
        my $hash;

        if ($def =~ m/(.*?)%(.*)/)
        {
            $path = $1;
            $hash = $2;

            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];
            $tests_filter{$path}->{"hash"} = $hash;
        }
        elsif ($def =~ m/(.*?):(.*)/)
        {
            my $params;
            my $params_hash = {};

            $path = $1;
            $params = $2;

            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];

            $params = $params.",";
            while ($params =~ /^([^,]+?)=\[(.+?)\],/ ||
                   $params =~ /^([^,]+?)=(.+?),/)
            {
                my $p_name = $1;
                my $p_value = $2;

                $params =~ s/^$p_name=\[?$p_value\]?,//;
                $p_value =~ s/\\([\[\]])/$1/g;
                $p_value =~ s/'/&apos;/g;

                $params_hash->{$p_name} = $p_value;
            }

            push(@{$tests_filter{$path}->{"params"}}, $params_hash);
        }
        else
        {
            $path = $def;
            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];
        }
    }
    elsif ($arg =~ m/^--tag-expr=(.*)$/)
    {
        $tag_expr = $1;
        $tag_expr =~ s/[.-]/_/g;
        $tag_expr =~ s/([^a-zA-Z_0-9])([a-zA-Z])/$1\$$2/g;
        $tag_expr =~ s/^([a-zA-Z])/\$$1/g;
        $tag_expr =~ s/&/ && /g;
        $tag_expr =~ s/\|/ || /g;
    }
    elsif ($arg =~ m/^--benchmarks$/)
    {
        $benchmarks = 1;
    }
    elsif ($arg =~ m/^--help$/ || $arg =~ m/^-h$/)
    {
        print "Getting all test results from night testing logs\n".
              "--from=, -f              From which date to load\n".
              "--to=, -t                To which date to load\n".
              "--log-path=, -l          From where to load logs\n".
              "--local-logs[=]          Get logs from tester-l5 home\n".
              "--cached-logs[=]         Get logs from Perl cache\n".
              "--update-cache=          Update cached results\n".
              "--out-file=              Where to save testing results\n".
              "--test=                  Test path (may be with parameters)\n".
              "--tag-expr=              Tag expression (to filter logs)\n".
              "--include-compromised    Include results from broken night logs\n".
              "--with-err-only          Show only results with some error\n".
              "--benchmarks             Collect data on script performance\n".
              "--verbose, -v            Log performed operations\n".
              "--help, -h               Display this message\n";
        exit(0);
    }
}

if (scalar(@log_paths) == 0)
{
    if ($use_remote_path == 0)
    {
        push(@log_paths,
             "/home/tester-l5/$tester_logs_dir/".
             "night-testing/Linux-v5_tot/");
    }
    else
    {
        push(@log_paths,
             "https://oktetlabs.ru/~tester-l5/".
             "night-testing/Linux-v5_tot/");
    }
}

sub cleanup
{ 
    free_tmp_files; 
}

sub filter_test_iters
{
    my $test_path = $_[0];
    my $test = $_[1];
    my $to_timestamp = $date_to->printf("%s") + 0;
    my $from_timestamp = $date_from->printf("%s") + 0;
    my $filtered_iters = {};
    my $iter;

    if (!defined($test))
    {
        return undef;
    }

    while ((undef, $iter) = each %{$test->{"iters"}})
    {
        my @filtered_results = ();

        next if (match_iter_params($test_path, $iter) == 0);
        foreach my $result (@{$iter->{"results"}})
        {
            my @filtered_logs = ();

            next if ($with_err_only > 0 &&
                     (!defined($result->{"err"}) ||
                       length($result->{"err"}) == 0));

            foreach my $log (@{$result->{"logs"}})
            {
                next if ($to_timestamp < $log->{"timestamp"});
                next if ($from_timestamp > $log->{"timestamp"});
                next if ($include_compromised == 0 &&
                         ((defined($log->{"compromised"}) &&
                           $log->{"compromised"} > 0) ||
                           log_in_compromised($log->{"log"})));
                next if match_tags($log->{"tags"}, $tag_expr) == 0;

                push(@filtered_logs, $log);
            }

            if (scalar(@filtered_logs) > 0)
            {
                my $filtered_result = $result;

                $filtered_result->{"logs"} = \@filtered_logs;
                push(@filtered_results, $filtered_result);
            }
        }

        if (scalar(@filtered_results) > 0)
        {
            my $filtered_iter = $iter;

            $filtered_iter->{"results"} = \@filtered_results;
            $filtered_iters->{hash2str($filtered_iter->{"params"})} =
                                                          $filtered_iter;
        }
    }

    if (scalar(keys %{$filtered_iters}) > 0)
    {
        $test->{"iters"} = $filtered_iters;
        return $test;
    }

    return undef;
}

my $secs_in_month = 60 * 60 * 24 * 30;

my $first_loaded_cache_index;

sub test_path2file_name
{
    my $test_path = $_[0];
    my $file_name;

    $file_name = $test_path;
    $file_name =~ s/^\///;
    $file_name =~ s/\/$//;
    $file_name =~ s/\//./g;

    return $file_name;
}

sub load_test_cache
{
    my $test_path = $_[0];
    my $test_cache_path = $_[1];
    my $filter_iters = $_[2];
    my $test_cache;
    my $file_name;

    my $timestamp_start = $date_from->printf("%s") + 0;
    my $timestamp_end = $date_to->printf("%s") + 0;

    $timestamp_start = floor($timestamp_start / $secs_in_month);
    $timestamp_end = floor($timestamp_end / $secs_in_month);

    $first_loaded_cache_index = $timestamp_start;

    $file_name = test_path2file_name($test_path);

    for (my $i = $timestamp_start; $i <= $timestamp_end; $i++)
    {
        my $file_path;

        $file_path = $test_cache_path."/$i/$file_name";
        if (-e $file_path)
        {
            my $tmp = retrieve($file_path);
            if ($filter_iters > 0)
            {
                $tmp = filter_test_iters($test_path, $tmp);
            }
            if (!defined($test_cache))
            {
                $test_cache = $tmp;
            }
            elsif (defined($tmp))
            {
                my $iter;

                while ((undef, $iter) = each %{$tmp->{"iters"}})
                {
                    test_add_iter($test_cache, $iter);
                }
            }
        }
    }

    return $test_cache;
}

sub stored_caches_add_iter_result
{
    my $caches = $_[0];
    my $cache_index = $_[1];
    my $iter = $_[2];
    my $result = $_[3];

    my $iter_copy = {};

    $iter_copy->{"params"} = $iter->{"params"};
    $iter_copy->{"hashes"} = $iter->{"hashes"};
    $iter_copy->{"results"} = [ $result ];

    if (!defined($caches->{$cache_index}))
    {
        $caches->{$cache_index} = { iters =>
            { hash2str($iter_copy->{"params"}) =>
                                      dclone($iter_copy) } };
    }
    else
    {
        test_add_iter($caches->{$cache_index}, $iter_copy);
    }
}

sub store_test_cache
{
    my $test_cache = $_[0];
    my $test_path = $_[1];
    my $path = $_[2];
    my %caches = ();
    my $iter;
    my $file_name;

    while ((undef, $iter) = each %{$test_cache->{"iters"}})
    {
        foreach my $result (@{$iter->{"results"}})
        {
            my $result_copy;
            my $prev_index;
            my $cur_index;

            $result_copy = dclone($result);
            $result_copy->{"logs"} = [];

            for (my $i = 0; $i < scalar(@{$result->{"logs"}}); $i++)
            {
                my $log = $result->{"logs"}->[$i];
                
                $cur_index = floor($log->{"timestamp"} / $secs_in_month);

                if (defined($prev_index) && $prev_index != $cur_index)
                {
                    stored_caches_add_iter_result(\%caches, $prev_index,
                                                  $iter, $result_copy);

                    $result_copy = dclone($result);
                    $result_copy->{"logs"} = [];
                }

                push(@{$result_copy->{"logs"}}, $log);
                $prev_index = $cur_index;
            }

            if (scalar(@{$result_copy->{"logs"}}) > 0)
            {
                stored_caches_add_iter_result(\%caches, $cur_index,
                                              $iter, $result_copy);
            }
        }
    }

    $file_name = test_path2file_name($test_path);

    foreach my $cache_index (sort {$a <=> $b} (keys %caches))
    {
        if (defined($first_loaded_cache_index) &&
            $cache_index < $first_loaded_cache_index)
        {
            print "WARNING: Writing into cache which was ".
                  "too early to be loaded\n";
        }
        `mkdir -p $path/$cache_index/`;
        nstore($caches{$cache_index},
               $path."/$cache_index/$file_name.tmp") or
             die "Failed to save test cache in file";
        `mv $path/$cache_index/$file_name.tmp $path/$cache_index/$file_name`;
    }
}

#Remove duplicates from tags list
my %fixed_tags_cache = ();
sub fix_tags
{
    my $tags = $_[0];
    my %tags_hash = ();
    my %tags_noval = ();
    my $tags_fixed = "";
    my $saved_tags = $tags;

    if (defined($fixed_tags_cache{$tags}))
    {
        return $fixed_tags_cache{$tags};
    }

    $tags =~ s/^\s*//;
    while ($tags =~ /^([^\s]+)\s*/)
    {
        my $tag = $1;

        if ($tag =~ /(.+):(.+)/)
        {
            my $tag_name;
            my $tag_value;

            $tag_name = $1;
            $tag_value = $2;

            $tags_hash{$tag_name} = $tag_value;
        }
        else
        {
            $tags_hash{$tag} = 1;
            $tags_noval{$tag} = 1;
        }

        $tags =~ s/^([^\s]+)\s*//;
    }

    foreach my $tag (sort(keys %tags_hash))
    {
        if (length($tags_fixed) > 0)
        {
            $tags_fixed .= " ";
        }
        if (defined($tags_noval{$tag}))
        {
            $tags_fixed .= $tag;
        }
        else
        {
            $tags_fixed .= $tag.":".$tags_hash{$tag};
        }
    }

    $fixed_tags_cache{$saved_tags} = $tags_fixed;
    return $tags_fixed;
}

$SIG{USR1} = $SIG{INT} =  sub { print "Interrupted!\n"; cleanup; exit 1; };

print "Processing night testing logs...\n";

if (defined($update_cache_path) &&
    length($update_cache_path) > 0)
{
    my $loaded_logs_fn = $update_cache_path."/"."loaded_logs";
    if (-e $loaded_logs_fn)
    {
        $loaded_logs = retrieve($loaded_logs_fn);
    }

    if (!defined($date_from))
    {
        my $cache_last_log_date_f = $update_cache_path."/last_log_date";
        if (-e $cache_last_log_date_f)
        {
            $date_from = new Date::Manip::Date;
            $date_from->parse(`cat $cache_last_log_date_f`);
            print "Using ".$date_from->printf("%Y.%m.%d").
                  " as start date\n";
        }
    }

    if (!defined($date_to))
    {
        $date_to = new Date::Manip::Date;
        $date_to->parse("today 23:59:59");
        print "Using ".$date_to->printf("%Y.%m.%d").
              " as end date\n";
    }
}

if (defined($date_from))
{
    $last_log_date->parse($date_from->printf("%Y.%m.%d"));
}
else
{
    $last_log_date->parse("1970.01.01");
}


if (defined($cached_logs_path) && length($cached_logs_path) > 0)
{
    my @cache_files = `ls -1 $cached_logs_path`;
    my $loaded_logs_fn = $cached_logs_path."/"."loaded_logs";
    if (-e $loaded_logs_fn)
    {
        $loaded_logs = retrieve($loaded_logs_fn);
    }

    if (-e $cached_logs_path."/compromised_logs")
    {
        my @compr_logs = `cat $cached_logs_path/compromised_logs`;

        foreach my $compr_log (@compr_logs)
        {
            $compr_log =~ s/\s*$//;
            $compr_log =~ s/^\s*//;
            if (length($compr_log) > 0)
            {
                $compromised_logs{$compr_log} = 1;
            }
        }
    }

    foreach my $path (keys %tests_filter)
    {
        my $test_cache;
        my $secs;

        $test_cache = load_test_cache($path,
                                      $cached_logs_path,
                                      1);
        if (defined($test_cache))
        {
            $night_results{"tests"}->{$path} = $test_cache;
        }
    }

    $date_from = new Date::Manip::Date;
    $date_from->parse(`cat $cached_logs_path/last_log_date`);
}

if (defined($date_from) && defined($date_to) &&
    $date_from->cmp($date_to) <= 0)
{
    foreach my $path (@log_paths)
    {
        get_timestamp('process', 'start');
        process_logs($date_from, $date_to, $path);
        get_timestamp('process', 'end');
    }
}

if (defined($update_cache_path) &&
    length($update_cache_path) > 0)
{
    if ($one_xml_log_parsed == 0)
    {
        nstore($loaded_logs, $update_cache_path."/loaded_logs");
        print "Cache is up to date\n";
        exit(0);
    }

    foreach my $test (keys %{$night_results{"tests"}})
    {
        my $test_cache;

        $test_cache = load_test_cache($test, $update_cache_path, 0);
        if (defined($test_cache))
        {
            my $iter;

            print "Updating existing cache for $test...\n";
            while ((undef, $iter) =
                    each %{$night_results{"tests"}->{$test}->{"iters"}})
            {
                test_add_iter($test_cache, $iter);
            }

            store_test_cache($test_cache, $test, $update_cache_path);
        }
        else
        {
            print "Caching results for $test...\n";
            store_test_cache($night_results{"tests"}->{$test},
                             $test,
                             $update_cache_path);
        }
    }

    my $cache_last_log_date_f = $update_cache_path."/last_log_date";
    my $last_log_date_str = $last_log_date->printf("%Y.%m.%d");
    `echo $last_log_date_str >$cache_last_log_date_f`;

    nstore($loaded_logs, $update_cache_path."/loaded_logs");

    exit(0);
}

open FILE, ">", $night_results_fn or return -1;

print FILE "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n";
print FILE "<html>\n";

print FILE "<head>\n";
print FILE "<meta http-equiv=\"content-type\" ".
            "content=\"text/html; charset=utf-8\">\n";
print FILE "<title>Results from night testing logs</title>";
print FILE "<style type=\"text/css\">\n";
print FILE ".test_name { font-weight: bold;}\n";

print FILE <<EOT;
    #TestLog {
        position: absolute;
        visibility: hidden;
        font-size: small;
        overflow: auto;
        width: 75%;
        height: 80%;
        left: 120px;
        top: 100px;
        background-color: #ffffe0;
        border: 1px solid #000000;
        padding: 10px;
    }
    #close {
        float: right;
    }
EOT

print FILE "</style>\n";

print FILE <<EOT;
<script type="text/javascript">
    function centerStats(obj,pos)
    {
        var scrolled_x, scrolled_y;
        if (self.pageYOffset)
        {
            scrolled_x = self.pageXOffset;
            scrolled_y = self.pageYOffset;
        }
        else if (document.documentElement &&
                 document.documentElement.scrollTop)
        {
            scrolled_x = document.documentElement.scrollLeft;
            scrolled_y = document.documentElement.scrollTop;
        }
        else if (document.body)
        {
            scrolled_x = document.body.scrollLeft;
            scrolled_y = document.body.scrollTop;
        }

        var center_x, center_y;
        if (self.innerHeight)
        {
            center_x = self.innerWidth;
            center_y = self.innerHeight;
        }
        else if (document.documentElement &&
                 document.documentElement.clientHeight)
        {
            center_x = document.documentElement.clientWidth;
            center_y = document.documentElement.clientHeight;
        }
        else if (document.body)
        {
            center_x = document.body.clientWidth;
            center_y = document.body.clientHeight;
        }

        if (pos == 'right')
            var leftOffset = scrolled_x +
                             (center_x - obj.offsetWidth) - 20;
        else
            var leftOffset = scrolled_x +
                             (center_x - obj.offsetWidth) / 2;

        var topOffset = scrolled_y +
                        (center_y - obj.offsetHeight) / 2;

        obj.style.top = topOffset + 'px';
        obj.style.left = leftOffset + 'px';
    }

    function hideObject(obj_name)
    {
        var obj = document.getElementById(obj_name);
        if (typeof obj == 'undefined')
            alert('Failed to get object ' + obj_name);

        obj.style.visibility = "hidden";
        document.prev_tip = '';
    }

    function hidePopups()
    {
        hideObject('TestLog');
    }

    function doNothing(ev)
    {
        ev = ev ? ev : window.event;
        ev.cancelBubble = true;
        if (ev.stopPropagation)
        {
            ev.stopPropagation();
        }
    }

    function showLog(name, url, event)
    {
        hidePopups();
        var obj = document.getElementById('TestLog');
        var innerHTML = '';
        innerHTML += '<span id="close"> ' +
                     '<a href="javascript:hidePopups();"' +
                     'style="text-decoration: none">' +
                     '<strong>[x]</strong></a></span>';
        innerHTML += '<div align="center"><b>Test: ' + name + '</b></div>';
        innerHTML += '<iframe name="Log" src="' + url + '" ' +
                     'style="width:100%; height:96%"/>';
        obj.innerHTML = innerHTML;
        centerStats(obj, 'right');
        obj.style.visibility = "visible";
        if (event)
            doNothing(event);
        return false;
    }
</script>
EOT

print FILE "</head>\n";

print FILE "<body>\n";

print FILE <<EOT;
    <div id="TestLog" onClick="doNothing(event);" onScroll="doNothing(event);">
      <span id="close"><a href="javascript:hidePopups()" style="text-decoration: none"><strong>[x]</strong></a></span>
      <p>Tests Log</p><br/>
    </div>
EOT

print FILE "<table border=1 cellpadding=4 cellspacing=3 ".
           "style=\"font-size:small;\">\n";
foreach my $test (keys %{$night_results{"tests"}})
{
    my $iter;

    print FILE "<tr>\n<td colspan=\"3\" class=\"test_name\">".
               $test."</td>\n</tr>\n";

    while ((undef, $iter) = each
              %{$night_results{"tests"}->{$test}->{"iters"}})
    {
        print FILE "<tr>\n<td>".$test."</td>\n";

        print FILE "<td>\n";
        foreach my $param (sort(keys %{$iter->{"params"}}))
        {
            my $param_val = $iter->{"params"}->{$param};
            my @val_strs = $param_val =~ m[.{1,100}]g;
            print FILE $param."=".join("<br>", @val_strs)."<br>\n";
        }
        print FILE "\n<br>Hash: ";
        if (defined($iter->{"hashes"}))
        {
            foreach my $hash (sort(keys %{$iter->{"hashes"}}))
            {
                print FILE $hash."<br>\n";
            }
        }
        print FILE "</td>\n";

        print FILE "<td>\n";
        print FILE "<table border=1 cellpadding=4 cellspacing=3 ".
                   "style=\"font-size:small;\">\n";
        foreach my $result (@{$iter->{"results"}})
        {
            my $err_present = 0;

            if (defined($result->{"err"}) && length($result->{"err"}) > 0)
            {
                $err_present = 1;
            }

            if ($err_present > 0 && $with_err_only == 0)
            {
                print FILE "<tr style=\"background-color:#ffdfdf\">\n";
            }
            else
            {
                print FILE "<tr>\n";
            }
            
            print FILE "<td>\n";

            if ($err_present > 0)
            {
                print FILE "<b>Error:</b> ".$result->{"err"}."<br>\n";
            }

            print FILE $result->{"result"}."<br>\n";
            if (scalar(@{$result->{"verdicts"}}) > 0)
            {
                print FILE "<br>\n";
                foreach my $verdict (@{$result->{"verdicts"}})
                {
                    print FILE $verdict."<br>\n";
                }
            }
            print FILE "</td>\n";

            print FILE "<td>\n";
            for (my $i = 0; $i < scalar(@{$result->{"logs"}}); $i++)
            {
                print FILE "<a href=\"".$result->{"logs"}->[$i]->{"log"}."\" ".
                           "onClick=\"showLog('$test', '".
                           $result->{"logs"}->[$i]->{"log"}."', event); ".
                           "return false;\" title=\"".
                           $result->{"logs"}->[$i]->{"date"}.": ".
                           fix_tags($result->{"logs"}->[$i]->{"tags"})."\"".
                           ">[".($i + 1)."]</a>";
                if ($i < scalar(@{$result->{"logs"}}) - 1)
                {
                    print FILE ", \n";
                }
            }
            print FILE "</td>\n";

            print FILE "</tr>\n";
        }
        print FILE "</table>\n";
        print FILE "</td>\n";

        print FILE "</tr>";
    }
}
print FILE "</table>\n";

print FILE "<p>Command used to generate this report:".
           join(" ", $0, @ARGV)."</p>\n";

print FILE "</body>\n";

print FILE "</html>\n";
close FILE;


