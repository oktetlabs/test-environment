#!/usr/bin/perl

use strict;
use warnings;
use Date::Manip;
use File::Temp qw/ tempfile /;
use IPC::Open2;
use File::Basename;
use Data::Dumper;
use English;
use Time::HiRes qw( time gettimeofday tv_interval );
use Storable qw/nstore retrieve dclone/;
use POSIX;
use HTML::Entities;

# Next comment is special, it will be changed to
# correct "use lib" when deploying.

#USE_LIB
use night_logs_cgi_aux::aux_funcs;

umask 0017;

my @tmp_files = ();
my $date_from;
my $date_to;
my $last_log_date = new Date::Manip::Date;
my @log_paths;
my $verbose = 0;
my $night_results_fn = "night_results.html";
my $tag_expr;
my $include_compromised = 0;
my $update_cache_path;
my $cached_logs_path;
my $benchmarks = 0;
my $with_err_only = 0;
my $iters_with_err_only = 0;
my $print_binary_report = 0;
my $group_logs_by_tags = 0;

my $loaded_logs = {};
my $one_xml_log_parsed = 0;

my $xml_log_def_name = "DEF_XML_LOG";

my %night_results = (
  tests => {},
);

my %tests_filter = ();

my %timestamps = (
    download => 0,
    unpack => 0,
    process => 0,
    fsize => 0,
    );

my $global_start = [gettimeofday];
my $start = 0;
my $end = 0;

# List of compromised logs stored in results cache
my %compromised_logs = ();

sub log_in_compromised
{
    my $log = $_[0];

    $log =~ s/\/html\/.*$/\//;
    $log =~ s/[\/]+/\//g;
    $log =~ s/^(.*):\//$1:\/\//;

    return defined($compromised_logs{$log});
}

sub get_timestamp
{
    use POSIX qw(strftime);
    my $cur_time = strftime "%a %b %e %H:%M:%S %Y", localtime;

    return if ($benchmarks == 0);

    # print sprintf("%s: %s %s\n", $cur_time, $_[0], $_[1]);

    if ($_[1] =~ 'start') 
    {
        $start = [gettimeofday];
    }
    else
    {
        $end = [gettimeofday];
    }

    $timestamps{$_[0]} += tv_interval($start);

    printf("Exectution time=%.2f =? (down=%.2f + unpack=%.2f + process=%.2f = %.2f) ; downloaded=%d\n",
           tv_interval($global_start),
           $timestamps{'download'},
           $timestamps{'unpack'},
           $timestamps{'process'}, 
           $timestamps{'download'} + $timestamps{'unpack'} + $timestamps{'process'},
           $timestamps{'fsize'}
        );
}

sub escape_str
{
    my $str = $_[0];
    $str =~ s/([\\"\$])/\\$1/g;
    return $str;
}

sub system_call
{
    my $cmd = $_[0];

    return system("trap \"kill -s 10 ".$PID."\" SIGINT ; ".$cmd);
}

sub download_log
{
    my $file_to_load = $_[0];
    my $file_to_save = $_[1];

    if ($file_to_load =~ m/https:\/\//)
    {
        return system_call("curl -L -s -u : --negotiate ".
                           $file_to_load." -f".
                           " -o ".$file_to_save);
    }
    else
    {
        return system_call("scp -q ".$file_to_load.
                           " ".$file_to_save);
    }
}

sub is_log_compromised
{
    my $path = $_[0];

    $path =~ s/[^\/]*$//;
    $path = $path."trc_compromised.js";

    if ($path =~ m/^(.*):/) # Protocol name, i.e. download from
    # remote location
    {
        (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");

        system_call("curl -L -s -u : --negotiate ".
                    $path." -f".
                    " -o ".$tmp_files[$#tmp_files]);
        if ((-s $tmp_files[$#tmp_files]) > 0)
        {
            return 1;
        }
    }
    else
    {
        if ( -e $path && (-s $path) > 0)
        {
            return 1;
        }
    }

    return 0;
}

sub download_prepare_log
{
    my $file_to_load = $_[0];
    my $is_compromised = 0;

    if ($verbose)
    {
        print "Download/Prepare $file_to_load\n";
    }

    my $log_name;
    my $file_name = "";

    $file_to_load =~ /.*\/([^\/]*)[\/]?\s*$/;
    $log_name = $1;
    $file_to_load =~ s/\s*$//;

    if ($file_to_load =~ m/\/$/)
    {
        $file_to_load = $file_to_load."$xml_log_def_name";
    }

    $is_compromised = is_log_compromised($file_to_load);
    if ($is_compromised > 0 && $include_compromised == 0)
    {
        return (-1, $is_compromised);
    }

    (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
    if ($file_to_load =~ m/^(.*):/) # Protocol name, i.e. download from
    # remote location
    {
        my $rc = 0;

        get_timestamp('download', 'start');
        $rc = download_log($file_to_load, $tmp_files[$#tmp_files]);

        if ($rc != 0)
        {
            warn "Failed to fetch XML log from $file_to_load";
            return (-1, 0);
        }

        get_timestamp('download', 'end');

        $timestamps{'fsize'} += (stat $tmp_files[$#tmp_files])[7];
        $file_name = $tmp_files[$#tmp_files];
    }
    else
    {
        $file_name = $file_to_load;
    }

    get_timestamp('unpack', 'start');

    (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
    if (system_call("cp ".escape_str($file_name)." ".
                    $tmp_files[$#tmp_files]) != 0)
    {
        warn "Failed to copy XML log";
        return (-1, 0);
    }
    $file_name = $tmp_files[$#tmp_files];

    if ($file_to_load =~ m/^(.*)[.]bz2\s*$/)
    {
        (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
        if (system_call("bzcat ".$file_name." > ".
                        $tmp_files[$#tmp_files]) != 0)
        {
            warn "Failed to unzip XML log";
            return (-1, 0);
        }
        $file_name = $tmp_files[$#tmp_files];
    }
    if ($file_to_load =~ m/^(.*)[.]xz\s*$/)
    {
        (undef, $tmp_files[$#tmp_files + 1]) = tempfile("log-XXXX");
        if (system_call("xz --decompress --keep --stdout ".$file_name." > ".
                        $tmp_files[$#tmp_files]) != 0)
        {
            warn "Failed to unzip XML log";
            return (-1, 0);
        }
        $file_name = $tmp_files[$#tmp_files];
    }

    if (system_call("tail ${file_name} | ".
                    "grep '</proteos:log_report>' >/dev/null") != 0)
    {
        print STDERR "Termination check failed\n";
        return (-1, 0);
    }

    get_timestamp('unpack', 'end');

    return (0, $is_compromised);
}

sub free_tmp_files
{
    system("rm -f ".join(" ", @tmp_files));
    @tmp_files = ();
}

sub compare_str_hashes
{
    my $hash1 = $_[0];
    my $hash2 = $_[1];

    for my $key (keys %$hash1)
    {
        return 0 if (defined($hash1->{$key}) != defined($hash2->{$key}) ||
                     $hash1->{$key} ne $hash2->{$key});
    }

    for my $key (keys %$hash2)
    {
        return 0 if (defined($hash1->{$key}) != defined($hash2->{$key}) ||
                     $hash1->{$key} ne $hash2->{$key});
    }

    return 1;
}

sub compare_str_arrays
{
    my $i = 0;
    my $arr1 = $_[0];
    my $arr2 = $_[1];

    return 0 if (scalar(@$arr1) != scalar(@$arr2));

    for ($i = 0; $i < scalar(@$arr1); $i++)
    {
        return 0 if ($arr1->[$i] ne $arr2->[$i]);
    }

    return 1;
}

sub match_test_paths
{
    my $path1 = $_[0];
    my $path2 = $_[1];

    my $path_reg = qr/$path1/;
    if ($path2 =~ /^[\/]?${path_reg}[\/]?$/)
    {
        return 1;
    }

    return 0;
}

sub match_params
{
    my $iter_params = $_[0];
    my $filter_params = $_[1];

    foreach my $name (keys %$filter_params)
    {
        return 0 if (!defined($iter_params->{$name}) ||
                     $iter_params->{$name} ne $filter_params->{$name});
    }

    return 1;
}

sub match_iter_params
{
    my $cur_path = $_[0];
    my $iter = $_[1];
    my $matched = 0;

    foreach my $test_path (keys %tests_filter)
    {
        next if (match_test_paths($test_path, $cur_path) == 0);

        if (defined($tests_filter{$test_path}->{"hash"}))
        {
            if (defined($iter->{"hashes"}) &&
                scalar(keys %{$iter->{"hashes"}}) > 0)
            {
                foreach my $hash (keys %{$iter->{"hashes"}})
                {
                    if ($tests_filter{$test_path}->{"hash"} eq $hash)
                    {
                        $matched = 1;
                        last;
                    }
                }
            }
            else
            {
                $matched = 1;
            }
        }
        else
        {
            foreach my $filter_params (@{$tests_filter{$test_path}->{"params"}})
            {
                if (match_params($iter->{"params"},
                                 $filter_params))
                {
                    $matched = 1;
                }
            }
            $matched = 1
                  if (scalar(@{$tests_filter{$test_path}->{"params"}}) == 0);
        }
    }
    $matched = 1 if (scalar(keys %tests_filter) == 0);

    return $matched;
}

sub hash2str
{
    my $hash = $_[0];
    my $str = "";

    foreach my $key (sort(keys %{$hash}))
    {
        $str .= $key." => ".$hash->{$key}."; ";
    }

    return $str;
}

sub result2str
{
    my $result = $_[0];
    my $str;

    if (defined($result->{"err"}) && length($result->{"err"}) > 0)
    {
        $str = "err => ".$result->{"err"}."; ";
    }
    $str .= $result->{"result"}."; ";
    $str .= "VERDICTS: ";

    foreach my $verdict (@{$result->{"verdicts"}})
    {
        $str .= $verdict."; ";
    }

    return $str;
}

sub test_add_iter
{
    my $test = $_[0];
    my $cur_iter = $_[1];
    my $iter_found = 0;

    my $iter_key;

    $iter_key = hash2str($cur_iter->{"params"});

    if (!defined($test->{"iters"}->{$iter_key}))
    {
        $test->{"iters"}->{$iter_key} = dclone($cur_iter);
    }
    else
    {
        my $iter = $test->{"iters"}->{$iter_key};

        if (defined($cur_iter->{"hashes"}))
        {
            foreach my $hash (keys %{$cur_iter->{"hashes"}})
            {
                $iter->{"hashes"}->{$hash} =
                              $cur_iter->{"hashes"}->{$hash};
            }
        }

        foreach my $cur_result (@{$cur_iter->{"results"}})
        {
            my $result_found = 0;

            foreach my $result (@{$iter->{"results"}})
            {
                if ($result->{"result"} eq
                      $cur_result->{"result"} &&
                    $result->{"err"} eq
                      $cur_result->{"err"} &&
                    compare_str_arrays(
                      $result->{"verdicts"},
                      $cur_result->{"verdicts"}))
                {
                    $result_found = 1;

                    if ($cur_result == $result)
                    {
                        die "Result duplication encountered which ".
                            "can lead to infinite loop\n";
                    }
                    foreach my $cur_log (@{$cur_result->{"logs"}})
                    {
                        push(@{$result->{"logs"}}, $cur_log)
                    }

                    last;
                }
            }

            if ($result_found == 0)
            {
                push(@{$iter->{"results"}},
                     dclone($cur_result));
            }
        }
    }
}

sub night_results_add_iter
{
    my $cur_path_str = $_[0];
    my $cur_iter = $_[1];
    my $matched = 0;

    $matched = match_iter_params($cur_path_str, $cur_iter);
    return if (!$matched);

    if (!$night_results{"tests"}->{$cur_path_str})
    {
        my $test_descr = { iters =>
            { hash2str($cur_iter->{"params"}) => dclone($cur_iter) } };

        $night_results{"tests"}->{$cur_path_str} = $test_descr;
    }
    else
    {
        test_add_iter($night_results{"tests"}->{$cur_path_str},
                      $cur_iter);
    }
}

sub remove_extra_slashes
{
    my $str = $_[0];

    $str =~ s/^\s*//;
    $str =~ s/\s*$//;
    $str =~ s/\/+/\//g;

    if ($str =~ /([^[:space:]]*):\/(.*)$/)
    {
        $str = $1."://".$2;
    }

    return $str;
}

# Caching already evaluated tags to speed up
# tag filtering
my %tags_eval_cache = ();

sub match_tags
{
    my $tags = $_[0];
    my $tag_expr = $_[1];
    my $comp = "";
    my $rc = 0;
    my %tag_names = ();
    my $tag_name;
    my $saved_tags;

    if (!defined($tag_expr) || length($tag_expr) == 0)
    {
        return 1;
    }

    if (defined($tags_eval_cache{$tags}))
    {
        return $tags_eval_cache{$tags};
    }

    $saved_tags = $tags;
    $tags =~ s/^\s*//;
    while ($tags =~ /^([^\s]+)\s*/)
    {
        my $tag = $1;

        $tag =~ s/[.-]/_/g;
        $tag =~ s/:/=/;

        $tag_name = $tag;
        $tag_name =~ s/=.*$//;
        $tag_names{$tag_name} = 1;

        if (!($tag =~ /=/))
        {
            $tag = $tag."=1";
        }

        $comp = $comp."\$$tag;\n ";

        $tags =~ s/^([^\s]+)\s*//;
    }

    foreach $tag_name (keys %tag_names)
    {
        $comp = "my \$$tag_name;\n".$comp;
    }

    $comp = $comp."\nif ($tag_expr) { \$rc = 1; } ".
            "else { \$rc = 0; }\n";

    eval($comp);

    $tags_eval_cache{$saved_tags} = $rc;
    if ($rc == 0)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

sub parse_xml_log
{
    my $download_path = $_[0];
    my $log = $_[1];
    my $is_compromised = $_[2];
    my @cur_path;
    my $cur_path_str = "";
    my $cur_iter;
    my $cur_tags;
    my $cur_ts;
    my $skip_test = 0;

    my $date_parser = new Date::Manip::Date;
    my $first_date = 1;

    if ($verbose)
    {
        print "Processing XML log from $download_path\n";
    }

    get_timestamp('process', 'start');

    open FILE, $log or return -1;

    my $k = 0;

    while (<FILE>)
    {
        my $line = $_;
        my $rc;

        $k++;

        if ($line =~ /<msg.* user="TRC tags".*>(.*?)<\/msg>/)
        {
            my $tags = $1;

            $cur_tags = $tags;
            if (defined($tag_expr))
            {
                if (match_tags($tags, $tag_expr) == 0)
                {
                    if ($verbose)
                    {
                        print "Skipping XML log\n";
                    }
                    last;
                }
            }
        }
        elsif ($line =~ /<start-ts>(.*)<\/start-ts>/)
        {
            $cur_ts = $1;
        }
        elsif ($line =~ /<pkg.*name="([^\s]*?)".*>/)
        {
            push(@cur_path, $1);
        }
        elsif ($line =~ /<test\s+.*name="([^\s]*?)".*/)
        {
            my $tin = "0";
            my $result = "";
            my $err = "";
            my $found = 0;

            push(@cur_path, $1);
            $cur_path_str = join("/", @cur_path);

            if ($line =~ /\s+result="([^\s]*?)"/)
            {
                $result = $1;
            }

            if ($line =~ /\s+err="(.*?)"/)
            {
                $err = $1;
            }

            if ($with_err_only > 0 && length($err) == 0)
            {
                $skip_test = 1;
                next;
            }

            foreach my $test_path (keys %tests_filter)
            {
                if (match_test_paths($test_path, $cur_path_str))
                {
                    $found = 1;
                    last;
                }
            }
            $found = 1 if (scalar(keys %tests_filter) == 0);

            if (!$found)
            {
                $skip_test = 1;
            }
            else
            {
                my $date = "";
                my $timestamp;
                my %hashes = ();

                $skip_test = 0;
                if ($line =~ /<test.*tin="([0-9]*)".*>/)
                {
                    $tin = $1;
                }

                if ($line =~ /<test.*hash="([^\s]*)".*>/)
                {
                    $hashes{$1} = 1;
                }

                if ($download_path =~
                            /.*([0-9]{2}[.][0-9]{2}[.][0-9]{2}).*/)
                {
                    $date = $1." ".$cur_ts;
                }

                $date_parser->parse_format("%y\\.%m\\.%d %H\\:%M\\:%S",
                                           $date);
                $timestamp = $date_parser->printf("%s") + 0;

                if ($first_date == 1 && $date_parser->cmp($last_log_date) > 0)
                {
                    $last_log_date->parse($date_parser->printf("%Y.%m.%d"));
                }
                $first_date = 0;

                $cur_iter = { results => [ { 
                                  result => $result, err => $err,
                                  verdicts => [],
                                  logs => [ {
                                    log => remove_extra_slashes(
                                              $download_path.
                                              "/html/node_".$tin.".html"),
                                    tags => $cur_tags,
                                    date => $date,
                                    timestamp => $timestamp,
                                    compromised => $is_compromised } ]
                              } ],
                              hashes => \%hashes,
                              params => {} };
            }
        }
        elsif (!$skip_test &&
               $line =~ /<param.*name="([^\s]*)".*value="(.*)".*>/)
        {
            if (defined($cur_iter))
            {
                $cur_iter->{"params"}->{$1} = $2;
            }
        }
        elsif (!$skip_test &&
               $line =~ /<verdict>(.*)<\/verdict>/)
        {
            if (defined($cur_iter))
            {
                push (@{$cur_iter->{results}->[0]->{"verdicts"}}, $1);
            }
        }
        elsif ($line =~ /<\/pkg>/ || $line =~ /<\/test>/)
        {
            pop @cur_path;

            if (!$skip_test && $line =~ /<\/test>/)
            {
                if (defined($cur_iter))
                {
                    night_results_add_iter($cur_path_str, $cur_iter);
                    $cur_iter = undef;
                }
            }
        }
    }

    close FILE;

    $one_xml_log_parsed = 1;
    get_timestamp('process', 'end');
}

sub process_logs
{
    my $start_date = $_[0];
    my $end_date = $_[1];
    my $log_path = $_[2];
    my @cur_logs = ();
    my $s;
    my $file_name;

    if ($log_path =~ /^[^\/]*:/)
    {
        @cur_logs = `curl -L -s -u : --negotiate $log_path`;
    }
    else
    {
        @cur_logs = `ls -F --format=single-column $log_path`;
    }

    foreach $s (@cur_logs)
    {
        if ($s =~ /run[.]log[.]txt/)
        {
            my $download_path = remove_extra_slashes("${log_path}/");
            my $is_compromised;
            my $rc;

            if (defined($loaded_logs->{$download_path}) &&
                $loaded_logs->{$download_path} == 1)
            {
                return;
            }

            print "downloading from $download_path \n";
            ($rc, $is_compromised) =
                      download_prepare_log($download_path);
            if ($rc != 0)
            {
                if ($is_compromised)
                {
                    print "Skipped because of ".
                          "compromised log\n";
                }
                else
                {
                    print "Failed to retrieve log\n";
                    $loaded_logs->{$download_path} = 2;
                }
            }
            else
            {
                my $xml_log_fn = $tmp_files[$#tmp_files];

                $loaded_logs->{$download_path} = 1;
                parse_xml_log($download_path, $xml_log_fn,
                              $is_compromised);
            }

            free_tmp_files();
            return;
        }
    }

    foreach $s (@cur_logs)
    {
        if ($s =~ /src="\/icons\/folder.gif".*<a.*href="(.*)"/)
        {
            my $log_date = new Date::Manip::Date;

            $file_name = $1;

            if ($file_name =~ /([0-9]{2}[.][0-9]{2}[.][0-9]{2})/)
            {
                my $date_str = $1;

                $log_date->parse_format("%y\\.%m\\.%d", $date_str);
                next if $log_date->cmp($end_date) > 0;
                $log_date->parse_format("%y\\.%m\\.%d",
                                        "$date_str 23:59:59");
                next if $log_date->cmp($start_date) < 0;
            }
            elsif ($file_name =~ /([0-9]{2}[.][0-9]{2})[\/]*\s*$/)
            {
                $log_date->parse_format("%y\\.%m\\.%d", $1.".01");
                next if $log_date->cmp($end_date) > 0;
                $log_date->parse($log_date->printf("last day of %B %Y\n"));
                next if $log_date->cmp($start_date) < 0;
            }

            if (!($file_name =~ /(\.\.\/)/))
            {
                process_logs($start_date, $end_date,
                             $log_path."/".$file_name);
            }
        }
    }
}

foreach my $arg (@ARGV)
{
    if ($arg =~ m/^--verbose$/ || $arg =~ m/^-v$/)

    {
        $verbose = 1;
    }
    elsif ($arg =~ m/^--from=(.*)$/ || $arg =~ m/^-f(.*)$/)
    {
        $date_from = new Date::Manip::Date;
        $date_from->parse($1);
        $date_from->set("time", [0, 0, 0]);
    }
    elsif ($arg =~ m/^--to=(.*)$/ || $arg =~ m/^-t(.*)$/)
    {
        $date_to = new Date::Manip::Date;
        $date_to->parse($1);
        $date_to->set("time", [23, 59, 59]);
    }
    elsif ($arg =~ m/^--include-compromised$/)

    {
        $include_compromised = 1;
    }
    elsif ($arg =~ m/^--with-err-only$/)

    {
        $with_err_only = 1;
    }
    elsif ($arg =~ m/^--iters-with-err-only$/)

    {
        $iters_with_err_only = 1;
    }
    elsif ($arg =~ m/^--update-cache=(.*)$/)

    {
        $update_cache_path = $1."/";
    }
    elsif ($arg =~ m/^--cached-logs=(.*)$/)
    {
        $cached_logs_path = $1."/";
    }
    elsif ($arg =~ m/^--log-path=(.*)$/ || $arg =~ m/^-l(.*)$/)
    {
        my $tmp = $1;

        if (defined($tmp) && length($tmp) > 0)
        {
            push(@log_paths, $tmp);
        }
    }
    elsif ($arg =~ m/^--out-file=(.*)$/)
    {
        $night_results_fn = $1;
    }
    elsif ($arg =~ m/^--test=(.*)$/)
    {
        my $def = $1;
        my $path;
        my $hash;

        if ($def =~ m/(.*?)%(.*)/)
        {
            $path = $1;
            $hash = $2;

            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];
            $tests_filter{$path}->{"hash"} = $hash;
        }
        elsif ($def =~ m/(.*?):(.*)/)
        {
            my $params;
            my $params_hash = {};

            $path = $1;
            $params = $2;

            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];

            $params = $params.",";
            while ($params =~ /^([^,]+?)=\[(.+?)\],/ ||
                   $params =~ /^([^,]+?)=(.+?),/)
            {
                my $p_name = $1;
                my $p_value = $2;

                $params =~ s/^$p_name=\[?$p_value\]?,//;
                $p_value =~ s/\\([\[\]])/$1/g;
                $p_value =~ s/'/&apos;/g;

                $params_hash->{$p_name} = $p_value;
            }

            push(@{$tests_filter{$path}->{"params"}}, $params_hash);
        }
        else
        {
            $path = $def;
            $tests_filter{$path} = {};
            $tests_filter{$path}->{"params"} = [];
        }
    }
    elsif ($arg =~ m/^--tag-expr=(.*)$/)
    {
        $tag_expr = $1;
        $tag_expr =~ s/[.-]/_/g;
        $tag_expr =~ s/([^a-zA-Z_0-9])([a-zA-Z])/$1\$$2/g;
        $tag_expr =~ s/^([a-zA-Z])/\$$1/g;
        $tag_expr =~ s/!\$([_a-zA-Z0-9]+)/!defined(\$tag_names{'$1'})/g;
        $tag_expr =~ s/&/ && /g;
        $tag_expr =~ s/\|/ || /g;
    }
    elsif ($arg =~ m/^--group-logs-by-tags$/)
    {
        $group_logs_by_tags = 1;
    }
    elsif ($arg =~ m/^--binary-report$/)
    {
        $print_binary_report = 1;
    }
    elsif ($arg =~ m/^--benchmarks$/)
    {
        $benchmarks = 1;
    }
    elsif ($arg =~ m/^--def-log-name=(.+)$/)
    {
        $xml_log_def_name = $1;
    }
    elsif ($arg =~ m/^--help$/ || $arg =~ m/^-h$/)
    {
        print "Getting all test results from night testing logs\n".
              "--from=, -f              From which date to load\n".
              "--to=, -t                To which date to load\n".
              "--log-path=, -l          From where to load logs\n".
              "--cached-logs[=]         Get logs from Perl cache\n".
              "--update-cache=          Update cached results\n".
              "--out-file=              Where to save testing results\n".
              "--test=                  Test path (may be with parameters)\n".
              "--tag-expr=              Tag expression (to filter logs)\n".
              "--include-compromised    Include results from broken night logs\n".
              "--with-err-only          Show only results with some error\n".
              "--iters-with-err-only    Show only iterations having some erroneous results\n".
              "--benchmarks             Collect data on script performance\n".
              "--def-log-name=          Filename of XML log\n".
              "                         (trc-log.bz2 by default)\n".
              "--group-logs-by-tags     Group logs by tags in HTML report\n".
              "--verbose, -v            Log performed operations\n".
              "--help, -h               Display this message\n";
        exit(0);
    }
}

sub cleanup
{ 
    free_tmp_files; 
}

$SIG{USR1} = $SIG{INT} =  sub { print "Interrupted!\n"; exit 1; };

END {
    cleanup;
}

my $compromised_iters;

sub iter_is_compromised
{
    my $iter_key = $_[0];
    my $result_str = $_[1];
    my $log = $_[2];

    if (!defined($compromised_iters))
    {
        $compromised_iters = get_compromised($cached_logs_path);
        if (!defined($compromised_iters))
        {
            return 0;
        }
    }

    if (defined($compromised_iters->{"iters"}) &&
        defined($compromised_iters->{"iters"}->{$iter_key}) &&
        defined($compromised_iters->{"iters"}->
                        {$iter_key}->{$result_str}) &&
        defined($compromised_iters->{"iters"}->
                {$iter_key}->{$result_str}->{$log->{"log"}}))
    {
        return 1;
    }

    return 0;
}

sub filter_test_iters
{
    my $test_path = $_[0];
    my $test = $_[1];
    my $to_timestamp = $date_to->printf("%s") + 0;
    my $from_timestamp = $date_from->printf("%s") + 0;
    my $filtered_iters = {};
    my $iter;
    my $iter_key;

    if (!defined($test))
    {
        return undef;
    }

    while (($iter_key, $iter) = each %{$test->{"iters"}})
    {
        my @filtered_results = ();

        next if (match_iter_params($test_path, $iter) == 0);
        foreach my $result (@{$iter->{"results"}})
        {
            my @filtered_logs = ();
            my $result_str;

            $result_str = result2str($result);

            next if ($with_err_only > 0 &&
                     (!defined($result->{"err"}) ||
                       length($result->{"err"}) == 0));

            foreach my $log (@{$result->{"logs"}})
            {
                next if ($to_timestamp < $log->{"timestamp"});
                next if ($from_timestamp > $log->{"timestamp"});
                next if ($include_compromised == 0 &&
                         ((defined($log->{"compromised"}) &&
                           $log->{"compromised"} > 0) ||
                           log_in_compromised($log->{"log"})));
                next if ($include_compromised == 0 &&
                         iter_is_compromised($iter_key, $result_str, $log));
                next if match_tags($log->{"tags"}, $tag_expr) == 0;

                push(@filtered_logs, $log);
            }

            if (scalar(@filtered_logs) > 0)
            {
                my $filtered_result = $result;

                $filtered_result->{"logs"} = \@filtered_logs;
                push(@filtered_results, $filtered_result);
            }
        }

        if (scalar(@filtered_results) > 0)
        {
            my $filtered_iter = $iter;

            $filtered_iter->{"results"} = \@filtered_results;
            $filtered_iters->{hash2str($filtered_iter->{"params"})} =
                                                          $filtered_iter;
        }
    }

    if (scalar(keys %{$filtered_iters}) > 0)
    {
        $test->{"iters"} = $filtered_iters;
        return $test;
    }

    return undef;
}

my $secs_in_month = 60 * 60 * 24 * 30;

my $first_loaded_cache_index;

sub test_path2file_name
{
    my $test_path = $_[0];
    my $file_name;

    $file_name = $test_path;
    $file_name =~ s/^\///;
    $file_name =~ s/\/$//;
    $file_name =~ s/\//./g;

    return $file_name;
}

sub load_test_cache
{
    my $test_path = $_[0];
    my $test_cache_path = $_[1];
    my $filter_iters = $_[2];
    my $test_cache;
    my $file_name;

    my $timestamp_start = $date_from->printf("%s") + 0;
    my $timestamp_end = $date_to->printf("%s") + 0;

    $timestamp_start = floor($timestamp_start / $secs_in_month);
    $timestamp_end = floor($timestamp_end / $secs_in_month);

    $first_loaded_cache_index = $timestamp_start;

    $file_name = test_path2file_name($test_path);

    for (my $i = $timestamp_start; $i <= $timestamp_end; $i++)
    {
        my $file_path;

        $file_path = $test_cache_path."/$i/$file_name";
        if (-e $file_path)
        {
            my $tmp = retrieve($file_path);
            if ($filter_iters > 0)
            {
                $tmp = filter_test_iters($test_path, $tmp);
            }
            if (!defined($test_cache))
            {
                $test_cache = $tmp;
            }
            elsif (defined($tmp))
            {
                my $iter;

                while ((undef, $iter) = each %{$tmp->{"iters"}})
                {
                    test_add_iter($test_cache, $iter);
                }
            }
        }
    }

    return $test_cache;
}

sub stored_caches_add_iter_result
{
    my $caches = $_[0];
    my $cache_index = $_[1];
    my $iter = $_[2];
    my $result = $_[3];

    my $iter_copy = {};

    $iter_copy->{"params"} = $iter->{"params"};
    $iter_copy->{"hashes"} = $iter->{"hashes"};
    $iter_copy->{"results"} = [ $result ];

    if (!defined($caches->{$cache_index}))
    {
        $caches->{$cache_index} = { iters =>
            { hash2str($iter_copy->{"params"}) =>
                                      dclone($iter_copy) } };
    }
    else
    {
        test_add_iter($caches->{$cache_index}, $iter_copy);
    }
}

sub store_test_cache
{
    my $test_cache = $_[0];
    my $test_path = $_[1];
    my $path = $_[2];
    my %caches = ();
    my $iter;
    my $file_name;

    while ((undef, $iter) = each %{$test_cache->{"iters"}})
    {
        foreach my $result (@{$iter->{"results"}})
        {
            my $result_copy;
            my $prev_index;
            my $cur_index;

            $result_copy = dclone($result);
            $result_copy->{"logs"} = [];

            for (my $i = 0; $i < scalar(@{$result->{"logs"}}); $i++)
            {
                my $log = $result->{"logs"}->[$i];
                
                $cur_index = floor($log->{"timestamp"} / $secs_in_month);

                if (defined($prev_index) && $prev_index != $cur_index)
                {
                    stored_caches_add_iter_result(\%caches, $prev_index,
                                                  $iter, $result_copy);

                    $result_copy = dclone($result);
                    $result_copy->{"logs"} = [];
                }

                push(@{$result_copy->{"logs"}}, $log);
                $prev_index = $cur_index;
            }

            if (scalar(@{$result_copy->{"logs"}}) > 0)
            {
                stored_caches_add_iter_result(\%caches, $cur_index,
                                              $iter, $result_copy);
            }
        }
    }

    $file_name = test_path2file_name($test_path);

    foreach my $cache_index (sort {$a <=> $b} (keys %caches))
    {
        if (defined($first_loaded_cache_index) &&
            $cache_index < $first_loaded_cache_index)
        {
            print "WARNING: Writing into cache which was ".
                  "too early to be loaded\n";
        }
        `mkdir -p $path/$cache_index/`;
        `chmod g+x $path/$cache_index/`;
        nstore($caches{$cache_index},
               $path."/$cache_index/$file_name.tmp") or
             die "Failed to save test cache in file";
        `mv $path/$cache_index/$file_name.tmp $path/$cache_index/$file_name`;
    }
}

#Remove duplicates from tags list
my %fixed_tags_cache = ();
sub fix_tags
{
    my $tags = $_[0];
    my %tags_hash = ();
    my %tags_noval = ();
    my $tags_fixed = "";
    my $saved_tags = $tags;

    if (defined($fixed_tags_cache{$tags}))
    {
        return $fixed_tags_cache{$tags};
    }

    $tags =~ s/^\s*//;
    while ($tags =~ /^([^\s]+)\s*/)
    {
        my $tag = $1;

        if ($tag =~ /(.+):(.+)/)
        {
            my $tag_name;
            my $tag_value;

            $tag_name = $1;
            $tag_value = $2;

            $tags_hash{$tag_name} = $tag_value;
        }
        else
        {
            $tags_hash{$tag} = 1;
            $tags_noval{$tag} = 1;
        }

        $tags =~ s/^([^\s]+)\s*//;
    }

    foreach my $tag (sort(keys %tags_hash))
    {
        if (length($tags_fixed) > 0)
        {
            $tags_fixed .= " ";
        }
        if (defined($tags_noval{$tag}))
        {
            $tags_fixed .= $tag;
        }
        else
        {
            $tags_fixed .= $tag.":".$tags_hash{$tag};
        }
    }

    $fixed_tags_cache{$saved_tags} = $tags_fixed;
    return $tags_fixed;
}

print "Processing night testing logs...\n";

if (defined($update_cache_path) &&
    length($update_cache_path) > 0)
{
    my $loaded_logs_fn = $update_cache_path."/"."loaded_logs";
    if (-e $loaded_logs_fn)
    {
        $loaded_logs = retrieve($loaded_logs_fn);
    }

    if (!defined($date_from))
    {
        my $cache_last_log_date_f = $update_cache_path."/last_log_date";
        if (-e $cache_last_log_date_f)
        {
            $date_from = new Date::Manip::Date;
            $date_from->parse(`cat $cache_last_log_date_f`);
            print "Using ".$date_from->printf("%Y.%m.%d").
                  " as start date\n";
        }
    }

    if (!defined($date_to))
    {
        $date_to = new Date::Manip::Date;
        $date_to->parse("today 23:59:59");
        print "Using ".$date_to->printf("%Y.%m.%d").
              " as end date\n";
    }
}

if (defined($date_from))
{
    $last_log_date->parse($date_from->printf("%Y.%m.%d"));
}
else
{
    $last_log_date->parse("1970.01.01");
}


if (defined($cached_logs_path) && length($cached_logs_path) > 0)
{
    my @cache_files = `ls -1 $cached_logs_path`;
    my $loaded_logs_fn = $cached_logs_path."/"."loaded_logs";
    if (-e $loaded_logs_fn)
    {
        $loaded_logs = retrieve($loaded_logs_fn);
    }

    if (-e $cached_logs_path."/compromised_logs")
    {
        my @compr_logs = `cat $cached_logs_path/compromised_logs`;

        foreach my $compr_log (@compr_logs)
        {
            $compr_log =~ s/\s*$//;
            $compr_log =~ s/^\s*//;
            if (length($compr_log) > 0)
            {
                $compromised_logs{$compr_log} = 1;
            }
        }
    }

    foreach my $path (keys %tests_filter)
    {
        my $test_cache;
        my $secs;

        $test_cache = load_test_cache($path,
                                      $cached_logs_path,
                                      1);
        if (defined($test_cache))
        {
            $night_results{"tests"}->{$path} = $test_cache;
        }
    }

    $date_from = new Date::Manip::Date;
    $date_from->parse(`cat $cached_logs_path/last_log_date`);
}

if (defined($date_from) && defined($date_to) &&
    $date_from->cmp($date_to) <= 0 &&
    !(defined($cached_logs_path) && !defined($update_cache_path)))
{
    foreach my $path (@log_paths)
    {
        get_timestamp('process', 'start');
        process_logs($date_from, $date_to, $path);
        get_timestamp('process', 'end');
    }
}

if (defined($update_cache_path) &&
    length($update_cache_path) > 0)
{
    if ($one_xml_log_parsed == 0)
    {
        nstore($loaded_logs, $update_cache_path."/loaded_logs");
        print "Cache is up to date\n";
        exit(0);
    }

    foreach my $test (keys %{$night_results{"tests"}})
    {
        my $test_cache;

        $test_cache = load_test_cache($test, $update_cache_path, 0);
        if (defined($test_cache))
        {
            my $iter;

            print "Updating existing cache for $test...\n";
            while ((undef, $iter) =
                    each %{$night_results{"tests"}->{$test}->{"iters"}})
            {
                test_add_iter($test_cache, $iter);
            }

            store_test_cache($test_cache, $test, $update_cache_path);
        }
        else
        {
            print "Caching results for $test...\n";
            store_test_cache($night_results{"tests"}->{$test},
                             $test,
                             $update_cache_path);
        }
    }

    my $date_inc = new Date::Manip::Delta;
    my $last_log_date_fixed;
    my $cache_last_log_date_f = $update_cache_path."/last_log_date";
    my $last_log_date_str;

    $date_inc->parse("- 2 day");
    $last_log_date_fixed = $date_inc->calc($last_log_date);
    $last_log_date_str = $last_log_date_fixed->printf("%Y.%m.%d");
    `echo $last_log_date_str >$cache_last_log_date_f`;

    nstore($loaded_logs, $update_cache_path."/loaded_logs");

    exit(0);
}

sub js_param_escape
{
    my $str = $_[0];

    $str =~ s/&/&amp;/g;
    $str =~ s/'/\\'/g;
    return $str;
}

sub tags2str
{
    my $tags = $_[0];

    return join(' ', sort(split(/\s+/, $tags)));
}

sub logs_group2html
{
    my $fh = $_[0];
    my $test = $_[1];
    my $logs = $_[2];

    for (my $i = 0; $i < scalar(@{$logs}); $i++)
    {
        print $fh "<a href=\"".$logs->[$i]->{"log"}."\" ".
                   "onClick=\"showLog('$test', '".
                   $logs->[$i]->{"log"}."', event); ".
                   "return false;\" title=\"".
                   $logs->[$i]->{"date"}.": ".
                   fix_tags($logs->[$i]->{"tags"})."\"".
                   ">[".($i + 1)."]</a>";
        if ($i < scalar(@{$logs}) - 1)
        {
            print $fh ", \n";
        }
    }
}

sub logs2html_aux
{
    my $fh = $_[0];
    my $test = $_[1];
    my $logs = $_[2];

    my $tags_str;
    my %logs_hash = ();

    if ($group_logs_by_tags > 0)
    {
        foreach my $log (@{$logs})
        {
            $tags_str = tags2str(fix_tags($log->{"tags"}));

            if (!defined($logs_hash{$tags_str}))
            {
                $logs_hash{$tags_str} = [ $log ];
            }
            else
            {
                push(@{$logs_hash{$tags_str}}, $log);
            }
        }

        print $fh "<table border=\"1\">\n";
        foreach $tags_str (sort(keys %logs_hash))
        {
            #my $tags_from_log = $logs_hash{$tags_str}->[0]->{"tags"};

            print $fh "<tr><td>${tags_str}</td>\n";
            print $fh "<td>\n";
            logs_group2html($fh, $test, $logs_hash{$tags_str});
            print $fh "</td>\n</tr>\n";
        }
        print $fh "</table>\n";
    }
    else
    {
        logs_group2html($fh, $test, $logs);
    }
}

sub logs2html
{
    my $fh = $_[0];
    my $test = $_[1];
    my $iter_key = $_[2];
    my $result_str = $_[3];
    my $logs = $_[4];
    my $compromised = $_[5];

    my $logs_str = "";
    my $compromise_arg;
    my $compromise_str;

    if ($compromised > 0)
    {
        $compromise_arg = 0;
        $compromise_str = "Uncompromise"
    }
    else
    {
        $compromise_arg = 1;
        $compromise_str = "Compromise"
    }

    logs2html_aux($fh, $test, $logs);

#    Temporary disabled.
#    for (my $i = 0; $i < scalar(@{$logs}); $i++)
#    {
#        if (length($logs_str) > 0)
#        {
#            $logs_str .= ",";
#        }
#        $logs_str .= $logs->[$i]->{"log"};
#    }
#
#    print $fh "<br>\n<input type=\"button\" value=\"$compromise_str\" ".
#              "onClick=\"compromiseIter(this, '".
#              js_param_escape($cached_logs_path)."', ".
#              "'".js_param_escape(${iter_key})."', ".
#              "'".js_param_escape($result_str)."', ".
#              "'".js_param_escape(${logs_str})."', $compromise_arg);\">";
}

my $err_result_color = "#ffdfdf";
my $compromised_iter_color = "#ff7777";

sub print_html_report
{
    my $fh = $_[0];

    print $fh "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n";
    print $fh "<html>\n";

    print $fh "<head>\n";
    print $fh "<meta http-equiv=\"content-type\" ".
                "content=\"text/html; charset=utf-8\">\n";
    print $fh "<title>Results from night testing logs</title>";
    print $fh "<style type=\"text/css\">\n";
    print $fh ".test_name { font-weight: bold;}\n";
    print $fh "td { vertical-align: top; }\n";

    print $fh <<EOT;
        #TestLog {
            position: absolute;
            visibility: hidden;
            font-size: small;
            overflow: auto;
            width: 75%;
            height: 80%;
            left: 120px;
            top: 100px;
            background-color: #ffffe0;
            border: 1px solid #000000;
            padding: 10px;
        }
        #close {
            float: right;
        }
EOT

    print $fh "</style>\n";

    print $fh <<EOT;
    <script type="text/javascript">
        function centerStats(obj,pos)
        {
            var scrolled_x, scrolled_y;
            if (self.pageYOffset)
            {
                scrolled_x = self.pageXOffset;
                scrolled_y = self.pageYOffset;
            }
            else if (document.documentElement &&
                     document.documentElement.scrollTop)
            {
                scrolled_x = document.documentElement.scrollLeft;
                scrolled_y = document.documentElement.scrollTop;
            }
            else if (document.body)
            {
                scrolled_x = document.body.scrollLeft;
                scrolled_y = document.body.scrollTop;
            }

            var center_x, center_y;
            if (self.innerHeight)
            {
                center_x = self.innerWidth;
                center_y = self.innerHeight;
            }
            else if (document.documentElement &&
                     document.documentElement.clientHeight)
            {
                center_x = document.documentElement.clientWidth;
                center_y = document.documentElement.clientHeight;
            }
            else if (document.body)
            {
                center_x = document.body.clientWidth;
                center_y = document.body.clientHeight;
            }

            if (pos == 'right')
                var leftOffset = scrolled_x +
                                 (center_x - obj.offsetWidth) - 20;
            else
                var leftOffset = scrolled_x +
                                 (center_x - obj.offsetWidth) / 2;

            var topOffset = scrolled_y +
                            (center_y - obj.offsetHeight) / 2;

            obj.style.top = topOffset + 'px';
            obj.style.left = leftOffset + 'px';
        }

        function hideObject(obj_name)
        {
            var obj = document.getElementById(obj_name);
            if (typeof obj == 'undefined')
                alert('Failed to get object ' + obj_name);

            obj.style.visibility = "hidden";
            document.prev_tip = '';
        }

        function hidePopups()
        {
            hideObject('TestLog');
        }

        function doNothing(ev)
        {
            ev = ev ? ev : window.event;
            ev.cancelBubble = true;
            if (ev.stopPropagation)
            {
                ev.stopPropagation();
            }
        }

        function showLog(name, url, event)
        {
            hidePopups();
            var obj = document.getElementById('TestLog');
            var innerHTML = '';
            innerHTML += '<span id="close"> ' +
                         '<a href="javascript:hidePopups();"' +
                         'style="text-decoration: none">' +
                         '<strong>[x]</strong></a></span>';
            innerHTML += '<div align="center"><b>Test: ' + name + '</b></div>';
            innerHTML += '<iframe name="Log" src="' + url + '" ' +
                         'style="width:100%; height:96%"/>';
            obj.innerHTML = innerHTML;
            centerStats(obj, 'right');
            obj.style.visibility = "visible";
            if (event)
                doNothing(event);
            return false;
        }

        function compromiseIter(button, cache_path, iter,
                                result, logs, compromise)
        {
            var xhr = new XMLHttpRequest();
            var params;
            var parent_bg_color;

            params = "cache_path=" + encodeURIComponent(cache_path) +
                     "&iter=" + encodeURIComponent(iter) +
                     "&result=" + encodeURIComponent(result) +
                     "&logs=" + encodeURIComponent(logs) +
                     "&compromise=" + compromise;

            xhr.open("POST", "/socktest/compromise.pl", false);
            xhr.setRequestHeader("Content-type",
                                 "application/x-www-form-urlencoded");
            xhr.send(params);

            if (compromise > 0)
            {
                compromise = 0;
                button.value = "Uncompromise";
                parent_bg_color = "$compromised_iter_color";
            }
            else
            {
                compromise = 1;
                button.value = "Compromise";
                parent_bg_color = "";
            }

            button.onclick = function() {
                                compromiseIter(button, cache_path, iter,
                                               result, logs, compromise); };
            button.parentElement.style.backgroundColor = parent_bg_color;
        }
    </script>
EOT

    print $fh "</head>\n";

    print $fh "<body>\n";

    print $fh <<EOT;
        <div id="TestLog" onClick="doNothing(event);" onScroll="doNothing(event);">
          <span id="close"><a href="javascript:hidePopups()" style="text-decoration: none"><strong>[x]</strong></a></span>
          <p>Tests Log</p><br/>
        </div>
EOT

    print $fh "<table border=1 cellpadding=4 cellspacing=3 ".
               "style=\"font-size:small;\">\n";
    foreach my $test (keys %{$night_results{"tests"}})
    {
        my $iter_key;
        my $iter;

        print $fh "<tr>\n<td colspan=\"3\" class=\"test_name\">".
                   $test."</td>\n</tr>\n";

        while (($iter_key, $iter) = each
                  %{$night_results{"tests"}->{$test}->{"iters"}})
        {
            if ($iters_with_err_only > 0)
            {
                my $err_encountered = 0;

                foreach my $result (@{$iter->{"results"}})
                {
                    if (defined($result->{"err"}) && length($result->{"err"}) > 0)
                    {
                        $err_encountered = 1;
                        last;
                    }
                }

                if ($err_encountered == 0)
                {
                    next;
                }
            }

            print $fh "<tr>\n<td>".$test."</td>\n";

            print $fh "<td>\n";
            foreach my $param (sort(keys %{$iter->{"params"}}))
            {
                my $param_val = $iter->{"params"}->{$param};
                my @val_strs = $param_val =~ m[.{1,100}]g;
                print $fh $param."=".join("<br>", @val_strs)."<br>\n";
            }
            print $fh "\n<br>Hash: ";
            if (defined($iter->{"hashes"}))
            {
                foreach my $hash (sort(keys %{$iter->{"hashes"}}))
                {
                    print $fh $hash."<br>\n";
                }
            }
            print $fh "</td>\n";

            print $fh "<td>\n";
            print $fh "<table border=1 cellpadding=4 cellspacing=3 ".
                       "style=\"font-size:small;\">\n";
            foreach my $result (@{$iter->{"results"}})
            {
                my $err_present = 0;

                if (defined($result->{"err"}) && length($result->{"err"}) > 0)
                {
                    $err_present = 1;
                }

                if ($err_present > 0 && $with_err_only == 0)
                {
                    print $fh "<tr style=\"background-color:".
                              "$err_result_color\">\n";
                }
                else
                {
                    print $fh "<tr>\n";
                }
                
                print $fh "<td>\n";

                if ($err_present > 0)
                {
                    print $fh "<b>Error:</b> ".$result->{"err"}."<br>\n";
                }

                print $fh $result->{"result"}."<br>\n";
                if (scalar(@{$result->{"verdicts"}}) > 0)
                {
                    print $fh "<br>\n";
                    foreach my $verdict (@{$result->{"verdicts"}})
                    {
                        print $fh $verdict."<br>\n";
                    }
                }
                print $fh "</td>\n";

                print $fh "<td>\n";

                my @compromised_logs = ();
                my @good_logs = ();
                my $result_str = result2str($result);

                foreach my $log (@{$result->{"logs"}})
                {
                    if (iter_is_compromised($iter_key, $result_str, $log))
                    {
                        push(@compromised_logs, $log);
                    }
                    else
                    {
                        push(@good_logs, $log);
                    }
                }

                print $fh "<table>\n";
                if (scalar(@good_logs) > 0)
                {
                    print $fh "<tr><td>\n";
                    logs2html($fh, $test, $iter_key, $result_str,
                              \@good_logs, 0);
                    print $fh "</tr></td>\n";
                }
                if (scalar(@compromised_logs) > 0)
                {
                    print $fh "<tr style=\"background-color:".
                              "$compromised_iter_color;\"><td>\n";
                    logs2html($fh, $test, $iter_key, $result_str,
                              \@compromised_logs, 1);
                    print $fh "</tr></td>\n";
                }
                print $fh "</table>\n";

                print $fh "</td>\n";

                print $fh "</tr>\n";
            }
            print $fh "</table>\n";
            print $fh "</td>\n";

            print $fh "</tr>";
        }
    }
    print $fh "</table>\n";

    print $fh "<p>Command used to generate this report:".
              join(" ", $0, @ARGV)."</p>\n";

    print $fh "</body>\n";

    print $fh "</html>\n";
}

sub print_binary_string
{
    my $fh = $_[0];
    my $str = $_[1];
    
    # 32-bit length followed by ASCII string
    print $fh pack("V/A*", decode_entities($str));
}

sub print_binary_tag
{
    my $fh = $_[0];
    my $tag_id = $_[1];

    print $fh pack("V", $tag_id);
}

sub print_binary_report
{
    my $fh = $_[0];

    my $test_tag_id = 1;
    my $iter_tag_id = 2;
    my $params_tag_id = 3;
    my $results_tag_id = 4;
    my $err_tag_id = 5;
    my $status_tag_id = 6;
    my $verdicts_tag_id = 7;
    my $logs_tag_id = 8;

    binmode($fh);

    foreach my $test (keys %{$night_results{"tests"}})
    {
        my $iter;

        print_binary_tag($fh, $test_tag_id);
        print_binary_string($fh, $test);
        print $fh pack("V", 
                       scalar(keys %{$night_results{"tests"}->
                                            {$test}->{"iters"}}));

        while ((undef, $iter) = each
                  %{$night_results{"tests"}->{$test}->{"iters"}})
        {
            print_binary_tag($fh, $iter_tag_id);

            print_binary_tag($fh, $params_tag_id);
            print $fh pack("V", scalar(keys %{$iter->{"params"}}));
            foreach my $param (sort(keys %{$iter->{"params"}}))
            {
                my $value = $iter->{"params"}->{$param};

                print_binary_string($fh, $param);
                print_binary_string($fh, $value);
            }

            print_binary_tag($fh, $results_tag_id);
            print $fh pack("V", scalar(@{$iter->{"results"}}));
            foreach my $result (@{$iter->{"results"}})
            {
                if (defined($result->{"err"}) &&
                    length($result->{"err"}) > 0)
                {
                    print_binary_tag($fh, $err_tag_id);
                    print_binary_string($fh, $result->{"err"});
                }

                print_binary_tag($fh, $status_tag_id);
                print_binary_string($fh, $result->{"result"});

                print_binary_tag($fh, $verdicts_tag_id);
                print $fh pack("V", scalar(@{$result->{"verdicts"}}));
                foreach my $verdict (@{$result->{"verdicts"}})
                {
                    print_binary_string($fh, $verdict);
                }

                print_binary_tag($fh, $logs_tag_id);
                print $fh pack("V", scalar(@{$result->{"logs"}}));
                foreach my $log (@{$result->{"logs"}})
                {
                    print_binary_string($fh, $log->{"log"});
                    print_binary_string($fh, $log->{"date"});
                    print_binary_string($fh, $log->{"tags"});
                }
            }

        }
    }
}

open my $fh, ">", $night_results_fn or return -1;
if ($print_binary_report > 0)
{
    print_binary_report($fh);
}
else
{
    print_html_report($fh);
}
close $fh;
