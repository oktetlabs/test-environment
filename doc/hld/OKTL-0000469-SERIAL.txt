Serial console parsing framework design.

Authors: Konstantin Ushakov <Konstantin.Ushakov@oktetlabs.ru>
         Andrey Dmitrov <Andrey.Dmitrov@oktetlabs.ru>

COPYRIGHT Copyright(C) OKTET Labs 2012

PROJECT oktetlabs/te

RESPMGR Konstantin Ushakov

* Status

Not approved

* Content

1. Abbreviations
2. Teminology
3. References
4. Conventions
5. Introduction
6. Requirements
7. Environment and decomposition
8. Product services
9. Utilised services
10. Interfaces
  1. External interfaces
  2. Internal interfaces
11. Data model definition
12. Processes
  1. Serial log parser thread
  2. Tester thread
13. Events processing
  1. Agent events
  2. Parser thread events
  3. Tester events
  4. Test events
14. Configuration parameters
  1. Tester configuration
  2. Parser thread configuration
15. Initialization and shutdown
16. Algorithms
  1. The *parser* thread algorithm of search for events
  2. Updating of the Tester events status and Tester settings


* Abbreviations

|------+--------------------|
| Term | Definition         |
|------+--------------------|
| HLD  | Hight Level Design |
| TE   | Test Environment   |

* Teminology

As the document describes a subsystem in TE it uses teminology and
abbreviations described in the TE architecture document OKTL-ARCH-0000044.

|-----------------+--------------------------------------------------------|
| Term            | Definition                                             |
|-----------------+--------------------------------------------------------|
| parser          | Instance which captures a serial console output to     |
|                 | parse it and detect certain events.                    |
| parser event    | The event caught by any parser.                        |
| tester event    | The tester event is an aggregation of *parser event*.  |
|                 | This is necessary for handling the event on the tester.|
| handler         | A handler to process *tester events*.                  |

* References

|-----+-------------------------------+---------------------|
| Ref | Document Title                | Document Identifier |
|-----+-------------------------------+---------------------|
|   1 | Test Environment Architecture | OKTL-0000044        |

* Conventions

Terms in *bold* like *handler* mean exactly what is written in the
definition in the *Terminology* section.

* Introduction

On some projects during testing the tester/developer may be interested in
serial console logs. For this purpose log_serial thread can be defined on
the test agent running on the host with conserver which is responsible for
the logs gathering. This thread connects to the conserver and reads the logs
from it in arbitrary portions. The logs are then added to the agent logs
ringbuffer.

It's required to detect certain logs appearance on the console and report it
back to the test/tester. Example of such logs may be "Kernel panic",
"Something crashed", "U-Boot bla-bla". These logs can mean that something is
seriously wrong or may be just a notion of some asynchronous event which has
just happened on the DUT.

The test (if exists at the moment of the event) should be notified ASAP and
take appropriate actions. Examples of actions may include diagnostics
gathering, some smart logging, DUT reboot and not touching the DUT.

* Requirements

OKTL-TE-MKT-0001
    It should be possible to detect some events that happen on DUT basing 
    on serial log patterns.

OKTL-TE-MKT-0005
    It should be possible to specify particular way of the detected events
    processing.

OKTL-TE-MKT-0010
    Event processing should be specified by handler (binary application)
    that should be called on event detection.

OKTL-TE-MKT-0015
    It should be possible to specify several handlers for the single event 
    and assign a priority to each handler.

OKTL-TE-MKT-0020
    It should be possible to specify system behaviour after finish of
    particular handler: continue event processing by the other handlers;
    stop event processing; stop test execution; stop the testing sequence.
    The information about the particular decision should be obtained
    dynamically from the called handler.

OKTL-TE-MKT-0025
        It should be possible to specify events and handlers statically 
        before testing.

OKTL-TE-MKT-0030
    It should be possible to specify events and handlers dynamically
    from the test.

OKTL-TE-MKT-0033
    Events/handlers/patterns added by the test should not take effect
    after test finish.
    Note: this requirement should be satisfied via Configurator
    backup/restore mechanism.

OKTL-TE-DSGN-0035
    Design should follow recommendations provided in section 2 of this
    document.

OKTL-TE-SCAL-0050
    Several serial log sources (test agents) should be supported.

OKTL-TE-SCAL-0055
    It should be possible to specify that particular pattern should
    trigger event only if it's detected on the patricular serial
    log source.

OKTL-TE-RBST-0055
    The framework should survive test agents crash/restart.

OKTL-TE-USBL-0060
    Test API for using from tests should be created.

OKTL-TE-DOCS-0040
    XML schema for new Configurator subtrees should be provided.

OKTL-TE-DOCS-0045
    Test API should be accompanied doxygen headers to allow automatic
    documentation generation.

* Environment and decomposition

#+begin_ditaa blue.png -r -S 

                                                         +-----------+
                                                         |           |
                                                         |  Handler  |
                                                         +-----------+
                                                            ^  |     
                                                            |  |Result
                                                        Call|  |      
                                                            |  v      
 +----------+                                            +----------+
 |          |                           cfg get/set      |          |
 |Conserver |                +---------------------------|  Tester  |
 |          |                |                           |          |
 +----------+                |                           +----------+
        |                    |                                 |     
        |Data                |                                 |Signal
        |                    v                                 v     
+-------|-----+      +--------------+                       +--------+
|       |     |      | Configurator |    cfg get/set        |        |
| Agent |     |      |    {s}       |<----------------------|  Test  |
|       v     |      +--------------+                       +--------+
| +-------+   |              |                                  |
| |Parser |   |              |                                  |
| |thread |   |              |                                  |
| +-------+   |              v                                  v
|             |       +------------+                        +--------+
|             |       |            |                        |        |
|             | <-----|     RCF    |<-----------------------| Logger |
|             |       |            |                        |        |
+-------------+       +------------+                        +--------+

#+end_ditaa

* Product Services

Serial console parsing framework provides:
  - possibility to save of the serial console output data;
  - possibility to search and handle events in the serial console output.
  
* Utilised services

1. *Configurator* is used to manage and configure of the *parser* threads.
   There is configured combinations of patterns, events and handlers.

2. *RCF* is used as the only transport mechanism.

3. *Logger* is used to write captured messages from the serial console.

4. Operating system signals used to perform *tester*->*test* intercation.

* Interfaces

** External Interfaces

*** Build Options

Additional build option is supported. To compile the agents with support
of serial console parsing framework should be added option
*--with-serialparse* to agent type options. See example:
    TE_TA_TYPE([linux], [], [unix], 
               [--with-serialparse], [], [], [], [])

*** Tester configuration TAPI

#+BEGIN_SRC C
    /**
     * Create a new empty Tester event
     * 
     * @param name          Event name
     */
    void
    tapi_serial_tester_event_add(const char *name);

    /**
     * Remove a Tester event
     * 
     * @param name          The event name
     */
    void
    tapi_serial_tester_event_del(const char *name);

    /**
     * Add a new external handler for an event
     * 
     * @param ev_name       Event name
     * @param h_name        Handler name
     * @param priority      Handler priority
     * @param path          Path to the handler
     */
    void
    tapi_serial_handler_ext_add(const char *ev_name, const char *h_name,
                                int priority, const char *path);

    /**
     * Add a new internal handler for an event
     * 
     * @param ev_name       Event name
     * @param h_name        Handler name
     * @param priority      Handler priority
     * @param signo         Signal number
     */
    void
    tapi_serial_handler_int_add(const char *ev_name, const char *h_name,
                               int priority, int signo);

    /**
     * Remove a handler
     * 
     * @param ev_name       Event name
     * @param h_name        Handler name
     */
    void
    tapi_serial_handler_del(const char *ev_name, const char *h_name);

#+END_SRC

*** Parser configuration TAPI

#+BEGIN_SRC C

    /**
     * Initialization of the parser id. The function calls the malloc. User
     * should call cleanup function (tapi_serial_id_cleanup()) after use. 
     * By default conserver port value 3109 will be assigned.
     * 
     * @param agent     Agent name
     * @param c_name    Serial console name
     * @param name      The parser name
     */
    tapi_parser_id *
    tapi_serial_id_init(const char *agent, const char *c_name,
                        const char *name);

    /**
     * Cleanup and free the parser id
     */
    void
    tapi_serial_id_cleanup(tapi_parser_id *id);

    /**
     * Create and launch a new parser
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_parser_add(tapi_parser_id *id);

    /**
     * Stop and remove a parser
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_parser_del(tapi_parser_id *id);

    /**
     * Start a parser thread
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_parser_enable(tapi_parser_id *id);

    /**
     * Stop a parser thread
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_parser_disable(tapi_parser_id *id);

    /**
     * Enable logging of the serial console to main log
     * 
     * @param id            Location of the parser id
     * @param level         Level name of the message for logging(logger_defs.h)
     *                      Use NULL to not change the value.
     */
    void
    tapi_serial_logging_enable(tapi_parser_id *id, const char *level);

    /**
     * Disable logging of the serial console to main log
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_logging_disable(tapi_parser_id *id);

    /**
     * Add parser event to the parser
     * 
     * @param id            Location of the parser id
     * @param name          The parser event name
     * @param t_name        The Tester event name. Use a name of one of the
     *                      events declarated in the Tester subtree.
     */
    void
    tapi_serial_parser_event_add(tapi_parser_id *id, const char *name,
                                 const char *t_name);

    /**
     * Delete parser event
     * 
     * @param id            Location of the parser id
     * @param name          The parser event name
     */
    void
    tapi_serial_parser_event_del(tapi_parser_id *id, const char *name);

    /**
     * Add a pattern to the parser event
     * 
     * @param id            Location of the parser id
     * @param e_name        The parser event name
     * @param pattern       The pattern string
     */
    int
    tapi_serial_parser_pattern_add(tapi_parser_id *id, const char *e_name,
                                   const char *pattern);

    /**
     * Remove a pattern from the parser event
     * 
     * @param id            Location of the parser id
     * @param e_name        The parser event name
     * @param pat_i         Index of the pattern
     */
    void
    tapi_serial_parser_pattern_del(tapi_parser_id *id, const char *e_name,
                                   int pat_i);

    /**
     * Reset status for each event of the parser
     * 
     * @param id            Location of the parser id
     */
    void
    tapi_serial_parser_reset(tapi_parser_id *id);

#+END_SRC

** Internal Interfaces

*** Configurator subtrees

Two new configuration subtrees are added to the configuration model.

The first subtree is /local/tester/, it is used to declare *Tester events*.
There is also performed binding of some handlers to declared events.
|------------------------------------+-------+------------------------------|
| OID                                | Type  | Description                  |
|------------------------------------+-------+------------------------------|
|/local/tester                       |RW none|Tester subtree.               |
|/local/tester/enable                |RW int |Enable the Tester thread to   |
|                                    |       |listen for events. By default |
|                                    |       |disabled, value is *0*.       |
|/local/tester/period                |RW int |Period for polling of events  |
|                                    |       |status.                       |
|                                    |       |By default is 100 milliseconds|
|/local/tester/location              |RW str |Directory with handlers for   |
|                                    |       |short named handlers. By      |
|                                    |       |default it is RUN_DIR/handlers|
|/local/tester/event                 |RC none|Subtree of a *Tester event*.  |
|/local/tester/event/handler         |RC str |Event handler. Use a path to  |
|                                    |       |the executable as value.      |
|/local/tester/event/handler/priority|RW int |Handler priority.             |
|/local/tester/event/handler/signal  |RW int |Signal name.                  |
|/local/tester/event/handler/internal|RW int |Indicates that it is internal |
|                                    |       |handler. By default, it is    |
|                                    |       |external, value is *0*.       |

A new subtree of the agent is /agent/parser. It is used to configure and
launch a *parser* thread for a serial consoles on the agent.
|----------------------------------+-------+--------------------------------|
| OID                              | Type  | Description                    |
|----------------------------------+-------+--------------------------------|
|/agent/parser                     |RC str |The *parser* subtree. Use a name|
|                                  |       |of serial console as value.     |
|/agent/parser/port                |RW int |Conserver port corresponds to   |
|                                  |       |launch parameters of conserver. |
|                                  |       |By defualt used *3109*.         |
|/agent/parser/user                |RW str |Conserver user name.            |
|                                  |       |By default *tester* is used     |
|/agent/parser/enable              |RW int |Start/stop the *parser* thread. |
|/agent/parser/interval            |RW int |Intreval of polling messages    |
|                                  |       |from the console.               |
|                                  |       |By default is 100 milliseconds. |
|/agent/parser/reset               |RW int |Reset status for all events.    |
|/agent/parser/event               |RC str |*Parser event* subtree. Use a   |
|                                  |       |name of one of the *Tester      |
|                                  |       |events* declared in the Tester  |
|                                  |       |subtree as value.               |
|/agent/parser/event/pattern       |RC str |Pattern string.                 |
|/agent/parser/event/counter       |RW int |Counter of the happened event.  |
|/agent/parser/event/status        |RW int |State of the event.             |
|/agent/parser/event/logging       |RW int |Enable logging of the console   |
|                                  |       |messages in the main log.       |
|                                  |       |By default enabled, value is *1*|
|/agent/parser/event/logging/level |RW str |Level of the message for logging|
|                                  |       |By default is *WARN*            |

*** Tester-Handler interaction

When an event has been detected, the Tester should call a sequence of
handlers. A handler can be internal or external, this indicates the
/local/tester/event/handler/internal instance.

If a handler is internal and an event occurred, then the Tester should send
a signal specified in the handler subtree. The event will be proccesed by
Test itself.

An external handler is an executable program. The handler has no input
parameters. It can perform any actions to handle the event, but it must
return one of the following values:
 * 0 : continue handlers execution
 * 1 : stop handlers execution
 * 2 : stop both handlers and test execution
 * 3 : stop handlers execution, kill the test and stop tests sequence
       execution.

*** Tester-Test interaction

The *Tester* send a signal to the *test*, when it is necessary. To stop a
*test* the *SIGTERM* signal is passed by the *Tester*.

* Data model definition

** Pattern

Pattern - is a character string. The serial log message (line) matches a
pattern if it contains the pattern substring.

** Event

There are two types of events. *Parser event* and *Tester event*. *Tester
event* is an aggregation of *Parser events*. Together they provide a mapping
templates to handlers.

*** Parser event

*Parser event* happens if a serial log message matches at least one of the
patterns, associated with the event. It is processed by the *parser* thread.

*** Tester event

*Tester event* has a set of associated handlers. *Tester event* happens if
the *tester* detects a *Parser event*.  If the *tester event* happens the
*tester* calls associated handlers in sequence in accordance to their
priority and return values. See below.

** Handler

When it detects of a *Tester event*, a sequence of handlers is called. The
handler is peresented in the Configurator by /local/tester/event/handler
subtree. User can use human-readable name for the instance name. If the
handler is an external handler, then a path to the executable should be used
as the instance value. In case if the handler is internal handler, than
signal number must be specified in the corresponding instance.

** Handlers directory

The end user, specifying full path, can use any handler programs or scripts,
that are located anywhere. But if is used a short name, the handler is
searched in the default handlers directory.

By default the handlers directory is *RUN_DIR/handlers*. The default
directory can be changed by user.

** Parser

Parser object is responsible for configuration and and managment of a serial
console *parser* thread. It is presented as /agent/parser subtree and has an
unique name for the agent.

** Parser list

Agent stores a list of parsers identified by their instance names. Instance
name should be explicitly assigned upon parser creation.

* Processes

** Serial log parser thread

Serial log *parser* thread is an agent thread. It is responsible for logs
gathering. The *Configurator* should configure and launch it. It listens for
the data from the conserver, running on the host, and receives arbitrary
amount of data. Log messages may be cut in arbitrary place etc. The thread
parses a data and searches one of events. When event is detected, the thread
changes the event state in the appropriate instance. Optional, the thread
can to print data from the serial console in the main log as well as before.

** Tester thread

Tester has a separate thread. It should periodically polls a state of the
events from the Configurator, when an event occurs the thread calls an
appropriate handler or a series of handlers.

* Events processing

** Parser thread events

The *parser* thread should listen a serial console, waiting for any agent
event. To handle an event the agent should to change event state of the
appropriate instance.

** Tester events

When an event occur in the *tester*, then should be called a sequence of
handlers, which is descibed in the *Configurator*. There are two types of
event handlers. An external handler can be called, *Configurator* keeps a
path to It. Or the signal can be passed to the *test*.

** Test events

It is a responsibility of the *test* developer to process of the events,
when received a signal from the *tester*. *Test events* are asynchronous to
the *test*.

* Configuration parameters

** Tester configuration

There is configurable polling timeout interval between cycles of calls to
the *Configurator*. Per cycle *tester* gets info about each event for all
agents.

** Parser thread configuration

Before starting of the *parser* thread should be configured connection to
the console. Must be specified following parameters: console name, port,
user, interval (of console polling). It is optional to launch logging of the
console.

* Initialization and shutdown

** Initialization

The *Tester* should to launch the thread, that will to check events state.
The first poll is performed after the thread has been started.

** Shutdown

After completing of the last *test*, the *Tester* informs the thread of
events processing that time to shutdown and waits, when the thread will be
finished. The thread performs the last poll and clean exit.

* Algorithms

** Algorithm of data polling process on a *parser* thread

For each main loop iteration the *parser* thread should:
  1. Call the poll() function with a certain value of timeout
  2. If there is data to read:
    1. Read the data and append it to the buffer.
    2. If the buffer is filled:
      1. Call data block processing macro.
    3. Else:
      1. Set *timeout value* to *interval*
  3. Else if the timeout left:
    1. Call data block processing macro.

** Data block processing macro on a *parser* thread

  1. If the buffer has a data:
    1. Search end ('\n') of the last string.
    2. If found:
      1. Processing of the data block from the start of the buffer to the
        finish of the last string:
        1. Check patterns matches.
        2. Printing the data block to main log if logging is active.
      2. Perform memove the leftover after the finish of last string, part
         of the data to the beginning of the buffer.
      3. Set the pointer of current position in the buffer to next byte
         after the moved block.
    3. Else:
      1. Processing of the data block from first byte to the
         last saved byte in the buffer:
        1. Check patterns matches.
        2. Printing the data block to main log if logging is active.
      2. Set the pointer of current position in the buffer to the first byte
         of the buffer.
    4. Set the *timeout value* to alive timeout value (60 sec).

** The *parser* thread algorithm of search for events

After the thread has been started on the agent, it should perform the
following sequence of actions:
  1. Connection to the serial console.
  2. Try to get a data from the console.
  3. For each received block of bytes:
    1. For each *parser event*:
      1. Compare the string with each pattern
      2. If the pattern is a substring of the console string:
        1. Change the *parser event* status.
        2. Break the *parser event* loop.
  4. Sleep timeout before the next attempt to pull the data.
  5. Return to step 2.

** Updating of the Tester events status and Tester settings

Interaction of the Tester thread with the Configurator is carried out by
means of *confapi*. The Tester periodically gets info from the Configurator.
It should check state of the event instances for all *parser* threads on 
all agents. 

Every times when need check events status the *Tester* should performs
the following calls to the *Configurator*:
  1. Get list of the event state instances for each *event* of each
     *parser*. For each instance perform:
      1. Get the synchronized event state value.
      2. Check the event status. If the event is occured:
          1. Get list of instances of the *handlers* for the *event*.
          2. Call the series of handlers.
          3. Reset status of the *parser event*.
