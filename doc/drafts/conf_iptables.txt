Iptables configuration model in TE.

Goals:
- Configurator should be able to track changes in iptables rules
  made by tests and rollback that changes.
- Configurator should not allow conflicts between different test
  agents running on the host.

Resolving Conflicts:
  To avoid conflicts between different test agents, separate chains
for each interface should be created.
  Each network interface is a resource of test agent and is not shared
with other TAs. Thus operating with per-interface chains only will not
affect other interfaces.
  Ð¡ommon (built-in) chains for each table should be duplicated and
corresponding jump rules added (inserted) with interface-only matching.

For example:
  For NAT table and interface eth1 we should create chains: eth1_PREROUTING,
eth1_POSTROUTING and eth1_OUTPUT, and add conditional jumps to PREROUTING,
POSTROUTING and OUTPUT chains of NAT table with intarface matching
(-i for incoming packets, or -o for outgoing)

Configuration Tree Model:
  1) Iptables configuration subtree should be under interface node:
    /agent/interface/iptables/

    Iptables node is not accessible and has no named instances.
    It is created to simplify sync for iptables subtree.

  2) Each table should be represented as standalone instance
  (filter, mangle, nat, raw):
    /agent/interface/iptables/table

  NOTE: Table node is also not accessible now, but probably should have a state
  (enabled/disabled) to verify if corresponding chains and jump rules are
  installed or not.

  3) Each rule should be represented as standalone object to simplify
  add/del operations.
    The problem of naming rule instances is resolved by using encoded
  iptables command as rule name. For example, command:
    'iptables -A POSTROUTING -s 10.30.0.1/32 -p tcp -m tcp --sport 554 -j SNAT \
        --to-source 68.120.102.29:554'
    should be cut to 'POSTROUTING -s 10.30.0.1/32 -p tcp -m tcp --sport 554 -j SNAT \
        --to-source 68.120.102.29:554'
    then, encoded by substituting symbols that are not allowed in
    instance name (' ', ':', '/').

    OID constructed for this rule looks like:
      /agent:TA_TST1/interface:eth1/iptables:/table:nat/rule:POSTROUTING#-s#10.30.0.1|32#-p#tcp#-m#tcp#--sport#554#-j#SNAT#--to-source#68.120.102.29;554

    This encoding allows to avoid values of rule instances.

Configutation Tree Operations:
  1) Add new rule.
    Adding new rule instance will decode instance name back to iptables rule
    and execute 'iptables -A ...' command on the agent.

  2) Delete new rule.
    Deletion of rule would be also simple decoding of instance name
    and executing 'iptables -D ...' command

  3) List rules.
    There is no need to implement get/set methods in this case. List method
    is implemented via 'iptables-save' command by encoding rules to instance
    names.

    At this moment list method works by running command:
      "iptables-save -t <table_name> | grep '^-A <ifname>_' | sed -e 's/^-A <ifname>_//g'"
    where <ifname> is corresponding interface name.

    Thus output contains only rules in per-interface chains. Each line
    represents one iptables rule. List method encodes this rules to instance
    names and constructs the complete list of iptables rules.

  4) Initialisation.
    Iptables configuration model initialisation with creating of per-interface
    chains for each table should be performed when an interface resource
    is grabbed.

  5) Finalisation.
    When network interface resource is released, all auxiliary per-interface
    iptables chains and corresponding jumping rules should be removed.
