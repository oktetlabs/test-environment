/**
@defgroup te_user TE: User Guide
@ingroup te
@{

@section te_user_introduction Introduction

This page gives step by step guideline on where to start with TE, how to
get the sources, build them and run a simple test script.

TE can be supplied in two release types:
- pre-installed form (external headers and binaries are available);
- source code form (all sources of TE components are available).
.

If you have pre-installed binaries you can obviously skip the sources
download and build part.

@section te_user_src Getting TE sources

Test Environment sources can be obtained from

<pre>
https://svn.oktetlabs.ru/svnroot/prj/oktetlabs/test-environment/src/trunk
</pre>

You will need OKTET Labs account and appropriate permissions, contact
mailto:Konstantin.Ushakov@oktetlabs.ru if you need any assistance.

If you have a test suite which is not structurally embeded in the TE subtree
(not in @path{suites/}) directory you also need to download its sources.

So in general case after all source code is retrieved from the repository
one should have:

<pre class="fragment">
work_dir/
   te/
   my-ts/
</pre>

@section te_user_build Building TE components

When you get TE in source code form you need to build TE before
it can be used for testing.

If you're living on a deb-based distribution you could benefit from
installing @lib_name{ol-te} and other packages. They will automatically
install all the deps for the engine and your project. Contact developers if
you need access to the the debian repository or to get the .deb file.

To build any of components TE Engine or TA it is necessary to install
development toolchain. You can use these packages on Debian derivatives:
- @lib_name{build-essential} - this package provokes the installation of
  the following packages:
    - @lib_name{g++},
    - @lib_name{gcc},
    - @lib_name{libc-dev},
    - @lib_name{make};
- @lib_name{pkg-config}.

Same for Debian derivatives in one line:

<pre class="fragment">
apt-get install build-essential pkg-config
</pre>

@subsection te_deps Test Environment Engine dependencies

Test Environment Engine depends on a set of 3-rd party libraries and packages:

- @lib_name{autoconf} - at least 2.61;
- @lib_name{automake} - at least 1.9;
- @lib_name{bison};
- @lib_name{curl};
- @lib_name{file};
- @lib_name{flex} - at least 2.5.31;
- @lib_name{gawk};
- @lib_name{libexpat1};
- @lib_name{libexpat1-dev};
- @lib_name{libglib2.0-dev};
- @lib_name{libncurses5};
- @lib_name{libncurses5-dev};
- @lib_name{libpam0g};
- @lib_name{libpam0g-dev};
- @lib_name{libpcap0.8-dev};
- @lib_name{libpopt-dev};
- @lib_name{libreadline5} - at least 5.0;
- @lib_name{libreadline-dev} - at least 5.0;
- @lib_name{libssl-dev};
- @lib_name{libusb-1.0-0};
- @lib_name{libusb-1.0-0-dev};
- @lib_name{libxml2};
- @lib_name{libxml2-dev} - at least 2.6.10;
- @lib_name{libxslt1.1};
- @lib_name{libxslt1-dev} - at least 1.1.6;
- @lib_name{ssh};
- @lib_name{tcl-dev};
- @lib_name{wget}.
.

Same for Debian derivatives in one line:

<pre class="fragment">
apt-get install autoconf automake bison curl file flex gawk libexpat1 libexpat1-dev libglib2.0-dev libncurses5 libncurses5-dev libpam0g libpam0g-dev libpcap0.8-dev libpopt-dev libreadline5 libreadline-dev libssl-dev libusb-1.0-0 libusb-1.0-0-dev libxml2 libxml2-dev libxslt1.1 libxslt1-dev ssh tcl-dev wget
</pre>

Or easy way, you can install meta package @b oktetlabs-te-dev from
OKTET Labs repository.

Optional libraries and packages:

- @lib_name{perl-Time-HiRes} - package on Redhat/Fedora is very usefull
  (it allows to avoid mixture in log because of unprecise timestamps in
  messages logged by Dispatcher (via logging script)).
.

@subsection ta_build_deps Test Agent build dependencies

Default Test Agent build depends on a set of 3-rd party libraries and packages:

- @lib_name{bison};
- @lib_name{file};
- @lib_name{flex} - at least 2.5.31;
- @lib_name{gawk};
- @lib_name{libpcap0.8-dev};
- @lib_name{libpopt-dev};
- ssh server, in Debian derivatives it is @lib_name{openssh-server};
- @lib_name{wget}.
.

Same for Debian derivatives in one line:

<pre class="fragment">
apt-get install bison file flex gawk libpcap0.8-dev libpopt-dev openssh_server wget
</pre>

Optional libraries and packages:

- @lib_name{libsnmp-dev} - for SNMP support.
.

@subsection ta_run_deps Test Agent run dependencies

Default Test Agent run depends on a set of 3-rd party libraries and packages:

- @lib_name{file};
- @lib_name{gawk};
- ssh server, in Debian derivatives it is @lib_name{openssh-server}.
.

Same for Debian derivatives in one line:

<pre class="fragment">
apt-get install file gawk openssh_server
</pre>

Optional libraries and packages:

- @lib_name{libsnmp} - for SNMP support.
.

@subsection te_build_config Build configuration

In order to build sources you will need to prepare project-specific
@ref te_engine_builder configuration file. For the details on the file
format please read @ref te_engine_builder_conf_file section.

If you're dealing with existing test suite the file usualy was already
written by the suite author/maintainer.

For example @path{builder.conf} file for a sample test suite located under
@path{${TE_BASE}/suites/ipv6-demo} is following:

@code
@USER_EXPAND{INCLUDE_FILE} suites/ipv6-demo/conf/builder.conf
@endcode

@subsection te_build_do Building

When you prepared a @ref te_engine_builder configuration file, you are
ready to start builing process.

You should have two folders:
* Test Environment sources folder;
* test suite sources folder.

Before building you @b must export @var{TE_BASE} environment variable
that points to the root directory of Test Environment sources.

As you usually work with one copy of Test Environment it is usefull to
add 
@code
export TE_BASE=/path/to/TE_root_dir
@endcode
into your @path{~/.bashrc}.

Suppose we have the following structure under our project directory
(a directory where we run Test Environment building procedure):
<pre class="fragment">
@path{${PRJ_ROOT}}
  +-- @path{conf_ipv6}
        +-- @path{builder.conf.ipv6_demo}
</pre>

To start building process we should run the following command:
<pre class="fragment">
cd $PRJ_ROOT
@path{${TE_BASE}}/@prog{dispatcher.sh} @prog_option{--conf-dir=}@path{conf_ipv6} @prog_option{--conf-builder=}@path{builder.conf.ipv6_demo} @prog_option{--build-only} @prog_option{--no-tester}
</pre>

@prog_option{\-\-build-only} option means that we don't try to run any tests
and @prog_option{\-\-no-tester} means that @prog{dispatcher.sh} doesn't
start the @ref te_tester.

If you build with a test suite (which means that you have @prog{run.sh}) you
can call:

<pre class="fragment">
cd $PRJ_ROOT
@path{${TE_BASE}}/@prog{run.sh} @prog_option{--cfg=myconfiguration_name} @prog_option{--tester-norun}
</pre>

@prog{run.sh} script is a wrapper for @prog{dispatcher.sh} which introduces
some suite-specific options and defaults. The above @prog{run.sh}
invocations will build both TE and the test suite. See @te_user_run or
@prog{dispatcher.sh} help for details on the @prog{\-\-cfg} option.

If you get some errors during building procedure, you should first check if
your have all necessary packages installed on your development platform.
Please refer to @ref te_deps section to check the list of required packages
and libraries.

If you do not specify @var{TE_BUILD} environment variable, @ref
te_engine_builder calls @prog{configure} scripts and calls @prog{make} under
@path{${PRJ_ROOT}} directory (i.e. a directory where you run
@prog{dispatcher.sh}.

@section te_user_run TE Exectuion

To run TE one need to have configuration files for all the TE
subsystems.

See @ref te_user_run_details or @ref te for more information about config
files creation and syntax.

Below we describe what's happens upon @prog{dispatcher.sh} execution and
what artifacts are left after it.

As it was mentioned above the TE can be started by @prog{run.sh} script
located in you test suite directory or by direct @prog{dispatcher.sh}
invocation.

You should either specify all the configuration files with
@prog_option{\-\-conf-*} options or use the default ones (see the dispatcher
script):

<pre class="fragment">
CONF_BUILDER=builder.conf
CONF_LOGGER=logger.conf
CONF_TESTER=tester.conf
CONF_CS=configurator.conf
CONF_RCF=rcf.conf
</pre>

To avoid extremely long command lines you can use @prog_option{\-\-opts}
option and pass a file:

<pre class="fragment">
$ cat conf/run.opts.defaults
--conf-builder=builder.conf.default
--conf-tester=tester.conf.default
$ ./dispatcher.sh --opts=run.opts.defaults --tester-run=foobar-ts/basic/trivial
</pre>

In case you're running with @prog{run.sh} there is even faster way to start
the framework.

<pre class="fragment">
$ ./run.sh --cfg=<cfgname> --tester-run=foobar-ts/basic/trivial
</pre>

In this case the @path{conf/run.conf.<cfgname>} file is considered as an
option file. This is very useful as usually project has several test
configurations (i.e. @b apple, @b carrot and @b tomato). Although each
configuration may use its own hosts they usually share @path{tester.conf},
@path{builder.conf} (if all hosts run the same operating system),
@path{configurator.conf}

When you start the TE the following is written to the console:

<pre class="fragment">
RUNDIR=/home/user/work/my_run_dir
--->>> Starting Logger...done
--->>> Starting RCF...done
--->>> Starting Configurator...done
--->>> Start Tester
Starting package foobar-ts
Starting test prologue                                               pass
Starting package basic
Starting test trivial                                                pass
Done package basic pass
Starting test epilogue                                               pass
Done package foobar-ts pass
--->>> Shutdown Configurator...done
--->>> Flush Logs
--->>> Shutdown RCF...done
--->>> Shutdown Logger...done
--->>> Logs conversion...done

Run (total)                               1
  Passed, as expected                     1
  Failed, as expected                     0
  Passed unexpectedly                     0
  Failed unexpectedly                     0
  Aborted (no useful result)              0
  New (expected result is not known)      0
Not Run (total)                         239
  Skipped, as expected                    0
  Skipped unexpectedly                    0
</pre>

So:
- Framework starts all its components; See @ref te_run_time section for
  details.
- It executes @b prologue if exists (@b prologue is not a test -- it's a
sequence of actions specific for a given package/suite; for instance it can
assign IP addresses or start certain services);
- @b tests which were passed with the @prog_option{\-\-tester-run} option
are executed; in the above case it's @b{foobar-ts/basic/trivial} (see @ref
te_tester for more details on the tests specification);
- @b epilogue is executed -- it can be used to rollback modifications done
in @b prologue or perform arbitrary cleanup;
- framework terminates;
- @ref trc prints some statistics, see @ref trc_tool_result for details
(note, that prologues and epilogues are not counted in the tests statisctics
as they @b MUST always sucess).

After execution is complete several new files appear in the log directory
(which is @var{PWD} if not specified with @prog_option{\-\-log-dir}
option. Name of some of the files can be changed via @prog_option{\-\-log-*}
options.

Files include:
- @path{tmp_raw_log} -- main log file in binary format; can be passed to
the @ref rgt and @ref trc utils;
- @path{ta.*} -- files with @b stderr from all of the agents, should contain
only 'Exiting' word if all went fine;
- if @prog_option{\-\-cs-print-trees} option was given then @path{objects}
and @path{instances} will be created; they will contain dump of objects and
instances @ref te_engine_conf trees.

You can read the logs in text or HTML format. See @ref rgt_output_formats
for more info on logs generation and looks.


@} <!-- END te_user -->
*/
