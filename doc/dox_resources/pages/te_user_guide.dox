/**
@defgroup te_user TE: User Guide
@ingroup te
@{

@section te_user_introduction Introduction

This page gives step by step guideline on where to start with TE, how to
get the sources, build them and run a simple test script.

TE can be supplied in two release types:
- pre-installed form (external headers and binaries are available);
- source code form (all sources of TE components are available).
.

If you have pre-installed binaries you can obviously skip the sources
download and build part.

@section te_user_src Getting TE sources

Test Environment sources can be obtained from

<pre>
https://svn.oktetlabs.ru/svnroot/prj/oktetlabs/test-environment/src/trunk
</pre>

You will need OKTET Labs account and appropriate permissions, contact
mailto:Konstantin.Ushakov@oktetlabs.ru if you need any assistance.

If you have a test suite which is not structurally embeded in the TE subtree
(not in @path{suites/}) directory you also need to download its sources.

So in general case after all source code is retrieved from the repository
one should have:

<pre class="fragment">
work_dir/
   te/
   my-ts/
</pre>

@section te_user_build Building TE components

When you get TE in source code form you need to build TE before
it can be used for testing.

@subsection te_deps Test Environment Dependencies

Test Environment depends on a set of 3-rd party libraries and packages.

For building TE components from sources you need:
- @prog{autoconf} version 2.61 or higher;
- @prog{automake} 1.9.6 (note: 1.10.* does not work).
.

For @ref te_engine build and run (in square brackets - debian package names):
- @lib_name{libxml2-devel} at least 2.6.x (2.6.10)
  [@lib_name{libxml2} @lib_name{libxml2-dev}];
- @lib_name{glib2-devel} (@lib_name{glib-2.0} package we use 2.4.8)
  [@lib_name{libglib2-dev}];
- @lib_name{popt-devel} (@lib_name{libpopt-dev} on Debian)
  [@lib_name{libpopt-dev}];
- @lib_name{libreadline} (for @ref te_engine_tester interactive)
  [@lib_name{libreadline-common}, @lib_name{libreadline-dev},
  @lib_name{libreadline-5}];
- @prog{tcl} (and @lib_name{tcl-devel}, if applicable, e.g. on Fedora Core 2)
  [@lib_name{tcl}, @lib_name{tcl-dev}];
- @lib_name{libxslt} (we use 1.1.6)
  [@lib_name{libxslt1-dev}, @lib_name{libxslt-1.1}];
- @lib_name{libexpat} [@lib_name{libexpat1}, @lib_name{libexpat1-dev}];
- @lib_name{flex} >= 2.5.31-31 from sourceforge; @lib_name{flex} 2.5.4a
  from gnu.org will not work [@lib_name{flex}];
- @prog{gawk} (@prog{mawk} will not work) [@lib_name{gawk}];
- any @lib_name{curses} library (@lib_name{ncurses} will work) with
  development files [@lib_name{ncurses}, @lib_name{ncurses-dev}];
- @lib_name{perl-Time-HiRes} package on Redhat/Fedora is very usefull
  (it allows to avoid mixture in log because of unprecise timestamps in
  messages logged by @ref te_engine_dispatcher (via logging script));
- @lib_name{libgss0} (>=0.0.18) [@lib_name{libgss0}];
- Wireless tools - development files [@lib_name{libiw-dev}];
- PPPoE [@lib_name{pppoe}] [@lib_name{pppoeconf}];
- @lib_name{curl} libraries [not from debian, should be taken from storage];
- @lib_name{libusb}, @lib_name{libusb-dev};
- @lib_name{libpam0g-dev};
- @lib_name{libperl-dev};
- @lib_name{bison}.
.

@ref te_agents_unix :

- @lib_name{expect} and @lib_name{expect-dev} (for TAD CLI only)
  [@lib_name{expect}, @lib_name{expect-dev}];
- @lib_name{flex} >= 2.5.31 from sourceforge;
  @lib_name{flex} 2.5.4a from gnu.org does not work;
- @lib_name{libexpat};
- @lib_name{libpcap0.8-dev} (for TAD PCAP only) [@lib_name{libpcap0.8-dev}];
- @lib_name{libpam} (0.76-22) (not required but suggested)
  [@lib_name{libpam}].
.

@ref te_agents_win :

- @lib_name{cygwin}, cross-toolchain;
- @lib_name{libpcap} (crosscompiled for @lib_name{cygwin}).
  Should be put into standard @path{include/lib} paths of
  @lib_name{cygwin} cross-compiler - required for TAD library.
  @lib_name{Winpcap} runtime has to be installed on Windows host.

Of course, @prog{gcc}, @prog{make}, @prog{sed} and other standard development
tools are required to build sources.

@subsection te_build_config Build configuration

In order to build sources you will need to prepare project-specific
@ref te_engine_builder configuration file. For the details on the file
format please read @ref te_engine_builder_conf_file section.

If you're dealing with existing test suite the file usualy was already
written by the suite author/maintainer.

For example @path{builder.conf} file for a sample test suite located under
@path{${TE_BASE}/suites/ipv6-demo} is following:

@code
@USER_EXPAND{INCLUDE_FILE} suites/ipv6-demo/conf/builder.conf
@endcode

@subsection te_build_do Building

When you prepared a @ref te_engine_builder configuration file, you are
ready to start builing process.

You should have two folders:
* Test Environment sources folder;
* test suite sources folder.

Before building you @b must export @var{TE_BASE} environment variable
that points to the root directory of Test Environment sources.

As you usually work with one copy of Test Environment it is usefull to
add 
@code
export TE_BASE=/path/to/TE_root_dir
@endcode
into your @path{~/.bashrc}.

Suppose we have the following structure under our project directory
(a directory where we run Test Environment building procedure):
<pre class="fragment">
@path{${PRJ_ROOT}}
  +-- @path{conf_ipv6}
        +-- @path{builder.conf.ipv6_demo}
</pre>

To start building process we should run the following command:
<pre class="fragment">
cd $PRJ_ROOT
@path{${TE_BASE}}/@prog{dispatcher.sh} @prog_option{--conf-dir=}@path{conf_ipv6} @prog_option{--conf-builder=}@path{builder.conf.ipv6_demo} @prog_option{--build-only} @prog_option{--no-tester}
</pre>

@prog_option{\-\-build-only} option means that we don't try to run any tests
and @prog_option{\-\-no-tester} means that @prog{dispatcher.sh} doesn't
start the @ref te_tester.

If you build with a test suite (which means that you have @prog{run.sh}) you
can call:

<pre class="fragment">
cd $PRJ_ROOT
@path{${TE_BASE}}/@prog{run.sh} @prog_option{--cfg=myconfiguration_name} \-\-tester-norun
</pre>

@prog{run.sh} script is a wrapper for @prog{dispatcher.sh} which introduces
some suite-specific options and defaults. The above @prog{run.sh}
invocations will build both TE and the test suite. See @te_user_run or
@prog{dispatcher.sh} help for details on the @prog{\-\-cfg} option.

If you get some errors during building procedure, you should first check if
your have all necessary packages installed on your development platform.
Please refer to @ref te_deps section to check the list of required packages
and libraries.

If you do not specify @var{TE_BUILD} environment variable, @ref
te_engine_builder calls @prog{configure} scripts and calls @prog{make} under
@path{${PRJ_ROOT}} directory (i.e. a directory where you run
@prog{dispatcher.sh}.

@section te_user_run TE Exectuion

To run TE one need to have configuration files for all the TE
subsystems.

See @ref te_user_run_details or @ref te for more information about config
files creation and syntax.

Below we describe what's happens upon @prog{dispatcher.sh} execution and
what artifacts are left after it.

As it was mentioned above the TE can be started by @prog{run.sh} script
located in you test suite directory or by direct @prog{dispatcher.sh}
invocation.

You should either specify all the configuration files with
@prog_option{\-\-conf-*} options or use the default once (see the dispatcher
script):

<pre class="fragment">
CONF_BUILDER=builder.conf
CONF_LOGGER=logger.confCONF_TESTER=tester.conf
CONF_CS=configurator.conf
CONF_RCF=rcf.conf
</pre>

To avoid extremely long command lines you can use @prog_option{\-\-opts}
option and pass a file:

<pre class="fragment">
$ cat conf/run.opts.defaults
--conf-builder=builder.conf.default
--conf-tester=tester.conf.default
$ ./dispatcher.sh --opts=run.opts.defaults --tester-run=foobar-ts/basic/trivial
</pre>

In case you're running with @prog{run.sh} there is even faster way to start
the framework.

<pre class="fragment">
$ ./run.sh --cfg=<cfgname> --tester-run=foobar-ts/basic/trivial
</pre>

In this case the @path{conf/run.conf.<cfgname>} file is considered as an
option file. This is very useful as usually project has several test
configurations (i.e. @b apple, @b carrot and @b tomato). Although each
configuration may use its own hosts they usually share @path{tester.conf},
@path{builder.conf} (if all hosts run the same operating system),
@path{configurator.conf}

When you start the TE the following is written to the console:

<pre class="fragment">
RUNDIR=/home/user/work/my_run_dir
--->>> Starting Logger...done
--->>> Starting RCF...done
--->>> Starting Configurator...done
--->>> Start Tester
Starting package foobar-ts
Starting test prologue                                               pass
Starting package basic
Starting test trivial                                                pass
Done package basic pass
Starting test epilogue                                               pass
Done package foobar-ts pass
--->>> Shutdown Configurator...done
--->>> Flush Logs
--->>> Shutdown RCF...done
--->>> Shutdown Logger...done
--->>> Logs conversion...done

Run (total)                               1
  Passed, as expected                     1
  Failed, as expected                     0
  Passed unexpectedly                     0
  Failed unexpectedly                     0
  Aborted (no useful result)              0
  New (expected result is not known)      0
Not Run (total)                         239
  Skipped, as expected                    0
  Skipped unexpectedly                    0
</pre>

So:
- Framework starts all its components; See @ref te_run_time section for
  details.
- It executes @b prologue if exists (@b prologue is not a test -- it's a
sequence of actions specific for a given package/suite; for instance it can
assign IP addresses or start certain services);
- @b tests which were passed with the @prog_option{\-\-tester-run} option
are executed; in the above case it's @b{foobar-ts/basic/trivial} (see @ref
te_tester for more details on the tests specification);
- @b epilogue is executed -- it can be used to rollback modifications done
in @b prologue or perform arbitrary cleanup;
- framework terminates;
- @ref trc prints some statistics, see @ref trc_tool_result for details
(note, that prologues and epilogues are not counted in the tests statisctics
as they @b MUST always sucess).

After execution is complete several new files appear in the log directory
(which is @var{PWD} if not specified with @prog_option{\-\-log-dir}
option. Name of some of the files can be changed via @prog_option{\-\-log-*}
options.

Files include:
- @path{tmp_raw_log} -- main log file in binary format; can be passed to
the @ref rgt and @ref trc utils;
- @path{ta.*} -- files with @b stderr from all of the agents, should contain
only 'Exiting' word if all went fine;
- if @prog_option{\-\-cs-print-trees} option was given then @path{objects}
and @path{instances} will be created; they will contain dump of objects and
instances @ref te_engine_conf trees.

You can read the logs in text or HTML format. See @ref rgt_output_formats
for more info on logs generation and looks.


@} <!-- END te_user -->
*/
