/**

@defgroup te_ts Test Suite
@ingroup te
@{

@section te_ts_terminology Terminology

@tdt_start
@tdt_term Test Package
@tdt_def Group of tightly related tests or test packages, which may share
internal libraries and usually run together (one-by-one or simultaneously).
Test Package may consist of one test. It may have a prologue (performing
some initialization) and epilogue (releasing resources and restoring
TE configuration).
@tdt_term Test Script
@tdt_def A test which is a minimal structural unit of a test harness.
@tdt_term Test Suite
@tdt_def Test Package which may be considered as standalone entity from
organisational point of view and build issues.
@tdt_tend

@section te_ts_tree_structure Directory tree structure

Test suite can be distributed in two forms:
-# pre-installed binary form;
-# source based form.
.

For pre-installed binary test suite does not require building procedure,
which is why there is no need to have build related files.

Pre-installed binary test suite has the following directory structure:

<pre class="fragment">
@path{${TS_ROOT}}
  +-- @path{package.xml}
  +-- @path{prologue}
  +-- @path{epilogue}
  +-- @path{p1_test1}
  +   ...
  +-- @path{p1_testN}
  +-- @path{subpackage}
       +-- @path{package.xml}
       +-- @path{prologue}
       +-- @path{epilogue}
       +-- @path{p2_test1}
       +   ...
       +-- @path{p2_testN}
       
</pre>

A test suite consists of a set of packages each containing a number of
test executables and package description file. For the details on the format
of @path{package.xml} files refer to @ref te_engine_tester_conf_pkg section.

Source based test suite additionally has build-specific files. As any other
component of TE, a source based test suite is expected to be built with the
help of @ref te_engine_builder. @ref te_engine_builder uses autotools in
the backgroud, which means a top level package directory shall include:
- @prog{configure} script.
.
And all directories shall include:
- @path{Makefile.in} file;
.

More often source based test suite will have base files of autotools:
- @path{Makefile.am};
- @path{configure.ac}.
.
And before running TE we there will be need to generate @prog{configure}
script and @path{Makefile.in} files with the following command:
<pre class="fragment">
@prog{autoreconf} @prog_option{--install} @prog_option{--force}
</pre>

The directory structure of source-based test suite is following:
<pre class="fragment">
@path{${TS_ROOT}}
  +-- @path{package.xml}
  +-- @path{configure.ac}
  +-- @path{Makefile.am}
  +-- @path{prologue.c}
  +-- @path{epilogue.c}
  +-- @path{p1_test1.c}
  +   ...
  +-- @path{p1_testN.c}
  +-- @path{subpackage}
       +-- @path{package.xml}
       +-- @path{Makefile.am}
       +-- @path{prologue.c}
       +-- @path{epilogue.c}
       +-- @path{p2_test1.c}
       +   ...
       +-- @path{p2_testN.c}

</pre>

@section te_ts_min Minimal Test Suite

Minimal test suite can be found under @path{${TE_BASE}/suites/minimal/suite}
directory.

The structure of minimal project is:
<pre class="fragment">
@path{${TE_BASE}/suites/minimal}
  +-- @path{conf}
  |     +-- @path{builder.conf}
  |     +-- @path{cs.conf}
  |     +-- @path{logger.conf}
  |     +-- @path{rcf.conf}
  |     +-- @path{tester.conf}
  +-- @path{suite}
        +-- @path{configure.ac}
        +-- @path{Makefile.am}
        +-- @path{package.xml}
        +-- @path{sample1.c}
</pre>

@ref te_engine_tester configuration file (@path{tester.conf}) refers to
suite sources and add this suite for @ref te_engine_tester run:
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/conf/tester.conf
@endcode

This test suite has simplest package description file (@path{package.xml}):
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/suite/package.xml
@endcode

Package description file specifies one test executable @prog{sample1} to run.

To run this test suite do the following steps:
-# under @path{${TE_BASE}/suites/minimal/suite} run:
<pre class="fragment">
@prog{autoreconf} @prog_option{--install} @prog_option{--force}
</pre>
This will generate @prog{configure} script and @path{Makefile.in} file
under @path{${TE_BASE}/suites/minimal/suite} directory.
-# export @var{TS_BASE} environment variable, because @ref te_engine_tester
   configuration file (@path{tester.conf}) uses it as the value of
   @attr_name{src} attribute of @attr_name{suite} TAG.
<pre class="fragment">
@prog{export} @var{TS_BASE}=@path{${TE_BASE}/suites/minimal}
</pre>
-# set @var{TE_BUILD} variable to specify allocation of build artifacts.
<pre class="fragment">
@prog{export} @var{TE_BUILD}=@path{${TS_BASE}/build}
</pre>
If this variable is not set, all generated files will be created in working directory.
-# run TE:
<pre class="fragment">
@path{${TE_BASE}/}@prog{dispatcher.sh} @prog_option{--conf-dir}=@path{${TS_BASE}/conf}
</pre>
In our test project all configuration file names match with the default
names, which is why we do not specify them with separate
@prog_option{--conf-<prog>} options, but only tell where to find
configuration files with @prog_option{--conf-dir} option.

As the result of these operations a number of directories are created
that have TE and suite build and installation files.

<pre class="fragment">
@path{${TE_BASE}/suites/minimal}
  +-- @path{conf}
  +-- @path{suite}
  +-- @path{build} - build directory
        +-- @path{engine} - @ref te_engine build directory
        +-- @path{agents} - @ref te_agents build directory
        +-- @path{lib} - build directory for TE libraries
        +-- @path{include} - build directory for includes
        +-- @path{platforms} - platforms build
        +-- @path{suites} - test suites build directory
              +-- @path{minimal} -- build directory of our @path{minimal} test suite
                    +-- @path{sample1} - test executable
        +-- @path{inst} - installation directory
              +-- @path{agents} - @ref te_agents installation directory
              +-- @path{default} - @ref te_test_engine installation directory
              +-- @path{suites} - test suites installation directory
                    +-- @path{minimal} -- installation directory of our @path{minimal} test suite
                          +-- @path{package.xml} - installed package description file
                          +-- @path{sample1} - test executable
</pre>

Please note that @ref te_engine_tester runs a test suite from
@path{inst/suites/<suite_name>} directory.

@subsection te_ts_min_builder Autotools files

The content of @path{configure.ac} of our minimal test suite is following:
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/suite/configure.ac
@endcode

The content of @path{Makefile.am} is following:
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/suite/Makefile.am
@endcode

@subsection te_ts_min_test_file Test scenario file

A test scenario file used in minimal test suite is a C source file:
@code
@USER_EXPAND{INCLUDE_FILE} suites/minimal/suite/sample1.c
@endcode

@section te_ts_scenario_layout Test scenario layout

Each test scenario shall have:
-# Definition of @c TE_TEST_NAME macro in order to specify Entity name
   of log messages generated from test scenario. Usually this is set to
   test name.
   @code
   #define TE_TEST_NAME "sample1"
   @endcode
-# Inclusion of @path{te_config.h} file. This file defines macros generated
   by TE @prog{configure} script after verification of header files,
   structure fields, strucure sizes (i.e. it has definitions of
   @c HAVE_xxx_H, @c SIZEOF_xxx macros).
   @code
   #include "te_config.h"
   @endcode
-# Inclusion of @path{tapi_test.h} file - basic API for test scenarios.
   @code
   #include "tapi_test.h"
   @endcode
-# @func{main()} function. A test scenario is an executable, so in case of
   C source file we should have program entry point, which is @func{main()}
   function for the default linker script. @func{main()} function has to have
   @var{argc}, @var{argv} parameters, because macros defined at tapi_test.h
   depend on them;
-# Mandatory test points:
   - TEST_START;
   - TEST_END;
   - TEST_SUCCESS.
   .
   The mandatory test structure is:
   @code
   {
       TEST_START;
       ...
       TEST_SUCCESS;
   cleanup:
       TEST_END;
   }
   @endcode
.

The following things should be taken into account while writing
a test scenario:
- If you need to add local variables to your test scenario, put them BEFORE
  TEST_START macro:
  @code
  {
      /* Local variables go before TEST_START macro */
      int              sock;
      struct sockaddr *addr4;
      struct sockaddr *addr6;
      int              opt_val;

      TEST_START;
      ...
      TEST_SUCCESS;
  cleanup:
      TEST_END;
  }
  @endcode
- If a set of tests require definition of the same set of local variables
  we can avoid duplication these variables from test to test by using
  TEST_START_VARS macro:
  @code
  /* test_suite.h */
  #define TEST_START_VARS \
      int sock;                 \
      struct sockaddr *addr4;   \
      struct sockaddr *addr6
  @endcode
  In each test scenarion we will have:
  @code
  ...
  #include "test_suite.h"
  ...
  int main(int argc, char **argv)
  {
      /* Define test-specific local variables */
      int              opt_val;

      TEST_START;
      ...
      sock = rpc_socket(rpc_srv,
                        RPC_AF_INET, RPC_SOCK_STREAM, RPC_IPPROTO_TCP);
      ...
  }
  @endcode
- Another useful macros are:
  - TEST_START_SPECIFIC;
  - TEST_END_SPECIFIC.
  .
  They can be defined if you need some common parts of code to be executed
  during TEST_START and TEST_END procedures. For example tests suites that
  use tapi_env library may define these macros as:
  @code
  #define TEST_START_VARS TEST_START_ENV_VARS
  #define TEST_START_SPECIFIC TEST_START_ENV
  #define TEST_END_SPECIFIC TEST_END_ENV
  @endcode
.

@section te_ts_scenario_params Test parameters

@copydetails te_ts_tapi_test_param


@} <!-- END te_ts -->

@defgroup te_ts_tapi Test API
@ingroup te_ts
@{
Miscellaneous API which can be used in tests.
@} <!-- END te_ts_tapi -->

 */
