<?xml version="1.0" encoding="utf-8"?>
<backup>

    <!-- This configuration model is to describe configuration
         information related to base hardware properties -->

    <!--
        Copyright (C) 2016 Test Environment authors (see file AUTHORS
        in the root directory of the distribution).

        Test Environment is free software; you can redistribute it
        and/or modify it under the terms of the GNU General Public
        License as published by the Free Software Foundation; either
        version 2 of the License, or (at your option) any later
        version.

        Test Environment is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
        PURPOSE. See the GNU General Public License for more details.

        You should have received a copy of the GNU General Public
        License along with this program; if not, write to the Free
        Software Foundation, Inc., 59 Temple Place, Suite 330,
        Boston, MA  02111-1307  USA

        Author: Artem Andreev E-mail: Artem.Andreev@oktetlabs.ru
    -->

    <!-- The root of all hardware-related information
         Name: none
         Value: none -->
    <object oid="/agent/hardware" access="read_only" type="none" />


    <!-- The container for various board identification strings.
         Name: none
         Value: none -->
    <object oid="/agent/hardware/identity" access="read_only" type="none" />

    <!-- Identification strings provided by SMBIOS/DMI record types 0-4.
         The names correspond to Linux sysfs entries under /sys/devices/virtual/dmi/id/
         @todo other DMI identification strings for things like DIMMs

         Name: none
         Value: identification string
    -->

    <object oid="/agent/hardware/identity/bios_date" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/bios_version" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/bios_vendor" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/board_asset_tag" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/board_name" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/board_serial" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/board_vendor" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/board_version" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/chassis_asset_tag" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/chassis_serial" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/chassis_vendor" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/chassis_version" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/product_name" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/product_serial" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/product_uuid" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/product_version" access="read_only" type="string" />
    <object oid="/agent/hardware/identity/sys_vendor" access="read_only" type="string" />

    <!-- Computing node (e.g. NUMA node).
         On small-scale systems there will be a single node.
         The available CPU info is organized into a tree (node > physical package > core > logical cpu),
         rather than a linear list of logical CPU so that it be possible to use node/package/core OIDs
         for resource grabbing.

         Currently all nodes are assumed to have the same architecture, but
         true heterogenous systems may eventually be supported.
         The arch value must be from a controlled vocabulary, not raw uname -m string

         The following set of arch values is defined:
         - i386
         - x86_64
         - powerpc
         - powerpc64
         - powerpc64le

         Name: integer node ID
         Value: arch identifier -->
    <object oid="/agent/hardware/node" access="read_only" type="string" />

    <!-- Physical CPU of a node
         Name: CPU package/socket id
         Value: none -->
    <object oid="/agent/hardware/node/cpu" access="read_only" type="none" />

    <!-- Container for CPU identity strings
         Name: none
         Value: none -->
    <object oid="/agent/hardware/node/cpu/identity" access="read_only" type="none" />

    <!-- Those are strings found in /proc/cpuinfo on Linux.
         On x86(_64) some of these values are integers, but since it cannot be warranted
         on all possible platforms, all values are declared as strings

         Name: none
         Value: identity string -->
    <object oid="/agent/hardware/node/cpu/identity/vendor" access="read_only" type="string" />
    <object oid="/agent/hardware/node/cpu/identity/family" access="read_only" type="string" />
    <object oid="/agent/hardware/node/cpu/identity/model" access="read_only" type="string" />
    <object oid="/agent/hardware/node/cpu/identity/model_name" access="read_only" type="string" />
    <object oid="/agent/hardware/node/cpu/identity/stepping" access="read_only" type="string" />

    <!-- FPU is present.
         On embedded architectures, this is a crucial feature, so it deserves its own node

         Name: none
         Value: 1 - hardware FPU, 0 - no hardware FPU
    -->
    <object oid="/agent/hardware/node/cpu/fpu" access="read_only" type="integer" />

    <!-- A set of CPU features.
         Since such a set is open and is platform-dependent, it's unreasonable to have
         a named boolean node for each feature.
         Instead, we have an empty node indexed by a feature designator as reported by /proc/cpuinfo
         Test libraries may (and should) provide wrapper function to check for more high-level and
         platform-specific conditions (e.g. the largest set of vectorized ops available etc)

         Name: feature ID
         Value: none -->
    <object oid="/agent/hardware/node/cpu/feature" access="read_only" type="none" />

    <!-- CPU cache information.
         Caches may be attached to a CPU package or to a CPU core, hence this subtree is
         repeated below for /agent/hardware/node/cpu/core
         @todo Cache performance nodes

         Name: index of cache
         Value: type of cache: instruction, data, unified -->
    <object oid="/agent/hardware/node/cpu/cache" access="read_only" type="string" />

    <!-- Cache level (L1, L2, L3)

         Name: none
         Value: level number -->
    <object oid="/agent/hardware/node/cpu/cache/level" access="read_only" type="integer" />

    <!-- Cache coherence line size in bytes

         Name: none
         Value: cache line size -->
    <object oid="/agent/hardware/node/cpu/cache/linesize" access="read_only" type="integer" />

    <!-- Cache size in bytes

         Name: none
         Value: cache size -->
    <object oid="/agent/hardware/node/cpu/cache/size" access="read_only" type="integer" />

    <!-- Cache associativity

         Name: none
         Value: number of ways of associativity (1, 2, 4...) -->
    <object oid="/agent/hardware/node/cpu/cache/assoc" access="read_only" type="integer" />

    <!-- CPU core

         Name: # of a core inside its package
         Value: none -->
    <object oid="/agent/hardware/node/cpu/core" access="read_only" type="none" />

    <!-- CPU thread (as in hyper-threading)
         @todo Performance counters
         @note The CPU frequency is intentionally omitted, because it is a number
               which virtually means nothing. CPU identity strings may be used to deduce
               nominal clock frequency

         Name: # of a thread in the core
         Value: # of a logical CPU -->
    <object oid="/agent/hardware/node/cpu/core/thread" access="read_only" type="integer" />

    <!-- Interrupt affinity to a CPU

         Name: IRQ number
         Value: 1 - enable routing it to this thread; 0 - disable it -->
    <object oid="/agent/hardware/node/cpu/core/thread/interrupt" access="read_write" type="integer" />

    <!-- Number of interrupts for a given IRQ to a given thread.

         Name: none
         Value: interrupt count -->
    <object oid="/agent/hardware/node/cpu/core/thread/interrupt/count" access="read_only" type="integer" volatile="true" />


    <!-- Per-core cache information, see /agent/hardware/node/cpu/cache for details -->
    <object oid="/agent/hardware/node/cpu/core/cache" access="read_only" type="string" />
    <object oid="/agent/hardware/node/cpu/core/cache/level" access="read_only" type="integer" />
    <object oid="/agent/hardware/node/cpu/core/cache/linesize" access="read_only" type="integer" />
    <object oid="/agent/hardware/node/cpu/core/cache/size" access="read_only" type="integer" />
    <object oid="/agent/hardware/node/cpu/core/cache/assoc" access="read_only" type="integer" />

    <!-- Amount of physical memory on a given node
         Name: none
         Value: node memory in bytes

         @todo Performance data, in particular NUMA non-local allocations
         @todo It would be helpful to detect physical parameters of memory chips,
               like the number of channels or clock speed. However, the required information is
               scattered between ACPI, DMI and EDAC and any arbitrary piece of it may be missing,
               so a reliable detection method, covering a wide range of platforms, is not, perhaps,
               worth the effort -->
    <object oid="/agent/hardware/node/memory" access="read_only" type="integer" />

    <!-- Free physical memory
         Name: none
         Value: amount of available physical memory -->
    <object oid="/agent/hardware/node/memory/free" access="read_only" type="integer" volatile="true" />

    <!-- A range of physical addresses belonging to a given node
         Name: start-end in hex format (like: 0000000000000000-FFFFFFFFFFFFFFFF)
         Value: none -->
    <object oid="/agent/hardware/node/memory/range" access="read_only" type="none" />

    <!-- NUMA memory access distance. In NUMA systems for every two nodes there is a metric
         showing how expensive is the access to memory at one node from a CPU at another node.
         The absolute values are not meaningful and should be compared to the cost of local access.
         So, /agent:XXX/hardware/node:0/distance:1 would contain the distance from node 0 to node 1,
         wherea /agent:XXX/hardware/node:0/distance:0 would contain the cost value of local access.

         Name: target node ID
         Value: access distance -->
    <object oid="/agent/hardware/node/distance" access="read_only" type="integer" />


    <!-- @todo /agent/hardware/sensor
         The conceptual problem with sensors, as well as with performance counters:
         the set of available counters/sensors varies greatly across systems, and the raw
         data are often meaningless, requiring some sort of calibration.
         So there are two ways:
         - provide low-level access to everything the system may provide and let the test or
         some other entity interpret the data
         - identify some set of important parameters and make a bona fide effort to provide
         platform-independent way to access them
    -->
</backup>