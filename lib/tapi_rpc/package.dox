/**

@page te_lib_rpc_tapi TAPI: Remote Procedure Calls (RPC)
- @subpage te_lib_rpc_netdb
- @subpage te_lib_rpc_unistd
- @subpage te_lib_rpc_power_sw
- @subpage te_lib_rpc_ifnameindex
- @subpage te_lib_rpc_telephony
- @subpage te_lib_rpc_winsock2
- @subpage te_lib_rpc_aio
- @subpage te_lib_rpc_socket
- @subpage te_lib_rpc_tr069
- @subpage te_lib_rpc_stdio
- @subpage te_lib_rpc_dlfcn
- @subpage te_lib_rpc_misc
- @subpage te_lib_rpc_signal

@tableofcontents

@section tapi_rpc_lib_introduction Introduction

TAPI RPC library is an auxiliary library that hides the details of RPC encoding/decoding procedure.
Its purpose is to provide an interface for tests that is almost equal to direct function calls made on test side.

@section tapi_rpc_lib_framework RPC Development Framework

In most cases a new test suite will require supporting a new set of RPC functions.
In such cases you will need to extend RPC TAPI and here is a guidelines on how to do it.

Assume we would like to add RPC call for function foobar() that have the following prototype:

@code
enum foobar_type {
    FOOBAR_TYPE_A,
    FOOBAR_TYPE_B,
};

struct foobar_type1 {
    enum foobar_type type;
    int field;
};

int foobar(struct foobar_type1 *param1, const char *param2, int param3, int *param4_out);
@endcode

First thing in supporting an RPC call is to define necessary data structures in include/tarpc.x.m4 file.
According to the prototype of rcf_rpc_call() function we can see that  to issue RPC we need to pass the following information:
- RPC name;
- RPC input argument;
- RPC output argument.
.

It means that for each function we need to define ONE data structure that will keep ALL input arguments and ONE data structure that will
keep ALL output values (output arguments and return value). For our example this may look like the following:

@code
enum tarpc_foobar_type {
    TARPC_FOOBAR_TYPE_A,
    TARPC_FOOBAR_TYPE_B,
};

struct tarpc_foobar_type1 {
    enum tarpc_foobar_type type;
    tarpc_int field;
};

struct tarpc_foobar_in {
    struct tarpc_in_arg common;

    struct tarpc_foobar_type1 param1;
    string                    param2<>;
    tarpc_int                 param3;
};

struct tarpc_foobar_out {
    struct tarpc_out_arg common;

    tarpc_int param4;
    tarpc_int retval;
};

/* Add foobar function in the list of RPC calls */
program tarpc
{
    version ver0
    {
        ...
        RPC_DEF(foobar)
        ...
    } = 1;
} = 1;
@endcode

Please note that each structure for input arguments should have struct tarpc_in_arg as the first field of the structure, each structure for output arguments should have struct tarpc_out_arg structure.
The format of include/tarpc.x.m4 file complies with XDR format specified in RFC 1014.

Now we are ready to implement TAPI side for our foobar() function. Due to the fact that our target is to call foobar() function in the context of another process, we can't use the same name for the function implementation - it may conflict with such a function in our context. To sort this out we prefix all functions with <b>rpc_</b> string.

Any TAPI RPC function should do the following things:
- define variable for IN arguments;
- define variable for OUT arguments;
- fill in fields of IN arguments variable;
- call rcf_rpc_call();
- set corresponding output parameters and return value with values extracted from OUT arguments variable.
.

For the case of foobar() function the implementation of corresponding TAPI RPC function could be as following:
@code
int
rpc_foobar(rcf_rpc_server *rpcs,
           struct foobar_type1 *param1, const char *param2, int param3, int *param4_out)
{
    struct tarpc_foobar_in in;
    struct tarpc_foobar_out out;

    memset(&in, 0, sizeof(in));
    memset(&out, 0, sizeof(out));

    in.param1.type = param1_type_h2rpc(param1->type); /* Convert enum constants to RPC representation */
    in.param1.field = param1->field; /* We can copy int value as is */
    in.param2 = param2; /* Put a pointer to string (XRPC will calculate string length and copy it) */
    in.param3 = param3; /* Copy int parameter as is */

    rcf_rpc_call(rpcs, "foobar", &in, &out);

    /* Check foobar() function returns value more or equal to -1 */
    CHECK_RETVAL_VAR_IS_GTE_MINUS_ONE(foobar, out.param4);

    *param4_out = out.param4;

    TAPI_RPC_LOG(rpcs, foobar, "%s:%d, %s, %d", "%d, %d",
                 param1_type_h2str(param1->type), param1->field, param2, param3,
                 out.param4, out.retval);

    RETVAL_INT(foobar, out.retval);
}
@endcode

You should note the following things:
- an extra parameter @p rpcs has been added to rpc_foobar() function in order to be able to specify RPC Server on which to run <b>foobar()</b> function;
- enumeration type should be converted from host representation to corresponding RPC enumeration. This needs to be done in case such constants have different
  values on different hosts. For our example this is not obvious, but imagine we pass <b>errno</b> value, of protocol family type in socket API (@c PF_INET, @c PF_LOCAL, etc.);
- parameters of integer type are not converted, but copied as is. This is obvious because there can be no conflicts between the value of this type of data on different hosts;
- parameters that represent string value are copied by XPRC library and we just put a pointer to the beginning of the string;
- assuming we know the range of return value from a function, we can check that return value with one of macros defined in lib/tapi_rpc/tapi_rpc_internal.h file.
  In our case we check that the return value is more or equal to -1 using CHECK_RETVAL_VAR_IS_GTE_MINUS_ONE() macro. More generic macro to use is CHECK_RETVAL_VAR(),
  but more likely you will find some predefined specific macro;
- right before returning a value from a function, we should provide log message about our function call. We specify value of input and output arguments and return value;
- return from a function should be done with one of macros defined in lib/tapi_rpc/tapi_rpc_internal.h file. In our case we return integer, which is why we use RETVAL_INT() macro.
.

A lot of RPC data types and convert functions are defined under lib/rpc_types library. Mainly this library keeps data types to use while doing RPC calls for system functions with well-known prototypes (like libc functions or functions from POSIX API). The purpose of this library is to export header files analogue to system library files.

Assuming you are implementing RPC calls for some standard API, you should better have a look at lib/rpc_types library and create your own header (and if necessary C source) file with corresponding data types.

Now we are ready to implement server side for our foobar() function.
Implementation of server side of RPC calls can be found in agents/unix/rpc/tarpc_server.c file. To define a function we should use TARPC_FUNC() macro.

For our sample the implementation can look like the following:

@code
TARPC_FUNC(foobar, {},
{
    struct foobar_type1 param1;

    param1.type = param1_type_rpc2h(in->param1.type);
    param1.field = in->param1.field;
    MAKE_CALL(out->retval = func(&param1, in->param2, in->param3, &out->param4));
}
)
@endcode

Please make sure that data types and values of arguments passed to a function call are native for the host where we run this function call.
In our sample we created local variable @p param1 of type @p foobar_type1 in order to have correct value for the first argument of the function.
Then we filled each field of this structure with native host values:
- @p foobar_type1::type field is set by means of helper function
param1_type_rpc2h() that converts enum tarpc_foobar_type enumeration into native host enumeration of type enum foobar_type;
- @p foobar_type1::field field is set to the value got from RPC input
argument structure. This is acceptable because it is just the value of integer type.
.

One thing that should also be explained is how to pass structures of variable length to and from RPC Server.
Let's assume we need to pass some data buffer as input parameter and a function shall fill some output buffer in.

Let's implement an RPC function foo() that has the following prototype:

@code
void foo(uint8_t *in_buf, size_t in_buf_len, uint8_t *out_buf, size_t *out_buf_len);
@endcode

include/tarpc.x.m4 file will have the following lines:

@code
struct tarpc_foo_in {
    struct tarpc_in_arg common;

    uint8_t in_buf<>; /* Input buffer content */
    tarpc_size_t in_buf_len; /* The value of in_buf_len parameter */
    uint8_t out_buf<>; /* Output buffer content */
    tarpc_size_t out_buf_len<>; /* The value kept by out_buf_len address */
};

struct tarpc_foo_out {
    struct tarpc_out_arg common;

    uint8_t out_buf<>; /* Output buffer content */
    tarpc_size_t out_buf_len<>; /* The value kept by out_buf_len address */
};
@endcode

Notes:
- We define @p rpc_foo_in::out_buf field in order to pass output buffer
  content to RPC server, i.e. on RPC Server side we would like to have an output buffer
  with the same pre-filled value as on RPC caller side. This is unnecessary in most of the cases
  and should be eliminated, but for example it can be useful when we want to check if a function call
  modifies output buffer or not in case a particular condition and how it modifies it.
- We define @p rpc_foo_in::out_buf_len field as an array in order to be able
  to track cases when @p out_buf_len value is @c NULL. We could use two separate fields
  to get the same results:
  @code
  tarpc_bool out_buf_len_null; /* TRUE when out_buf_len parameter is NULL */
  tarpc_size_t out_buf_len; /* The value of out_buf_len when it is not NULL */
  @endcode
- We define @p rpc_foo_in::out_buf array in @p rpc_foo_out data structure in
  order to be able to encode filled output buffer value;
- We define @p rpc_foo_in::out_buf_len field in @p rpc_foo_out data
  structure in order to pass updated value of @p out_buf_len parameter.
  We define it as an array in order to simplify server side implementation;
- We use the same names in in and out data structures for @p rpc_foo_in::out_buf
  and @p rpc_foo_in::out_buf_len fields to make it possible to use some auxiliary
  macros in implementation of server side.
.

TAPI implementation for our foo() function may look like the following:

@code
int
rpc_foo(rcf_rpc_server *rpcs,
        uint8_t *in_buf, size_t in_buf_len, uint8_t *out_buf, size_t *out_buf_len,
        size_t rout_buf_len)
{
    struct tarpc_foo_in in;
    struct tarpc_foo_out out;

    memset(&in, 0, sizeof(in));
    memset(&out, 0, sizeof(out));

    /* Pass information about in_buf parameter */
    in.in_buf.in_buf_len = (in_buf == NULL) ? 0 : in_buf_len;
    in.in_buf.in_buf_val = in_buf;

    /*
     * Copy in_buf_len parameter independently on the value
     * of in_buf parameter
     */
    in.in_buf_len = in_buf_len;

    /*
     * The size of out_buf buffer can be different from the value passed
     * via out_buf_len parameter, which is why we added an extra
     * parameter rout_buf_len. This parameter reflects the real size of
     * out_buf that we need to transfer from RPC caller to RPC server.
     */
    in.out_buf.out_buf_len = (out_buf == NULL) ? 0 : rout_buf_len;
    in.out_buf.out_buf_val = out_buf;

    /*
     * We use array data type to pass information whether
     * the value of out_buf_len parameter is NULL or not.
     * In our case out_buf_len_val is either NULL or a valid pointer.
     * In case of NULL, the size of an array is 0, but when it is a valid
     * data pointer, the size of an array will be 1, because we have only
     * one element that needs to be passed to RPC server.
     */
    in.out_buf_len.out_buf_len_len = (out_buf_len == NULL) ? 0 : 1;
    in.out_buf_len.out_buf_len_val = out_buf_len;

    rcf_rpc_call(rpcs, "foo", &in, &out);

    /*
     * In case this was just a call without waiting for the result
     * we should not copy output parameters (they are not ready yet).
     */
    if (RPC_IS_CALL_OK(rpcs) && rpcs->op != RCF_RPC_WAIT)
    {
        if (out_buf != NULL && out.out_buf.out_buf_val != NULL)
            memcpy(out_buf, out.out_buf.out_buf_val, out.out_buf.out_buf_len));

        if (out_buf_len != NULL)
            *out_buf_len = out.out_buf_len.out_buf_len_val[0];
    }

    TAPI_RPC_LOG(rpcs, foo, "%p, %u, %p, %p", "",
                 in_buf, in_buf_len, out_buf, out_buf_len);

    RETVAL_VOID(foo);
}
@endcode

Please note the following:
- we encode @p rout_buf_len bytes of @p out_buf buffer to transfer between
  RPC client and server;
- we do not copy return value when the case was not blocking RPC start-up.
.

Server side implementation may look like the following:
@code
TARPC_FUNC(foo,
{
    COPY_ARG(out_buf);
    COPY_ARG(out_buf_len);
},
{

    /*
     * Register out_buf for memory corruption in the out of buffer area
     * (for the cases when real buffer length is more than the length
     * passed via out_buf_len parameter).
     */
    INIT_CHECKED_ARG(out->out_buf.out_buf_val, out->out_buf.out_buf_len,
                     (out->out_buf_len.out_buf_len_len == 0) ? 0 : out->out_buf_len.out_buf_len_val[0]);

    MAKE_CALL(func(in->in_buf.in_buf_val, in->in_buf_len,
                   (out->out_buf.out_buf_len == 0) ? NULL : out->out_buf.out_buf_val,
                   (out->out_buf_len.out_buf_len_len == 0) ? NULL : out->out_buf_len.out_buf_len_val));
}
)
@endcode

Notes:
- We copy @p out_buf and @p out_buf_len arguments from IN to OUT. You should
  note that for the case of RPC we must pass output arguments (if necessary)
  first in IN arguments data structure and then all the values function returns
  or updates are passed via OUT data structure (tarpc_foo_out structure).
  Because of this we need to copy the content of buffers that potentially
  could be updated by the function. Field names for such arguments should be the
  same in input and output arguments structures;
- We use INIT_CHECKED_ARG() macro to register our @p out_buf for validation
  against out of bound update - MAKE_CALL() will automatically check that the data
  beyond specified buffer length is not updated;
.

@section tapi_rpc_lib_usage Some usage aspects of TAPI RPC library

@subsection tapi_rpc_lib_usage_error_handling Handling expected errors

Each RPC call (TAPI RPC call) can finish with success or an error. Error condition is analyzed in the context of TAPI RPC function implementation.
An error condition could be:
- timeout waiting for RPC call to finish;
- unexpected return code value or the value of some output parameters
  (controlled by TAPI RPC implementation logic);
- Test Agent crash.
.
By default if an error occurred during RPC call, TAPI RPC interrupts test execution and passes control to test termination block.
Sometimes you would expect an error to be returned by a function and you would not want a test to be terminated.
To tell TAPI RPC that you expect an error condition on RPC call you can use RPC_AWAIT_IUT_ERROR() macro. For example:

@code
    /*
     * Check that bind() returns an error when we try to bind a socket
     * to an address that does not exist on a host.
     */
    RPC_AWAIT_IUT_ERROR(tst_srv);
    rc = rpc_bind(tst_srv, sock_desc, SA(&alien_addr));
    if (rc != -1)
        TEST_FAIL("bind() for an address not assigned to any host interface "
                  "returns %d instead of -1", rc);

    if (RPC_ERRNO(tst_srv) != RPC_EADDRNOTAVAIL)
    {
        TEST_FAIL("bind() returns -1 when called for not assigned address, "
                  "but sets errno to %s instead of %s",
                  errno_rpc2str(RPC_ERRNO(tst_srv)),
                  errno_rpc2str(RPC_EADDRNOTAVAIL));
    }
@endcode

@subsection tapi_rpc_lib_usage_non_blocking_calls Non blocking calls of RPC

In some tests you may have RPC calls that block until some external event happens and a test is the entity that should cause this external event.
One possible solution would be to create a separate thread that blocks on RPC call while another thread takes care of necessary event generating.
This approach could be the right choice for some complex test cases, but in most cases it is enough to use a non blocking RPC call with further calls
to check/get return status. As soon as non blocking RPC call finishes we can continue our test sequence taking into account that there is a pending
call on some RPC Server. The type of RPC call can be controlled with rcf_rpc_server::op field of RPC Server.

In the following example we do non blocking call for recv() function on one socket and then call send() function on another socket that causes
recv() function to return.

@code
    /*
     * Tell rcv_srv to do non blocking call.
     * It means that RPC Server of course blocks on this call,
     * but RPC caller gets control immediately after launching
     * this function on RPC Server side.
     */
    rcv_srv->op = RCF_RPC_CALL;
    /* We do not check return value because this does not make sense right now */
    rpc_recv(rcv_srv, rx_sock, rx_buf, TST_BUF_LEN, 0);

    /* Make sure recv() call blocks */
    CHECK_RC(rcf_rpc_server_is_op_done(rcv_srv, &rcv_done));
    if (rcv_done)
        TEST_FAIL("recv() call is expected to be blocked on incoming data event, but it is not");

    /* By default RPC call is run with RCF_RPC_CALL_WAIT, i.e. blocking call */
    rc = rpc_send(snd_srv, tx_sock, tx_buf, TST_BUF_LEN, 0);
    if (rc != TST_BUF_LEN)
        TEST_FAIL("send() returns %d, but expected return value is %d", rc, TST_BUF_LEN);

    /* Check that recv() call finished */
    CHECK_RC(rcf_rpc_server_is_op_done(rcv_srv, &rcv_done));
    if (!rcv_done)
        TEST_FAIL("recv() call is expected to return on incoming data, but it is not");

    /* Get results of recv() call */
    rcv_srv->op = RCF_RPC_WAIT;
    rc = rpc_recv(rcv_srv, rx_sock, rx_buf, TST_BUF_LEN, 0);
    if (rc != TST_BUF_LEN)
        TEST_FAIL("recv() returns %d, but expected return value is %d", rc, TST_BUF_LEN);

    if (memcmp(rx_buf, tx_buf, TST_BUF_LEN) != 0)
        TEST_FAIL("recv() returns buffer whose content does not match with "
                  "the content of transmitted buffer");
@endcode

/**@} <!-- END te_lib_rpc_tapi --> */

*/

