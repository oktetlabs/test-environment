/* SPDX-License-Identifier: Apache-2.0 */
/** @file
 * @brief ASN.1 library user interface
 *
 * Declarations of user API for processing ASN.1 values.
 *
 * Copyright (C) 2004-2022 OKTET Labs Ltd. All rights reserved.
 */

#ifndef __TE_ASN_USR_H__
#define __TE_ASN_USR_H__

#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#include "te_stdint.h"
#include "te_errno.h"
#include "te_defs.h"

#ifdef __cplusplus
extern "C" {
#endif


/**
 * ASN.1 type struct declaration
 */
struct asn_type;

/**
 * Type: ASN_type
 *
 * Instances of this type shouldn't be dynamically created, they may be
 * only statically defined in special modules. Such modules may be either
 * written manually or generated by a special tool.
 *
 */
typedef struct asn_type asn_type;


/** bit 'named syntax' for compound type syntaxes. */
#define ASN_SYN_NAMED   1
/** bit 'ordered sequence' for compound type syntaxes. */
#define ASN_SYN_ORDER   2
/** bit 'ordered sequence' for compound type syntaxes. */
#define ASN_SYN_ARRAY   4

/**
 * Enumerated type with ASN.1 syntax codes. All syntax codes are divided into
 * the following groups:
 *  - primitive syntaxes, internal presentation of which does
 *      not require memory allocation.
 *  - primitive syntaxes, internal presentation of which
 *      requires memory allocation, because number of octets occupied
 *      depends on the value.
 *  - constractive syntaxes.
 *      Codes of types, which specification contain array of namedValues
 *      (with types), have lower bit zero.
 */
typedef enum {
    SYNTAX_UNDEFINED = 0,  /**< Undefined syntax, used as error mark. */
    BOOL = 1,       /**< Boolean syntax          */
    INTEGER,        /**< Integer syntax          */
    PR_ASN_NULL,    /**< ASN_NULL syntax         */
    ENUMERATED,     /**< Enum syntax             */
    UINTEGER,       /**< Unsigned integer syntax (not a ASN.1 native type) */

    PRIMITIVE_VAR_LEN = 0x10, /**< value to be bit-anded with tag
                                   to determine primitive syntax
                                   with variable length           */
    LONG_INT    = PRIMITIVE_VAR_LEN | 1, /**< This syntax differs from
                                             "long int" in C! length of its
                                              data in octets is specified
                                              by asn_type field 'size'.     */
    BIT_STRING  = PRIMITIVE_VAR_LEN | 2, /**< ASN.1 "BIT STRING" type       */
    OCT_STRING  = PRIMITIVE_VAR_LEN | 3, /**< ASN.1 "OCTET STRING" type     */
    CHAR_STRING = PRIMITIVE_VAR_LEN | 4, /**< ASN.1 "GeneralString" type    */
    REAL        = PRIMITIVE_VAR_LEN | 5, /**< ASN.1 "REAL" type             */
    OID         = PRIMITIVE_VAR_LEN | 6, /**< ASN.1 "OBJECT IDENTIFIER" type*/

    COMPOUND = 0x20, /**< flag of COMPOUND syntax */
    TAGGED      = COMPOUND,
    CHOICE      = COMPOUND | ASN_SYN_NAMED,

    SET_OF      = COMPOUND    | ASN_SYN_ARRAY,
    SET         = SET_OF      | ASN_SYN_NAMED,
    SEQUENCE_OF = SET_OF      | ASN_SYN_ORDER,
    SEQUENCE    = SEQUENCE_OF | ASN_SYN_NAMED,

} asn_syntax;


/**
 * Test whether all bits 1 in mask are the same in syntax;
 * that is bitwise consequence mask => syntax have give all 1.
 * Thus result is true when bitwise NOT for (bitwise mask => syntax)
 * is zero.
 *
 * @param syntax        Syntax to be tested.
 * @param mask          Mask.
 *
 * @return non-zero if statement true and zero if false.
 */
static inline int
asn_syntax_is_a(asn_syntax syntax, int mask)
{
    return !((~syntax) & mask);
}

/**
 * Enumerated type with ASN.1 tag class codes.
 */
typedef enum {
    UNIVERSAL,
    APPLICATION,
    CONTEXT_SPECIFIC,
    PRIVATE
} asn_tag_class;

/** Value of the ASN.1 tag */
typedef uint16_t asn_tag_value;

/**
 * ASN.1 tag
 */
typedef struct asn_tag_t {
    asn_tag_class   cl; /**< ASN.1 tag class */
    asn_tag_value   val;/**< ASN.1 tag value */
} asn_tag_t;



/**
 * Obtain textual label of ASN.1 type.
 *
 * @param type       ASN.1 type which name is interested
 *
 * @return plain string with type name or NULL if error occurred.
 */
extern const char *asn_get_type_name(const asn_type *type);

/**
 * Obtain ASN.1 syntax type;
 *
 * @param type          ASN.1 value which leaf syntax is interested
 *
 * @return syntax of specified leaf in value.
 */
extern asn_syntax asn_get_syntax_of_type(const asn_type *type);


/**
 * Get constant pointer to subtype of some ASN.1 type.
 *
 * @param type          ASN.1 type
 * @param subtype       location for pointer to ASN.1 sub-type (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 * @param labels        string with dot-separated sequence of textual field
 *                      labels, specifying interested sub-type
 *
 * @return zero or error code.
 */
extern te_errno asn_get_subtype(const asn_type *type,
                                const asn_type **subtype,
                                const char *labels);


/**
 * Get ASN.1 type of on-level child of constaint ASN.1 type by child tag.
 *
 * @param type      root of ASN.1 value tree which subvalue is interested
 * @param subtype   location for pointer to ASN.1 sub-value (OUT)
 * @param tag_class class of ASN.1 tag
 * @param tag_val   value of ASN.1 tag
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_child_type(const asn_type *type,
                                   const asn_type **subtype,
                                   asn_tag_class tag_class,
                                   asn_tag_value tag_val);


/**
 * Find ASN.1 tag value by textual label.
 *
 * @param type          ASN.1 type descriptor, must have SEQUENCE, SET
 *                      or CHOICE syntax
 * @param label         textual label of desired field
 * @param tag           location for ASN.1 tag (OUT)
 *
 * @return status code
 */
extern te_errno asn_label_to_tag(const asn_type *type, const char *label,
                                 asn_tag_t *tag);

/**
 * Declaration of structures which describes basic ASN.1 types.
 */

extern const asn_type * const asn_base_boolean;  /**< BOOLEAN    */
extern const asn_type * const asn_base_integer;  /**< INTEGER    */
extern const asn_type * const asn_base_uinteger; /**< UINTEGER   */
extern const asn_type * const asn_base_enum;     /**< ENUMERATED */
extern const asn_type * const asn_base_charstring; /**< UniversalString */
extern const asn_type * const asn_base_octstring;  /**< OCTET STRING    */
extern const asn_type * const asn_base_bitstring;  /**< BIT STRING      */
extern const asn_type * const asn_base_real;    /**< REAL */
extern const asn_type * const asn_base_null;    /**< NULL */
extern const asn_type * const asn_base_objid;   /**< OBJECT IDENTIFIER */

extern const asn_type * const asn_base_int4;    /**< INTEGER (0..15)    */
extern const asn_type * const asn_base_int8;    /**< INTEGER (0..255)   */
extern const asn_type * const asn_base_int16;   /**< INTEGER (0..65535) */

extern const asn_type  asn_base_boolean_s;      /**< BOOLEAN           */
extern const asn_type  asn_base_integer_s;      /**< INTEGER           */
extern const asn_type  asn_base_enum_s;         /**< ENUMERATED        */
extern const asn_type  asn_base_charstring_s;   /**< UniversalString   */
extern const asn_type  asn_base_octstring_s;    /**< OCTET STRING      */
extern const asn_type  asn_base_bitstring_s;    /**< BIT STRING        */
extern const asn_type  asn_base_real_s;         /**< REAL              */
extern const asn_type  asn_base_null_s;         /**< NULL              */
extern const asn_type  asn_base_objid_s;        /**< OBJECT IDENTIFIER */

extern const asn_type  asn_base_int1_s;  /**< INTEGER (0..1)           */
extern const asn_type  asn_base_int2_s;  /**< INTEGER (0..3)           */
extern const asn_type  asn_base_int3_s;  /**< INTEGER (0..7)           */
extern const asn_type  asn_base_int4_s;  /**< INTEGER (0..15)          */
extern const asn_type  asn_base_int5_s;  /**< INTEGER (0..31)          */
extern const asn_type  asn_base_int6_s;  /**< INTEGER (0..63)          */
extern const asn_type  asn_base_int7_s;  /**< INTEGER (0..127)         */
extern const asn_type  asn_base_int8_s;  /**< INTEGER (0..255)         */
extern const asn_type  asn_base_int9_s;  /**< INTEGER (0..511)         */
extern const asn_type  asn_base_int12_s; /**< INTEGER (0..4095)        */
extern const asn_type  asn_base_int16_s; /**< INTEGER (0..65535)       */
extern const asn_type  asn_base_int24_s; /**< INTEGER (0..16777215)    */
extern const asn_type  asn_base_int32_s; /**< INTEGER (0..4294967295)  */

extern const asn_type asn_base_uint32_s; /**< UINTEGER (0..4294967295) */






/**
 * Declaration of struct ASN.1 value
 */
struct asn_value;

/**
 * C type for presentation of ASN.1 value.
 */
typedef struct asn_value asn_value;

/**
 * Auxiliary container to represent both ASN.1
 * child value and its index within the parent
 */
struct asn_child_desc;
typedef struct asn_child_desc asn_child_desc_t;

/**
 * Init empty ASN.1 value of specified type.
 *
 * @param type       ASN.1 type to which value should belong
 *
 * @return pointer to new asn_value instance or NULL if error occurred.
 */
extern asn_value *asn_init_value(const asn_type *type);

/**
 * Macro to log failures of asn_init_value() function.
 */
#define ERROR_ASN_INIT_VALUE(_type) \
    ERROR("%s(): Failed to initialize ASN.1 value of type " #_type, \
          __FUNCTION__)


/**
 * Init empty ASN.1 value of specified type with a certain ASN.1 tag.
 *
 * @param type       ASN.1 type to which value should belong
 * @param tc         ASN.1 tag class, see enum definition and ASN.1 standard
 * @param tag        ASN.1 tag value, may be an arbitrary non-negative integer
 *
 * @return pointer to new asn_value instance or NULL if error occurred.
 */
extern asn_value *asn_init_value_tagged(const asn_type *type,
                                        asn_tag_class tc,
                                        asn_tag_value tag);

/**
 * Make a copy of ASN.1 value instance.
 *
 * @param value       ASN.1 value to be copied
 *
 * @return pointer to new asn_value instance or NULL if error occurred.
 */
extern asn_value *asn_copy_value(const asn_value *value);

/**
 * Move content of ASN.1 value to another ASN.1 value instance.
 *
 * @param dst       ASN.1 value, which content should be changed
 *                  to be identical to 'src'.
 * @param src       ASN.1 value to be copied.
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_assign_value(asn_value *dst, const asn_value *src);

/**
 * Free memory allocalted by ASN.1 value instance.
 *
 * @param value       ASN.1 value to be destroyed
 *
 * @return nothing
 */
extern void asn_free_value(asn_value *value);


/**
 * Obtain ASN.1 type to which specified value belongs.
 *
 * @param value       ASN.1 value which type is interested
 *
 * @return pointer to asn_type instance or NULL if error occurred.
 */
extern const asn_type *asn_get_type(const asn_value *value);

/**
 * Check ASN.1 value for particular type.
 *
 * @param value         ASN.1 value.
 * @param type          ASN.1 type.
 *
 * @return @c TRUE if @p value of type of @p type, @c FALSE otherwise.
 */
extern te_bool asn_check_type(const asn_value *value, const asn_type *type);



/*
 * Text processing methods
 */


/**
 * Parse textual presentation of single ASN.1 value of specified type and
 * create a new instance of asn_value type with its internal presentation.
 * @note Text should correspoind to the "Value" production label in ASN.1
 * specification.
 *
 * @param string        text to be parsed
 * @param type          expected type of value
 * @param parsed_val    parsed value (OUT)
 * @param parsed_syms   number of parsed symbols (OUT)
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_parse_value_text(const char *string,
                                     const asn_type *type,
                                     asn_value **parsed_val,
                                     int *parsed_syms);

/**
 * Read ASN.1 text file, parse DefinedValue of specified ASN.1 type
 *
 * @param filename      name of file to be parsed
 * @param type          expected type of value
 * @param parsed_value  parsed value (OUT)
 * @param syms_parsed   quantity of parsed symbols in 'text' (OUT)
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_parse_dvalue_in_file(const char *filename,
                                         const asn_type *type,
                                         asn_value **parsed_value,
                                         int *syms_parsed);


/**
 * Prepare textual ASN.1 presentation of passed value and put it into
 * specified buffer.
 * This method writes trailing zero to the text buffer, and checks that
 * there is space for it, but does not include it in amount of
 * printed symbols - excactly like standard snprintf().
 *
 * Besides, if required buffer length is greater, then passed, last buffer
 * byte will be set to zero, and textual presentation of value will be
 * printed so match, as possible. In this case asn_sprint_value will return
 * amount of total number of bytes, which are required for this value.
 *
 * @param value         ASN.1 value to be printed
 * @param buffer        buffer for ASN.1 text
 * @param buf_len       length of buffer
 * @param indent        current indent, usually zero
 *
 * @return number characters should be written to buffer
 * (without trailing zero), or -1 if error occured.
 */
extern int asn_sprint_value(const asn_value *value, char *buffer,
                            size_t buf_len, unsigned int indent);

/**
 * Prepare textual ASN.1 presentation of passed value and save this string
 * to file with specified name. If file already exists, it will be
 * overwritten.
 *
 * @param value         ASN.1 value to be stored
 * @param filename      name of the file
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_save_to_file(const asn_value *value,
                                 const char *filename);






/*
 * BER encode/decode, unsupported now...
 */


/**
 * BER encoding of passed ASN.1 value.
 *
 * @param buf           pointer to buffer to be filled by coded data
 * @param buf_len       length of accessible buffer, function puts here
 *                      length of encoded data (IN/OUT)
 * @param value         asn value to be encoded
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_encode(void *buf, size_t *buf_len, asn_value *value);

/**
 * BER decoding of passed data.
 *
 * @param data          pointer to data to be decoded
 *
 * @return pointer to new asn_value instance or NULL if error occurred.
 */
extern asn_value *asn_decode(const void *data);






/*
 *  ================== New API routines ==================
 */


/**
 * Find ASN.1 CHOICE values identified by the given tag value from
 * child ASN.1 values inside the given SEQUENCE_OF ASN.1 container
 *
 * @param container     ASN.1 container
 * @param tag_value     ASN.1 tag value
 * @param items_out     Location for the array of descriptors
 *                      containing values which correspond to
 *                      @p tag_value and their serial numbers
 * @param nb_items_out  Location for the size of @p items_out
 *
 * @return Status code
 */
extern te_errno asn_find_child_choice_values(const asn_value   *container,
                                             asn_tag_value      tag_value,
                                             asn_child_desc_t **items_out,
                                             unsigned int      *nb_items_out);

/**
 * Dedicated wrapper for @b asn_find_child_choice_values()
 * to get the first matching choice value in the container
 */
extern asn_value *asn_find_child_choice_value(const asn_value *container,
                                              asn_tag_value    tag_value);

/**
 * Given an ASN.1 CHOICE array and a tag, look up the first element
 * which, when unfolded, resolves to a value matching the given tag.
 *
 * @param nb_values The number of elements in ASN.1 CHOICE array
 * @param values    ASN.1 CHOICE array
 * @param tag       ASN.1 tag
 *
 * @return First matching ASN.1 CHOICE unfolded value or @c NULL
 */
extern asn_value *asn_choice_array_look_up_value(unsigned int    nb_values,
                                                 asn_value     **values,
                                                 asn_tag_value   tag);

/**
 * Free one-level subvalue of constraint ASN.1 value instance by tag.
 * For CHOICE syntax value tag is ignored.
 *
 * @param value       ASN.1 value which subvalue should be destroyed
 * @param tag_class   class of ASN.1 tag
 * @param tag_val     value of ASN.1 tag
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_free_child(asn_value *value,
                               asn_tag_class tag_class,
                               asn_tag_value tag_val);

/**
 * Free subvalue of constraint ASN.1 value instance, which may be
 * very deep in value-constrain tree.
 *
 * @param value       ASN.1 value which subvalue should be destroyed
 * @param labels      string with dot-separated sequence of textual field
 *                    labels, specifying subvalue in ASN.1 value tree with
 *                    'container' as a root. Label for 'SEQUENCE OF' and
 *                    'SET OF' subvalues is decimal notation of its integer
 *                    index in array. Choice labels shouls be prepended by
 *                    symbol '#'
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_free_descendant(asn_value *value, const char *labels);



/**
 * Find descendant value in ASN.1 value tree by textual labels specifier.
 * This method fails and return NULL if specified subvalue does not
 * exists in 'value'.
 * Besides, if some CHOICE specifier is absent, this methods
 * silently go down to specific value.
 *
 * NOTE for user: do not change got subvalue, if you are not sure,
 * what are you doing. Especially - do not free it!
 *
 * @param value         Root of ASN.1 value tree.
 * @param status        Location of status of operation,
 *                      allways changed unless NULL (OUT).
 * @param labels_fmt    Format (*printf-like) string for labels string.
 * @param ...           Respective parameters for format string.
 *
 * @return pointer to found subvalue.
 */
extern asn_value *asn_find_descendant(const asn_value *value,
                                      te_errno *status,
                                      const char *labels_fmt, ...);


/**
 * Find descendant value in ASN.1 value tree by textual labels specifier.
 * This method creates subvalue, respective to labels, if it is absent
 * in 'value'.
 * If some CHOICE specifier is absent, but there is specific subvalue
 * at that node, this methods fails and set 'status' to TE_EASNWRONGLABEL.
 *
 * NOTE for user: do not change got subvalue, if you are not sure,
 * what are you doing. Especially - do not free it!
 *
 * @param value         Root of ASN.1 value tree.
 * @param status        Location of status of operation,
 *                      allways changed unless NULL (OUT).
 * @param labels_fmt    Format (*printf-like) string for labels string.
 * @param ...           Respective parameters for format string.
 *
 * @return pointer to found subvalue.
 */
extern asn_value *asn_retrieve_descendant(asn_value *value,
                                          te_errno *status,
                                          const char *labels_fmt, ...);



/**
 * Get descendent subvalue of some ASN.1 value with COMPOUND syntax.
 * Got subvalue should NOT be freed!
 *
 * This method is much faster then "asn_read_component_value' because
 * it does not make external copy of subvalue.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param subval        location for pointer to ASN.1 sub-value (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_descendent(const asn_value *container,
                                   asn_value **subval,
                                   const char *labels);



/**
 * Put descendent subvalue to some ASN.1 value with COMPOUND syntax.
 * Passed ASN.1 value simply inserted into tree without copy, old
 * value on respective place is freed!
 *
 * @param container     Root of ASN.1 value tree.
 * @param subval        ASN.1 sub-value which should be inserted, may
 *                      be NULL, if respecive part of 'container'
 *                      just should be cleared.
 * @param labels        Textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description.
 *
 * @return zero on success or error code.
 */
extern te_errno asn_put_descendent(asn_value *container,
                                   asn_value *subval,
                                   const char *labels);


/**
 * Insert array element in indexed syntax (i.e. 'SEQUENCE OF' or 'SET OF')
 * subvalue of root ASN.1 value container.
 * Passed subvalue will NOT copied, do not free it after this method!
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param elem_value    ASN.1 value to be placed into the array, specified
 *                      by labels at place, specified by index
 * @param index         array index of place to which element should be
 *                      inserted
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_insert_indexed(asn_value *container,
                                   asn_value *elem_value,
                                   int index, const char *labels);

/**
 * Remove array element from indexed syntax (i.e. 'SEQUENCE OF' or 'SET OF')
 * subvalue of root ASN.1 value container.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param index         array index of element to be removed
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_remove_indexed(asn_value *container,
                                   int index, const char *labels);

/**
 * Get subvalue of ASN.1 value with indexed ('SEQUENCE OF' or 'SET OF')
 * syntax. Got subvalue should NOT be freed!
 *
 * This method does not make external copy of subvalue.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param subval        location for pointer to ASN.1 sub-value (OUT)
 * @param index         index of subvalue
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_indexed(const asn_value *container,
                                asn_value **subval,
                                int index, const char *labels);


/**
 * Write primitive syntax value.
 *
 * @param value         ASN.1 value with primitive syntax.
 * @param data          Data to be written, should be in nature
 *                      C format for data type respective to leaf syntax.
 * @param d_len         Length of the data.
 *                      Measured in octets for all types except OID and
 *                      BIT_STRING; for OID measured in sizeof(int);
 *                      for BIT_STRING measured in bits.
 *
 * @return zero on success or error code.
 */
extern te_errno asn_write_primitive(asn_value *value,
                                    const void *data, size_t d_len);




/**
 * Put 'value' as CHOICE of 'container'. Free other subvalue of
 * 'container', if there is one.
 * Check that type of 'value' is one of possible choices in 'container'.
 *
 * @param value         ASN.1 value of CHOICE syntax, which subvalue
 *                      should be changed.
 * @param value         ASN.1 value to be put into 'container'.
 *
 * @return status code
 */
extern te_errno asn_put_choice(asn_value *container, asn_value *value);


/**
 * Convert 'extended' ASN.1 path (set of labels) to ordinary one for given
 * asn_value.
 *
 * Extended ASN.1 path could have search expression instead of one (or
 * several) labels. Only index labels could be replaced (i.e. it is
 * possible only for SEQUENCE_OF and SET_OF types) and subtype has to be
 * SEQUENCE or SET. The syntax is following:
 *   <optional labels>.[<label>:<asn text value>].<other optional labels>
 * Square brackets are part of format. The asn_value corresponding to
 * <optional labels> is iterated and for each member the <label> value is
 * compared to <asn text value>. If comparison is successful, then whole
 * search expression is replaced by index. There could be several labels in
 * the search expression, they are separated by ',' then.
 *
 * @param node          Root ASN.1 value to start searching for labels
 * @param ext_path      Extended ASN.1 path with search expressions
 * @param asn_path      Buffer for normal ASN.1 path
 * @param asn_path_len  asn_path buffer length
 * @param auto_insert   Insert items if search fail
 *
 * @return  Status code
 */
te_errno asn_path_from_extended(asn_value *node, const char *ext_path,
                                char *asn_path, unsigned int asn_path_len,
                                te_bool auto_insert);

/**
 * Inserts 'value' into root_node ASN.1 value.
 *
 * ext_path must be of format
 *   <labels>.[<label>:<asn text value>]
 *
 * 'value' will be inserted as a subvalue of '<labels>' value, its index
 * will be stored in 'index' variable and after that <asn text value> will
 * be assigned to field named <label> of newly inserted ASN.1 value. Several
 * labels could be specified in [], separate with ','.
 *
 * @param root_node  Root ASN.1 value to start searching for labels
 * @param ext_path   Extended ASN.1 path with search expressions
 * @param value      ASN.1 value to be inserted
 * @param index      Index of 'value' after insertion into container (OUT)
 *
 * @return   Status code
 */
int asn_insert_value_extended_path(asn_value *root_node,
                                   const char *ext_path,
                                   asn_value *value,
                                   int *index);


/**
 * Check that everything that is in the 'value' is in the 'container'.
 *
 * @param container  ASN.1 value to be compared against
 * @param value      ASN.1 value to be compared
 *
 * @return Status code
 */
te_errno
asn_check_value_contains(asn_value *container, asn_value *value);

/*
 * ======================================================================
 * All methods below are deprecated, or will become such in nearest
 * future. It is recommended to use methods above, if there is
 * applicable to your task.
 * ======================================================================
 */





/**
 * Free subvalue of constraint ASN.1 value instance.
 *
 * @param value       ASN.1 value which subvalue should be destroyed
 * @param labels      string with dot-separated sequence of textual field
 *                    labels, specifying subvalue in ASN.1 value tree with
 *                    'container' as a root. Label for 'SEQUENCE OF' and
 *                    'SET OF' subvalues is decimal notation of its integer
 *                    index in array. Choice labels shouls be prepended by
 *                    symbol '#'
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_free_subvalue(asn_value *value, const char *labels);

/**
 * Variadic version of @c asn_free_subvalue().
 */
extern te_errno asn_free_subvalue_fmt(asn_value  *container,
                                      const char *labels_fmt,
                                      ...)
                                      __attribute__((format(printf, 2, 3)));

/**
 * Free one-level subvalue of constraint ASN.1 value instance by tag.
 * For CHOICE syntax value tag is ignored.
 *
 * @param value       ASN.1 value which subvalue should be destroyed
 * @param tag_class   class of ASN.1 tag
 * @param tag_val     value of ASN.1 tag
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_free_child_value(asn_value *value,
                                     asn_tag_class tag_class,
                                     asn_tag_value tag_val);







/**
 * Put ASN.1 value to the named one-depth leaf to the ASN.1 value.
 * Free old leaf subvalue, if there was one.
 * Subvalue is not copied, but inserted into ASN.1 tree of 'container' as is.
 *
 * @param container     ASN.1 value which child should be updated,
 *                      have to be of syntax SEQUENCE, SET, or CHOICE
 * @param subvalue      new ASN.1 value for child
 * @param tag_class     class of ASN.1 tag
 * @param tag_val       value of ASN.1 tag
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_put_child_value(asn_value *container,
                                    asn_value *subvalue,
                                    asn_tag_class tag_class,
                                    asn_tag_value tag_val);

/**
 * The same as 'asn_put_child_value', but take as child specificator
 * its character label instead of tag.
 *
 * @param container     ASN.1 value which child should be updated,
 *                      have to be of syntax SEQUENCE, SET, or CHOICE
 * @param subvalue      new ASN.1 value for child
 * @param label         character label of child
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_put_child_value_by_label(asn_value *container,
                                             asn_value *subvalue,
                                             const char *label);


/**
 * Write data into primitive syntax leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param data          data to be written, should be in nature C format for
 *                      data type respective to leaf syntax
 * @param d_len         length of the data
 *                      Measured in octets for all types except OID and
 *                      BIT_STRING; for OID measured in sizeof(int)
 *                      for BIT_STRING measured in bits
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_value_field(asn_value *container,
                                      const void *data, size_t d_len,
                                      const char *labels);

/**
 * Variadic version of @c asn_write_value_field().
 */
extern te_errno asn_write_value_field_fmt(asn_value  *container,
                                          const void *data,
                                          size_t      len,
                                          const char *labels_fmt,
                                          ...)
                                          __attribute__((format(printf, 4, 5)));

/**
 * Read data from primitive syntax leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param data          pointer to buffer for read data (OUT)
 * @param d_len         length of available buffer / read data (IN/OUT).
 *                      Measured in octets for all types except OID and
 *                      BIT_STRING; for OID measured in sizeof(int),
 *                      for BIT_STRING measured in bits
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_read_value_field(const asn_value *container,
                                     void *data, size_t *d_len,
                                     const char *labels);

/**
 * Variadic version of @c asn_read_value_field().
 */
extern te_errno asn_read_value_field_fmt(const asn_value  *container,
                                         void             *data,
                                         size_t           *len,
                                         const char       *labels_fmt,
                                         ...)
                                         __attribute__((format(printf, 4, 5)));

/**
 * Get primitive value of enumeration type from ASN.1 value.
 *
 * @param[in]  container    ASN.1 value containing data of enumeration type.
 * @param[out] value        Primitive value.
 *
 * @return Status code.
 */
extern te_errno asn_get_enum(const asn_value *container, int32_t *value);

/**
 * Get enumeration value name.
 *
 * @note Return value must not be modified, since it points to @p container
 * internals.
 *
 * @param[in]  container    ASN.1 value containing data of enumeration type.
 * @param[out] name         Name of value of enumeration type.
 *
 * @return Status code.
 */
extern te_errno asn_get_enum_name(const asn_value *container,
                                  const char **name);

/**
 * Write 32-bit integer into leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         integer value to be written
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_int32(asn_value *container,
                                int32_t value, const char *labels);

/**
 * Read 32-bit integer from leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         place for integer value to be read (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_read_int32(const asn_value *container,
                               int32_t *value, const char *labels);

/**
 * Write 32-bit unsigned integer into leaf in specified ASN.1 value.
 *
 * @param container     Pointer to ASN.1 value.
 * @param value         Value to be written.
 * @param labels        Textual ASN.1 labels of a leaf which should be
 *                      changed; see asn_free_subvalue() method for more
 *                      information.
 *
 * @return Status code.
 */
extern te_errno asn_write_uint32(asn_value *container,
                                 uint32_t value, const char *labels);

/**
 * Read 32-bit unsigned integer from a leaf in specified ASN.1 value.
 *
 * @param container     Pointer to ASN.1 value.
 * @param value         Where to save read value.
 * @param labels        Textual ASN.1 labels of a leaf from which to read
 *                      value; see asn_free_subvalue() method for more
 *                      information.
 *
 * @return Status code.
 */
extern te_errno asn_read_uint32(const asn_value *container,
                                uint32_t *value, const char *labels);

/**
 * Write boolean into leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         boolean value to be written
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_bool(asn_value *container,
                               te_bool value, const char *labels);

/**
 * Read boolean from leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         place for boolean value to be read (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_read_bool(const asn_value *container,
                              te_bool *value, const char *labels);

/**
 * Write character string into leaf in specified ASN.1 value.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         string to be written
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_string(asn_value *container,
                                 const char *value, const char *labels);

/**
 * Read character string from leaf in specified ASN.1 value.
 * User have to free() got pointer to string.
 *
 * @param container     pointer to ASN.1 value which leaf field is interested
 * @param value         place for pointer to read string (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_read_string(const asn_value *container,
                                char **value, const char *labels);


/**
 * Write component of COMPOUND subvalue in ASN.1 value tree.
 *
 * @param container     root of ASN.1 value tree which subvalue to be changed
 * @param elem_value    ASN.1 value to be placed into the tree at place,
 *                      specified by labels
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_component_value(asn_value *container,
                                          const asn_value *elem_value,
                                          const char *labels);

/**
 * Read component of COMPOUND subvalue in ASN.1 value tree.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param elem_value    read ASN.1 value, copy of subtree specified by
 *                      labels argument (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_read_component_value(const asn_value *container,
                                         asn_value **elem_value,
                                         const char *labels);


/**
 * Replace array element in indexed ('SEQUENCE OF' or 'SET OF') subvalue
 * of root ASN.1 value container.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param elem_value    ASN.1 value to be placed into the array, specified
 *                      by labels at place, specified by index
 * @param index         array index of element to be replaced
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success, otherwise error code.
 */
extern te_errno asn_write_indexed(asn_value *container,
                                  const asn_value *elem_value,
                                  int index,
                                  const char *labels);

/**
 * Read array element in indexed ('SEQUENCE OF' or 'SET OF') subvalue
 * of root ASN.1 value 'container'.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param index         array index of element to be read
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return pointer to new asn_value instance or NULL if error occurred.
 */
extern asn_value *asn_read_indexed(const asn_value *container,
                                    int index, const char *labels);

/**
 * Get length of subvalue of root ASN.1 value container.
 * Semantic of length value depends on the ASN.1 syntax.
 *    primitive syntax:
 *        INTEGER --
 *            zero for usual native 'int' or number of bits used.
 *        LONG_INT, CHAR_STRING, OCT_STRING, REAL --
 *            number of octets;
 *        OBJECT IDENTIFIER --
 *            number of sub-ids, which sub-id has usual for
 *            current architecture size of 'int';
 *        BIT_STRING -- number of bits;
 *    constraint syntax:
 *          number of sub-values; should be one or zero (for non-complete
 *          values) for CHOICE and TAGGED syntacies.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return length subvalue, -1 if error occurred.
 */
extern int asn_get_length(const asn_value *container, const char *labels);

/**
 * Obtain ASN.1 syntax of specified field in value.
 *
 * @param value          ASN.1 value which leaf syntax is interested
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return syntax of specified leaf in value.
 */
extern asn_syntax asn_get_syntax(const asn_value *value,
                                 const char *labels);



/**
 * Get choice in subvalue of root ASN.1 value container.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 *
 * @return pointer to label or NULL on error.
 */
extern const char *asn_get_choice_ptr(const asn_value *container);

/**
 * Get choice in subvalue of root ASN.1 value container.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *                      Subvalue should have ASN.1 syntax CHOICE
 * @param choice_label  string with label of choice in ASN.1 value (OUT)
 * @param ch_lb_len     length of available buffer in choice_label
 *
 * @return zero or error code.
 */
extern te_errno asn_get_choice(const asn_value *container,
                               const char *labels,
                               char *choice_label, size_t ch_lb_len);


/**
 * Get name of value;
 *
 * @param container     value which name is interested
 *
 * @return value's name or NULL.
 */
extern const char *asn_get_name(const asn_value *container);


/**
 * Get constant pointer to subvalue of some ASN.1 value with COMPOUND
 * syntax.
 * User may to try discard 'const' qualifier of obtained subvalue only
 * if he (she) knows very well what he doing with ASN.1 value.
 * In particular, got subvalue should NOT be freed!
 *
 * This method is much faster then "asn_read_component_value'
 * because it does not make external copy of subvalue.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param subval        location for pointer to ASN.1 sub-value (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_subvalue(const asn_value *container,
                                 asn_value ** subval, const char *labels);



/**
 * Get constant pointer to direct subvalue of ASN.1 value with named syntax
 * ('SEQUENCE' or 'SET') by its tag. If there are more then one
 * child with specified tag, method return first found.
 *
 * User may try to discard 'const' qualifier of obtained subvalue only
 * if he (she) knows very well what he doing with ASN.1 value.
 * In particular, got subvalue should NOT be freed!
 *
 * This method is much faster then "asn_read_component_value' because
 * it does not make external copy of subvalue.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param subval        location for pointer to ASN.1 sub-value (OUT)
 * @param tag_class     class of ASN.1 tag
 * @param tag_val       value of ASN.1 tag
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_child_value(const asn_value *container,
                                    const asn_value **subval,
                                    asn_tag_class tag_class,
                                    asn_tag_value tag_val);


/**
 * Get constant pointer to direct subvalue of ASN.1 value with CHOICE syntax.
 *
 * User may try to discard 'const' qualifier of obtained subvalue only
 * if he (she) knows very well what he doing with ASN.1 value.
 * In particular, got subvalue should NOT be freed!
 *
 * This method is much faster then "asn_read_component_value' because
 * it does not make external copy of subvalue.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param subval        location for pointer to ASN.1 sub-value (OUT)
 * @param tag_class     class of ASN.1 tag of subvalue (OUT)
 * @param tag_val       value of ASN.1 tag of subvalue (OUT)
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_choice_value(const asn_value *container,
                                     asn_value **subval,
                                     asn_tag_class *tag_class,
                                     asn_tag_value *tag_val);

/**
 * Get constant pointer to data related to leaf plain-syntax sub-value
 * of ASN.1 value.
 *
 * Got pointer should NOT be freed!
 *
 * Write to got memory location is acceptable in case of simple data syntax
 * (e.g. PrintableString or INTEGER) and if new data has length not greater
 * then set in ASN.1 value leaf; user has no way to change data length except
 * via 'asn_write_value_field' method.
 *
 * This method is much faster then "asn_read_value_field' because it does
 * not copy data to user location, with large octet strings or OIDs
 * it may be significant.
 *
 * @param container     root of ASN.1 value tree which subvalue is interested
 * @param data_ptr      pointer to location for plain data pointer;
 *                      usually it should be something like '&str', where
 *                      'srt' has type 'const char *' (OUT)
 * @param labels        textual ASN.1 labels of subvalue; see
 *                      asn_free_subvalue method for more description
 *
 * @return zero on success or error code.
 */
extern te_errno asn_get_field_data(const asn_value *container,
                                   void *data_ptr, const char *labels);



/**
 * Get tag of value;
 *
 * @param container     value which name is intereseted
 *
 * @return value's name or NULL.
 */
extern asn_tag_value asn_get_tag(const asn_value *container);


/**
 * Count required length of string for textual presentation
 * of specified value, without trailing zero byte.
 * So, while using this method to calculate required buffer,
 * add 1 to got value.
 *
 * @param value         ASN.1 value
 * @param indent        current indent, usually should be zero
 *
 * @return length the number of bytes required for textual
 *         presentation of specified value.
 */
extern size_t asn_count_txt_len(const asn_value *value,
                                unsigned int indent);


/**
 * Set the mark to ASN.1 value, which is arbitrary integer, which
 * semantic is user-free.
 *
 * @param value         Pointer to the ASN.1 value.
 * @param mark          Mark to be set.
 *
 * @return status code.
 */
extern te_errno asn_put_mark(asn_value *value, int mark);

/**
 * Get the mark of ASN.1 value.
 *
 * @param value         Pointer to the ASN.1 value.
 * @param mark          Location for the mark of value.
 *
 * @return status code.
 */
extern te_errno asn_get_mark(const asn_value *value, int *mark);


/**
 * Typedef for user method to be called during walk over ASN.1 value
 * tree.
 *
 */
typedef te_errno (* walk_method)(asn_value *value, void *user_ptr);

/**
 * Walk over all subvalues tree of ASN.1 value.
 * Order of walk is depth-first. Walk stops if user callback
 * return non-zero status.
 *
 * @param container     Pointer to the ASN.1 value which subvalues
 *                      should be iterated.
 * @param only_leafs    Boolean flag, if TRUE, user callback will
 *                      will be called only for the leafs, i.e.
 *                      for nodes without sub-values: either
 *                      primitive or empty compound.
 * @param status        Location for user status of walk: if callback
 *                      return non-zero, walk stops and callback
 *                      return code will be put here. Should be zero
 *                      before start.
 * @param func          User callback, which should be called for each
 *                      subvalue.
 * @param user_ptr      User parameter for callback.
 *
 * @return status code.
 */
extern te_errno asn_walk_depth(asn_value *container, te_bool only_leafs,
                               te_errno *status, walk_method func,
                               void *user_ptr);

/**
 * Walk over all subvalues tree of ASN.1 value.
 * Order of walk is breadth-first. Walk stops if user callback
 * return non-zero status.
 *
 * @param container     Pointer to the ASN.1 value which subvalues
 *                      should be iterated.
 * @param only_leafs    Boolean flag, if TRUE, user callback will
 *                      will be called only for the leafs, i.e.
 *                      for nodes without sub-values: either
 *                      primitive or empty compound.
 * @param status        Location for user status of walk: if callback
 *                      return non-zero, walk stops and callback
 *                      return code will be put here.
 * @param func          User callback, which should be called for each
 *                      subvalue.
 * @param user_ptr      User parameter for callback.
 *
 * @return status code.
 */
extern te_errno asn_walk_breadth(asn_value *container, te_bool only_leafs,
                                 te_errno *status, walk_method func,
                                 void *user_ptr);



#ifdef __cplusplus
} /* for 'extern "C" {' */
#endif
#endif /* __TE_ASN_USR_H__ */
