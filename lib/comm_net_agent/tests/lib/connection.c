/** @file
 * @brief Test Environment
 * Network Communication Library Tests - Test Agent side - Library
 * Connections
 *
 * Copyright (C) 2004-2022 OKTET Labs Ltd. All rights reserved.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <semaphore.h>

#include "comm_agent.h"
#include "messages.h"
#include "connection.h"
#include "workshop.h"
#include "synch.h"
#include "debug.h"

/* Initial random seed */
#define AGENT_RANDOM_SEED      101101101

/*
 * The upper boundary of the number of initial random commands.
 */
#define MAX_INITIAL_MESSAGES          10

/* The lower boundary of the number of initial random commands */
#define MIN_INITIAL_MESSAGES          1

/* The minimum size of the random commands being generated */
#define MIN_RANDOM_COMMAND_SIZE       30

/* The maximum size of the random commands being generated */
#define MAX_RANDOM_COMMAND_SIZE       30000

/* Each 'OMIT_ATTACHMENT_FREQUENCY'-th command will miss the attachment */
#define OMIT_ATTACHMENT_FREQUENCY     4

/* The maximal size of the random attachment */
#define MAX_RANDOM_ATTACHMENT_SIZE    30000

/*
 * The number of initial random messages sent before the actual
 * testing will happen. The value is shared by both threads.
 * It is generated by the remote_presend_random() routine.
 * After setting the value, this routine sem_post()s the semaphore
 * random_number_semaphore, so that the local_receive_random()
 * routine can read the value of this variable.
 */
int   initial_messages_no = -1;
/*
 * This semaphore allows the local station to access the initial_messages_no
 * variable
 */
extern sem_t random_number_semaphore;   /* see synch.h */

/*
 * This semaphore allows both threads to synchronize after sending/receiving
 * each initial random message. The remote station waits until the local
 * station has checked the recently sent message, before sending a new
 * message
 */
extern sem_t random_messages_semaphore;  /* see synch.h */

/* Port number at which the local station will be listening for connections */
char  *local_port_no = "5000";

/* Network Communication Library connection handle */
struct rcf_comm_connection *handle = NULL;

/* Communication socket used by the remote station */
int remote_socket = -1;

/*
 * Usually 'output_buffer' is used by the remote station, and 'input_buffer'
 * is used by the local station. But in rare cases, when agent's transmitting
 * activity is tested, the things will be the other way around.
 */
char *input_buffer = NULL;           /* Input buffer for messages */
int   total_input_buffer_length;     /* Size of the buffer as allocated */
int   declared_input_buffer_length;  /* Size of the data on the buffer,
                                  * as in the customs declaration   */

char *output_buffer = NULL;          /* Output buffer for messages */
int   total_output_buffer_length;    /* Size of the buffer as allocated */
int   declared_output_buffer_length; /* Size of the data on the buffer,
                                  * as in the customs declaration   */

/*
 * These buffers are used for transferring initial random messages.
 * The above _length variables are also used to indicate the sizes of them.
 */
char *random_input_buffer = NULL;
char *random_output_buffer = NULL;

/**
 * Initializes the agent side connection.
 *
 * @retval  0           Connection opened successfully
 * @retval  1           Connection initialization failed due to
 *                      the Network Communication Library API failure
 */
int
local_connection_init(void)
{
    int  err;
    char err_buf[BUFSIZ];

    /* synchronize at the level of connection */
    local_synch(SYNCH_AGENT_CONNECTION_READY);

    err = rcf_comm_agent_init(local_port_no, &handle);
    if (err != 0)
    {
       strerror_r(err, err_buf, sizeof(err_buf));
       fprintf(stderr, "local_connection_init: rcf_comm_agent_init() "
              "failed: %s\n", err_buf);
       return 1;
    }

    DEBUG("local_connection_init: rcf_comm_agent_init() ok\n");

    return 0;
}

/**
 * Shuts down the agent side connection.
 *
 * @return  n/a
 */
void
local_connection_close(void)
{
    if (input_buffer != NULL)
       free(input_buffer);       /* though, it not necessarily has
                                 been allocated by the local station */
    /* ignore the return value */
    if (handle != NULL)
       rcf_comm_agent_close(&handle);
}

/**
 * Initializes the remote station's side connection. Sets random seed.
 *
 * @retval  0           Connection opened successfully
 * @retval  1           Connection initialization failed
 */
int
remote_connection_init(void)
{
    struct sockaddr_in addr;

    /* create the socket */
    remote_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (remote_socket < 0)
    {
       char err_buf[BUFSIZ];

       strerror_r(errno, err_buf, sizeof(err_buf));
       fprintf(stderr, "\t\t\tremote_connection_init: "
              "can't create a socket: %s\n", err_buf);
       exit(1);
    }

    /* synchronize at the level of connecting */
    remote_synch(SYNCH_AGENT_CONNECTION_READY);

    /* now connect */
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(atoi(local_port_no));
    addr.sin_addr.s_addr = inet_addr(LOCAL_STATION_ADDRESS);
    if (connect(remote_socket, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
       char err_buf[BUFSIZ];

       strerror_r(errno, err_buf, sizeof(err_buf));
       fprintf(stderr, "\t\t\tremote_connection_init: can't connect to "
              "the agent: %s\n", err_buf);
       return 1;
    }

    /* set the random seed */
    srandom(AGENT_RANDOM_SEED);

    return 0;
}

/**
 * Shuts down the remote station's side connection
 *
 * @return      n/a
 */
void
remote_connection_close(void)
{
    sem_destroy(&random_messages_semaphore);
    sem_destroy(&random_number_semaphore);

    if (output_buffer != NULL)
    {
       free(output_buffer);       /* though, it not necessarily has
                                  been allocated by the remote station */
       output_buffer = NULL;
    }

    if (remote_socket >= 0)
       close(remote_socket);
}

/**
 * Allocates memory for the input buffer of size 'size' with declared size
 * 'declared_size'.
 *
 * @param   size           total size of the buffer
 * @param   declared_size  declared size of the buffer
 *
 * @return  the pointer to the allocated area
 */
char *
alloc_input_buffer(int size, int declared_size)
{
    char *ptr;

    ptr = malloc(size);
    if (ptr == NULL)
    {
       fprintf(stderr, "alloc_input_buffer: malloc() failed\n");
       exit(1);
    }
    total_input_buffer_length = size;
    declared_input_buffer_length = declared_size;
    input_buffer = ptr;

    return ptr;
}

/**
 * Allocates memory for the output buffer of size 'size' with declared size
 * 'declared_size'.
 *
 * @param   size           total size of the buffer
 * @param   declared_size  declared size of the buffer
 *
 * @return  the pointer to the allocated area
 */
char *
alloc_output_buffer(int size, int declared_size)
{
    char *ptr;

    ptr = malloc(size);
    if (ptr == NULL)
    {
       fprintf(stderr, "alloc_output_buffer: malloc() failed\n");
       exit(1);
    }
    total_output_buffer_length = size;
    declared_output_buffer_length = declared_size;
    output_buffer = ptr;

    return ptr;
}

/**
 * Transmits as many as 'initial_messages_no' initial commands to
 * the local station.
 *
 *
 * @retval 0     Transmission successful
 * @retval 1     Transmission failed due to a failure (or improper
 *               behavior) at the local station.
 */
int
remote_presend_random()
{
    int i;
    int cmd_size, attach_size;
    int do_generate_attachment;

    /* generate the number of initial random commands */
    initial_messages_no = MIN_INITIAL_MESSAGES +
       (int)(random() % (MAX_INITIAL_MESSAGES - MIN_INITIAL_MESSAGES + 1));

    DEBUG("\t\t\tremote_presend_random: sending %d initial random messages\n",
         initial_messages_no);

    /*
     * post the semaphore so that the local station now can
     * read the value of the above variable
     */
    if (sem_post(&random_number_semaphore) < 0)
    {
       char err_buf[BUFSIZ];

       strerror_r(errno, err_buf, sizeof(err_buf));
       fprintf(stderr, "\t\t\tremote_presend_random: can't sem_post(): %s\n",
              err_buf);
       exit(1);
    }

    /* allocate a special temporary buffer */
    random_output_buffer = malloc(MAX_RANDOM_COMMAND_SIZE +
                              MAX_RANDOM_ATTACHMENT_SIZE);
    if (random_output_buffer == NULL)
    {
       fprintf(stderr, "\t\t\tremote_presend_random: can't malloc()\n");
       exit(1);
    }

    /* cycle over all initial messages */
    for (i = 0; i < initial_messages_no; i++)
    {
       char *buf_ptr;

       /*
        * Now we generate the size of the command and the size
        * of the attachment
        */
       cmd_size = MIN_RANDOM_COMMAND_SIZE +
           (int)(random() % (MAX_RANDOM_COMMAND_SIZE -
                           MIN_RANDOM_COMMAND_SIZE + 1));

       /* Now throw the dice if we should omit the attachment */
       do_generate_attachment =
           (random() % OMIT_ATTACHMENT_FREQUENCY != 0);

       if (do_generate_attachment)
       {
           /* Generate the size of the attachment */
           attach_size = (int)(random() % MAX_RANDOM_ATTACHMENT_SIZE) + 1;
       }
       else
       {
           attach_size = 0;
       }

       /* ok, now generate the message itself */
       generate_command(random_output_buffer, cmd_size, attach_size);

#if 0
       DEBUG("\t\t\tremote_presend_random: generated a command of size %d, "
             "attachment = %d\n", cmd_size, attach_size);
       DEBUG("\t\t\tThe command is:\n");
       random_output_buffer[cmd_size + attach_size - 1] = '\0';
       DEBUG("\t\t\t%s\n", random_output_buffer);
#endif

       declared_output_buffer_length = cmd_size + attach_size;

       /* now transmit it over the net */
       cmd_size += attach_size;   /* total size now */
       buf_ptr   = random_output_buffer;
       do {
           int sent;

           sent = write(remote_socket, buf_ptr, cmd_size);
           if (sent < 0)
           {
              char err_buf[BUFSIZ];

              strerror_r(errno, err_buf, sizeof(err_buf));
              fprintf(stderr,
                     "\t\t\tremote_presend_random: "
                     "can't write() to socket: %s\n",
                     err_buf);
              return 1;  /* we consider any network failures as
                           agent's unwillingness to obey our commands,
                           i.e. subordination violation */
           }
           cmd_size -= sent;
           buf_ptr  += sent;
       } while(cmd_size > 0);

       /* now wait while the local station reads and checks the message */
       if (sem_wait(&random_messages_semaphore) < 0)
       {
           char err_buf[BUFSIZ];

           strerror_r(errno, err_buf, sizeof(err_buf));
           fprintf(stderr,
                  "\t\t\tremote_presend_random: can't sem_wait(): %s\n",
                  err_buf);
           exit(1);
       }

       if (!CHECK_PROCEED())
       {
           return 1;  /* consistency check failed on the other side */
       }
    } /* for all initial messages */

    /* now free the initial buffer */
    free(random_output_buffer);

    return 0;
}

/**
 * Receives initial random messages from the remote station and
 * checks each message.
 *
 * @retval 0     All messages are ok
 * @retval 1     Receipt of messages failed due to malfunction of
 *               the Network Communication Library
 */
int
local_receive_random()
{
    int rc;
    int i, num_messages;

    /* wait the number's semaphore to rise */
    DEBUG("local_receive_random: waiting on the number's semaphore..\n");
    if (sem_wait(&random_number_semaphore) < 0)
    {
       char err_buf[BUFSIZ];

       strerror_r(errno, err_buf, sizeof(err_buf));
       fprintf(stderr, "local_receive_random: can't sem_wait(): %s\n",
              err_buf);
       exit(1);
    }
    DEBUG("local_receive_random: number's semaphore is up\n");

    /* now obtain the number of messages */
    if ((num_messages = initial_messages_no) < 0)
    {
       fprintf(stderr, "local_receive_random: couldn't obtain the number "
              "of initial messages\n");
       exit(2);
    }

    /* allocate a special temporary buffer */
    random_input_buffer = malloc(MAX_RANDOM_COMMAND_SIZE +
                             MAX_RANDOM_ATTACHMENT_SIZE);
    if (random_input_buffer == NULL)
    {
       fprintf(stderr, "local_receive_random: can't malloc()\n");
       exit(1);
    }

    DEBUG("local_receive_random: receiving %d initial random messages\n",
         num_messages);
    for (i = 0; i < num_messages; i++)
    {
       declared_input_buffer_length = MAX_RANDOM_COMMAND_SIZE +
                                       MAX_RANDOM_ATTACHMENT_SIZE;
       /* now obtain the whole message; the input buffer MUST be enough */
       rc = rcf_comm_agent_wait(handle, random_input_buffer,
                             &declared_input_buffer_length, NULL);
       if (rc != 0)
       {
           fprintf(stderr, "local_receive_random: rcf_comm_agent_wait() "
                  "failed(%d)\n", rc);
           FAIL_PROCEED();
           return 1;
       }

#if 0
       DEBUG("local_receive_random: received a buffer of length %d\n",
             declared_input_buffer_length);
       DEBUG("The buffer is:\n");
       DEBUG("%s\n", random_input_buffer);
       DEBUG("End of buffer\n");
#endif

       ZERO_ADJUST_INPUT_BUFFER(random_input_buffer,
                             declared_input_buffer_length);

       /* check the obtained buffer */
       if (compare_buffers(random_input_buffer,
                         declared_input_buffer_length,
                         random_output_buffer,
                         declared_output_buffer_length) != 0)
       {
           fprintf(stderr, "local_receive_random: buffers don't match\n");
           FAIL_PROCEED();
           return 1;
       }

       /*
        * post the semaphore to let the other side know it can now
        * send the next message
        */
       if (sem_post(&random_messages_semaphore) < 0)
       {
           char err_buf[BUFSIZ];

           strerror_r(errno, err_buf, sizeof(err_buf));
           fprintf(stderr,
                  "local_receive_random: can't sem_post(): %s\n", err_buf);
           exit(1);
       }
    } /* for (all messages) */

    /* now free the initial buffer */
    free(random_input_buffer);

    /* all messages are ok */
    return 0;
}

/**
 * Transfers the output buffer of the remote station to the local station.
 *
 * @return       n/a
 */
void
remote_transfer_buffer(void)
{
    char *p = output_buffer;
    int   size = declared_output_buffer_length;

    do {
       int sent;

       sent = write(remote_socket, p, size);

       if (sent < 0)
       {
           char err_buf[BUFSIZ];

           strerror_r(errno, err_buf, sizeof(err_buf));
           fprintf(stderr,
                  "\t\t\tremote_transfer_buffer: "
                  "can't write() to socket: %s\n", err_buf);
           exit(1);
       }
       size -= sent;
       p    += sent;
    } while(size > 0);
}
